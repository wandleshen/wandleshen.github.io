<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/2021/10/28/World/</url>
    <content><![CDATA[<blockquote>
<p>于浩歌狂热之际中寒;于天上看见深渊。于一切眼中看见无所有;于无所希望中得救。</p>
</blockquote>
<p>欢迎来到Wandleshen的博客，目前是一个计算机专业在读大学生，还有很多东西需要学习呢。</p>
<h2 id="主营业务"><a href="#主营业务" class="headerlink" title="主营业务"></a>主营业务</h2><ul>
<li><a href="https://wandleshen.github.io/tags/%E5%88%B7%E9%A2%98/">刷题感想</a></li>
<li><a href="https://wandleshen.github.io/tags/%E9%9A%8F%E7%AC%94/">日常随笔</a></li>
<li><a href="https://wandleshen.github.io/tags/%E6%B8%B8%E6%88%8F/">游戏分享</a></li>
<li><a href="https://wandleshen.github.io/tags/%E7%81%B5%E6%84%9F/">灵感记录</a></li>
</ul>
]]></content>
      <tags>
        <tag>主页</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟主播数据分析</title>
    <url>/2023/02/11/analysis/</url>
    <content><![CDATA[<p>本文是通过 jupyter notebook 转换而来，所有的代码和数据集都可以在<a href="https://github.com/wandleshen/vup-data-analysis/">这里</a>找到。</p>
<span id="more"></span>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>众所周知，ZJU 的计算机学院有两大势力——图形学和数据挖掘，作为一名普通的计算机专业学生，不得不品尝一下 data mining 的醍醐味。本文将以虚拟主播直播数据为例，介绍一些数据分析的基本方法，包括数据预处理、数据可视化、数据挖掘等。</p>
<p>注意：本文包含以下要素：强行拟合、嗯套模型、选择数据、显而易见。</p>
<h2 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h2><p>很明显，虚拟主播作为网络直播中的一个小小的分支，据我所知是没有一个现成的数据集可以使用的，所以我们需要自己抓取数据集。我们在这里使用 <a href="danmakus.com">danmakus</a> 的 API 来获取数据。</p>
<p>在数据集的规模上，我们选择 50 名不同的虚拟主播，获取它们最近的 50 场直播的收入和互动数据。这样的数据集规模足够我们进行一些简单的分析，但是也不至于太大，导致分析过程过于繁琐。这 50 名虚拟主播大多来自于 VirtualReal 企划（VR 信真的是），但是也有一部分来自其他的工会或者个人。当然这样的选取谈不上科学，因为这些大部分是我自己常看的或者比较知名的主播，所以其实并不具备什么典型性。他们的名称、所属的企划或工会、用户 ID 都会被手动输入到一个 csv 文件中，以便后续的数据抓取。</p>
<p>之后我们定义一个函数 <code>get_last_50_lives</code> 来获取最近的 50 场直播的数据， <code>get_live_detail</code> 来获得直播的详细信息，最终储存的数据将会有如下的字段：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>liver</code></td>
<td>主播名称</td>
</tr>
<tr>
<td><code>area</code></td>
<td>直播分区</td>
</tr>
<tr>
<td><code>danmakusCount</code></td>
<td>弹幕数量</td>
</tr>
<tr>
<td><code>startDate</code></td>
<td>直播开始时间</td>
</tr>
<tr>
<td><code>stopDate</code></td>
<td>直播结束时间</td>
</tr>
<tr>
<td><code>title</code></td>
<td>直播标题</td>
</tr>
<tr>
<td><code>totalIncome</code></td>
<td>直播总收入</td>
</tr>
<tr>
<td><code>watchCount</code></td>
<td>直播观看人数</td>
</tr>
<tr>
<td><code>interactionCount</code></td>
<td>直播互动数量</td>
</tr>
<tr>
<td><code>superchatIncome</code></td>
<td>直播 superchat 收入</td>
</tr>
<tr>
<td><code>superchatTimestampes</code></td>
<td>直播 superchat 时间戳</td>
</tr>
<tr>
<td><code>membershipIncome</code></td>
<td>直播大航海收入</td>
</tr>
<tr>
<td><code>membershipTimestampes</code></td>
<td>直播大航海时间戳</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># imports</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas.plotting <span class="keyword">import</span> scatter_matrix</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.dates <span class="keyword">as</span> mdates</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_last_50_lives</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    api_str = <span class="string">&#x27;https://ukamnads.icu/api/v2/channel?uId=&#123;0&#125;&#x27;</span></span><br><span class="line">    url = api_str.<span class="built_in">format</span>(<span class="built_in">id</span>)</span><br><span class="line">    lives = requests.get(url).json()[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;lives&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> lives[<span class="number">0</span>][<span class="string">&#x27;isFinish&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> lives[:<span class="number">50</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> lives[<span class="number">1</span>:<span class="number">51</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_live_detail</span>(<span class="params">live_id</span>):</span></span><br><span class="line">    api_str = <span class="string">&#x27;https://ukamnads.icu/api/v2/live?liveId=&#123;0&#125;&#x27;</span></span><br><span class="line">    url = api_str.<span class="built_in">format</span>(live_id)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        danmakus = requests.get(url).json()[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;danmakus&#x27;</span>]</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    superchatCount = <span class="number">0</span></span><br><span class="line">    superchatIncome = <span class="number">0</span></span><br><span class="line">    superchatTimestampes = []</span><br><span class="line">    membershipCount = <span class="number">0</span></span><br><span class="line">    membershipIncome = <span class="number">0</span></span><br><span class="line">    membershipTimestampes = []</span><br><span class="line">    <span class="keyword">for</span> danmaku <span class="keyword">in</span> danmakus:</span><br><span class="line">        <span class="keyword">if</span> danmaku[<span class="string">&#x27;type&#x27;</span>] == <span class="number">3</span>:</span><br><span class="line">            superchatCount += <span class="number">1</span></span><br><span class="line">            superchatIncome += danmaku[<span class="string">&#x27;price&#x27;</span>]</span><br><span class="line">            superchatTimestampes.append(danmaku[<span class="string">&#x27;sendDate&#x27;</span>])</span><br><span class="line">        <span class="keyword">elif</span> danmaku[<span class="string">&#x27;type&#x27;</span>] == <span class="number">2</span>:</span><br><span class="line">            membershipCount += <span class="number">1</span></span><br><span class="line">            membershipIncome += danmaku[<span class="string">&#x27;price&#x27;</span>]</span><br><span class="line">            membershipTimestampes.append(danmaku[<span class="string">&#x27;sendDate&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> [superchatCount, superchatIncome, superchatTimestampes, membershipCount, membershipIncome, membershipTimestampes]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get_last_50_lives(434401868)[0]</span></span><br><span class="line"><span class="comment"># get_live_detail(&#x27;63013fb9-a8e3-46b0-bd34-a479ad8c4858&#x27;)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dataframe will be like this</span></span><br><span class="line"><span class="comment"># | liver | area | danmakusCount | startDate | stopDate | timeDuration | title | totalIncome | watchCount </span></span><br><span class="line"><span class="comment"># | interactionCount | superchatCount | superchatIncome | superchatTimestamps | membershipCount | membershipIncome | membershipTimestamps |</span></span><br><span class="line"></span><br><span class="line">c_names = pd.read_csv(<span class="string">&#x27;vtb.csv&#x27;</span>, names=[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;affiliation&#x27;</span>, <span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">df = pd.DataFrame(columns=[<span class="string">&#x27;liver&#x27;</span>, <span class="string">&#x27;area&#x27;</span>, <span class="string">&#x27;danmakusCount&#x27;</span>, <span class="string">&#x27;startDate&#x27;</span>, <span class="string">&#x27;stopDate&#x27;</span>, <span class="string">&#x27;timeDuration&#x27;</span>, </span><br><span class="line">                            <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;totalIncome&#x27;</span>, <span class="string">&#x27;watchCount&#x27;</span>, <span class="string">&#x27;interactionCount&#x27;</span>, <span class="string">&#x27;superchatCount&#x27;</span>, </span><br><span class="line">                            <span class="string">&#x27;superchatIncome&#x27;</span>, <span class="string">&#x27;superchatTimestamps&#x27;</span>, <span class="string">&#x27;membershipCount&#x27;</span>, <span class="string">&#x27;membershipIncome&#x27;</span>, <span class="string">&#x27;membershipTimestamps&#x27;</span>])</span><br><span class="line"></span><br><span class="line">c_names.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>affiliation</th>
      <th>id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>七海Nana7mi</td>
      <td>vr</td>
      <td>434334701</td>
    </tr>
    <tr>
      <th>1</th>
      <td>中单光一</td>
      <td>vr</td>
      <td>434401868</td>
    </tr>
    <tr>
      <th>2</th>
      <td>内德维德</td>
      <td>independent</td>
      <td>90873</td>
    </tr>
    <tr>
      <th>3</th>
      <td>弥希Miki</td>
      <td>vr</td>
      <td>477317922</td>
    </tr>
    <tr>
      <th>4</th>
      <td>星弥Hoshimi</td>
      <td>vr</td>
      <td>477342747</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> c_names.iterrows():</span><br><span class="line">    lives = get_last_50_lives(<span class="built_in">int</span>(row[<span class="string">&#x27;id&#x27;</span>]))</span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">for</span> live <span class="keyword">in</span> lives:</span><br><span class="line">        live_detail = get_live_detail(live[<span class="string">&#x27;liveId&#x27;</span>])</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            df = df.append(&#123;</span><br><span class="line">                <span class="string">&#x27;liver&#x27;</span>: row[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;area&#x27;</span>: live[<span class="string">&#x27;area&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;danmakusCount&#x27;</span>: live[<span class="string">&#x27;danmakusCount&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;startDate&#x27;</span>: live[<span class="string">&#x27;startDate&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;stopDate&#x27;</span>: live[<span class="string">&#x27;stopDate&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;timeDuration&#x27;</span>: live[<span class="string">&#x27;stopDate&#x27;</span>]-live[<span class="string">&#x27;startDate&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;title&#x27;</span>: live[<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;totalIncome&#x27;</span>: live[<span class="string">&#x27;totalIncome&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;watchCount&#x27;</span>: live[<span class="string">&#x27;watchCount&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;interactionCount&#x27;</span>: live[<span class="string">&#x27;interactionCount&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;superchatCount&#x27;</span>: live_detail[<span class="number">0</span>],</span><br><span class="line">                <span class="string">&#x27;superchatIncome&#x27;</span>: live_detail[<span class="number">1</span>],</span><br><span class="line">                <span class="string">&#x27;superchatTimestamps&#x27;</span>: live_detail[<span class="number">2</span>],</span><br><span class="line">                <span class="string">&#x27;membershipCount&#x27;</span>: live_detail[<span class="number">3</span>],</span><br><span class="line">                <span class="string">&#x27;membershipIncome&#x27;</span>: live_detail[<span class="number">4</span>],</span><br><span class="line">                <span class="string">&#x27;membershipTimestamps&#x27;</span>: live_detail[<span class="number">5</span>]</span><br><span class="line">            &#125;, ignore_index=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line">    <span class="built_in">print</span>(row[<span class="string">&#x27;name&#x27;</span>] + <span class="string">&#x27;Done&#x27;</span>)</span><br><span class="line">df.to_hdf(<span class="string">&#x27;data.h5&#x27;</span>, key=<span class="string">&#x27;df&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>以上代码我略作修改之后扔服务器里跑了，为了“分布式”我将各个主播的数据拆分开储存，如果你也想要这个数据集，可以在<a href="https://github.com/wandleshen/vup-data-analysis/">这里</a>下载。</p>
<h3 id="经过漫长的等待"><a href="#经过漫长的等待" class="headerlink" title="经过漫长的等待"></a>经过漫长的等待</h3><p>我们得到的数据集是以有由 50 个 hdf 文件组成的文件夹的形式存在的，每个 hdf 文件都是一个主播的最近 50 场直播的数据。我们需要将这些数据整合到一个文件中，以便后续的分析。这里我们使用 <code>pandas</code> 来处理数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, _, files <span class="keyword">in</span> os.walk(<span class="string">&#x27;./h5s&#x27;</span>):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">&#x27;.h5&#x27;</span>):</span><br><span class="line">            joined = pd.read_hdf(<span class="string">&#x27;./h5s/&#x27;</span> + file)</span><br><span class="line">            df = pd.concat([df, joined], ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.shape)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<pre><code>(2477, 16)
</code></pre><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>liver</th>
      <th>area</th>
      <th>danmakusCount</th>
      <th>startDate</th>
      <th>stopDate</th>
      <th>timeDuration</th>
      <th>title</th>
      <th>totalIncome</th>
      <th>watchCount</th>
      <th>interactionCount</th>
      <th>superchatCount</th>
      <th>superchatIncome</th>
      <th>superchatTimestamps</th>
      <th>membershipCount</th>
      <th>membershipIncome</th>
      <th>membershipTimestamps</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟Singer</td>
      <td>2627</td>
      <td>1675951004000</td>
      <td>1675962058514</td>
      <td>11054514</td>
      <td>下面我来简单唱两句</td>
      <td>1754.0</td>
      <td>4078</td>
      <td>468</td>
      <td>16</td>
      <td>680</td>
      <td>[1675954450657, 1675955951334, 1675957817542, ...</td>
      <td>0</td>
      <td>0</td>
      <td>[]</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟Singer</td>
      <td>3762</td>
      <td>1675864738000</td>
      <td>1675876582848</td>
      <td>11844848</td>
      <td>赫赫，我来简单唱两句</td>
      <td>11057.0</td>
      <td>4928</td>
      <td>649</td>
      <td>12</td>
      <td>597</td>
      <td>[1675864937946, 1675865846334, 1675866462953, ...</td>
      <td>11</td>
      <td>7358</td>
      <td>[1675868606293, 1675868631905, 1675869343361, ...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>2167</td>
      <td>1675727764000</td>
      <td>1675736225954</td>
      <td>8461954</td>
      <td>早上好！唱一会儿~</td>
      <td>3852.0</td>
      <td>3382</td>
      <td>451</td>
      <td>7</td>
      <td>230</td>
      <td>[1675728302746, 1675729527578, 1675730123898, ...</td>
      <td>9</td>
      <td>1242</td>
      <td>[1675727902618, 1675728119437, 1675728413698, ...</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>4039</td>
      <td>1675605329000</td>
      <td>1675620251527</td>
      <td>14922527</td>
      <td>歌杂~</td>
      <td>8225.0</td>
      <td>4455</td>
      <td>575</td>
      <td>19</td>
      <td>3276</td>
      <td>[1675605761897, 1675606540268, 1675606864640, ...</td>
      <td>6</td>
      <td>2688</td>
      <td>[1675608154614, 1675609365272, 1675609368458, ...</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>1393</td>
      <td>1675518765000</td>
      <td>1675565646886</td>
      <td>46881886</td>
      <td>LOL内战之赢一把就睡</td>
      <td>666.0</td>
      <td>5452</td>
      <td>355</td>
      <td>3</td>
      <td>90</td>
      <td>[1675522508393, 1675522632583, 1675526359959]</td>
      <td>3</td>
      <td>414</td>
      <td>[1675525369538, 1675526556414, 1675531104266]</td>
    </tr>
  </tbody>
</table>
</div>



<p>其实看到这里我就有点后悔了，叔叔给虚拟主播区分二级区域只是最近的事情，几个主播的分区不是虚拟主播区就是电台区，根本没有任何分析的必要。</p>
<p>然后我感觉或许应该增加一个有关粉丝数量的字段，毕竟大 v 和小 v 的恰米数量是不一样的，不过 later better than never 。这里我们用到了 <a href="https://www.bilibili.com/">Bilibili</a> 的 API ，根据局部性原理，我们可以不用调用 2500 次 API 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">API_STR = <span class="string">&#x27;https://api.bilibili.com/x/web-interface/card?mid=&#123;0&#125;&#x27;</span></span><br><span class="line">mid = <span class="number">0</span></span><br><span class="line">all_followers = []</span><br><span class="line"><span class="keyword">for</span> _, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">    <span class="keyword">if</span> mid != c_names[c_names[<span class="string">&#x27;name&#x27;</span>] == row[<span class="string">&#x27;liver&#x27;</span>]][<span class="string">&#x27;id&#x27;</span>].values[<span class="number">0</span>]:</span><br><span class="line">        mid = c_names[c_names[<span class="string">&#x27;name&#x27;</span>] == row[<span class="string">&#x27;liver&#x27;</span>]][<span class="string">&#x27;id&#x27;</span>].values[<span class="number">0</span>]</span><br><span class="line">        url = API_STR.<span class="built_in">format</span>(mid)</span><br><span class="line">        followers = requests.get(url).json()[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;follower&#x27;</span>]</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">    all_followers.append(followers)</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;followers&#x27;</span>] = all_followers</span><br><span class="line">df.to_hdf(<span class="string">&#x27;data.h5&#x27;</span>, key=<span class="string">&#x27;df&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>liver</th>
      <th>area</th>
      <th>danmakusCount</th>
      <th>startDate</th>
      <th>stopDate</th>
      <th>timeDuration</th>
      <th>title</th>
      <th>totalIncome</th>
      <th>watchCount</th>
      <th>interactionCount</th>
      <th>superchatCount</th>
      <th>superchatIncome</th>
      <th>superchatTimestamps</th>
      <th>membershipCount</th>
      <th>membershipIncome</th>
      <th>membershipTimestamps</th>
      <th>followers</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟Singer</td>
      <td>2627</td>
      <td>1675951004000</td>
      <td>1675962058514</td>
      <td>11054514</td>
      <td>下面我来简单唱两句</td>
      <td>1754.0</td>
      <td>4078</td>
      <td>468</td>
      <td>16</td>
      <td>680</td>
      <td>[1675954450657, 1675955951334, 1675957817542, ...</td>
      <td>0</td>
      <td>0</td>
      <td>[]</td>
      <td>34583</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟Singer</td>
      <td>3762</td>
      <td>1675864738000</td>
      <td>1675876582848</td>
      <td>11844848</td>
      <td>赫赫，我来简单唱两句</td>
      <td>11057.0</td>
      <td>4928</td>
      <td>649</td>
      <td>12</td>
      <td>597</td>
      <td>[1675864937946, 1675865846334, 1675866462953, ...</td>
      <td>11</td>
      <td>7358</td>
      <td>[1675868606293, 1675868631905, 1675869343361, ...</td>
      <td>34583</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>2167</td>
      <td>1675727764000</td>
      <td>1675736225954</td>
      <td>8461954</td>
      <td>早上好！唱一会儿~</td>
      <td>3852.0</td>
      <td>3382</td>
      <td>451</td>
      <td>7</td>
      <td>230</td>
      <td>[1675728302746, 1675729527578, 1675730123898, ...</td>
      <td>9</td>
      <td>1242</td>
      <td>[1675727902618, 1675728119437, 1675728413698, ...</td>
      <td>34583</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>4039</td>
      <td>1675605329000</td>
      <td>1675620251527</td>
      <td>14922527</td>
      <td>歌杂~</td>
      <td>8225.0</td>
      <td>4455</td>
      <td>575</td>
      <td>19</td>
      <td>3276</td>
      <td>[1675605761897, 1675606540268, 1675606864640, ...</td>
      <td>6</td>
      <td>2688</td>
      <td>[1675608154614, 1675609365272, 1675609368458, ...</td>
      <td>34583</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>1393</td>
      <td>1675518765000</td>
      <td>1675565646886</td>
      <td>46881886</td>
      <td>LOL内战之赢一把就睡</td>
      <td>666.0</td>
      <td>5452</td>
      <td>355</td>
      <td>3</td>
      <td>90</td>
      <td>[1675522508393, 1675522632583, 1675526359959]</td>
      <td>3</td>
      <td>414</td>
      <td>[1675525369538, 1675526556414, 1675531104266]</td>
      <td>34583</td>
    </tr>
  </tbody>
</table>
</div>



<p>至此，我们获得了一个数据集，然后就是数据的预处理了。</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>首先我们先来看看每个字段的类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_hdf(<span class="string">&#x27;data.h5&#x27;</span>)</span><br><span class="line">df.info()</span><br></pre></td></tr></table></figure>
<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
Int64Index: 2477 entries, 0 to 2476
Data columns (total 17 columns):
 #   Column                Non-Null Count  Dtype 
---  ------                --------------  ----- 
 0   liver                 2477 non-null   object
 1   area                  2477 non-null   object
 2   danmakusCount         2477 non-null   object
 3   startDate             2477 non-null   object
 4   stopDate              2477 non-null   object
 5   timeDuration          2477 non-null   object
 6   title                 2477 non-null   object
 7   totalIncome           2477 non-null   object
 8   watchCount            2477 non-null   object
 9   interactionCount      2477 non-null   object
 10  superchatCount        2477 non-null   object
 11  superchatIncome       2477 non-null   object
 12  superchatTimestamps   2477 non-null   object
 13  membershipCount       2477 non-null   object
 14  membershipIncome      2477 non-null   object
 15  membershipTimestamps  2477 non-null   object
 16  followers             2477 non-null   int64 
dtypes: int64(1), object(16)
memory usage: 348.3+ KB
</code></pre><p>好家伙，全是 object ，很明显不能拿来进行相关性的分析，所以我们在这里要做的就是将部分字段转换成数值型的数据。而对于时间相关的字段，我们要将其转换为 <code>datetime</code> 类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部分字段转换为数值类型</span></span><br><span class="line"><span class="comment"># df[&#x27;danmakusCount&#x27;] = pd.to_numeric(df[&#x27;danmakusCount&#x27;])</span></span><br><span class="line">df[<span class="string">&#x27;timeDuration&#x27;</span>] = pd.to_numeric(df[<span class="string">&#x27;timeDuration&#x27;</span>])</span><br><span class="line"><span class="comment"># df[&#x27;totalIncome&#x27;] = pd.to_numeric(df[&#x27;totalIncome&#x27;])</span></span><br><span class="line">df[<span class="string">&#x27;watchCount&#x27;</span>] = pd.to_numeric(df[<span class="string">&#x27;watchCount&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;interactionCount&#x27;</span>] = pd.to_numeric(df[<span class="string">&#x27;interactionCount&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;superchatCount&#x27;</span>] = pd.to_numeric(df[<span class="string">&#x27;superchatCount&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;superchatIncome&#x27;</span>] = pd.to_numeric(df[<span class="string">&#x27;superchatIncome&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;membershipCount&#x27;</span>] = pd.to_numeric(df[<span class="string">&#x27;membershipCount&#x27;</span>])</span><br><span class="line">df[<span class="string">&#x27;membershipIncome&#x27;</span>] = pd.to_numeric(df[<span class="string">&#x27;membershipIncome&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳 -&gt; datetime</span></span><br><span class="line">df[<span class="string">&#x27;startDate&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;startDate&#x27;</span>], unit=<span class="string">&#x27;ms&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;stopDate&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;stopDate&#x27;</span>], unit=<span class="string">&#x27;ms&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;superchatTimestamps&#x27;</span>] = df[<span class="string">&#x27;superchatTimestamps&#x27;</span>].apply(<span class="keyword">lambda</span> x: [pd.to_datetime(i, unit=<span class="string">&#x27;ms&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x])</span><br><span class="line">df[<span class="string">&#x27;membershipTimestamps&#x27;</span>] = df[<span class="string">&#x27;membershipTimestamps&#x27;</span>].apply(<span class="keyword">lambda</span> x: [pd.to_datetime(i, unit=<span class="string">&#x27;ms&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> x])</span><br><span class="line"></span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>liver</th>
      <th>area</th>
      <th>danmakusCount</th>
      <th>startDate</th>
      <th>stopDate</th>
      <th>timeDuration</th>
      <th>title</th>
      <th>totalIncome</th>
      <th>watchCount</th>
      <th>interactionCount</th>
      <th>superchatCount</th>
      <th>superchatIncome</th>
      <th>superchatTimestamps</th>
      <th>membershipCount</th>
      <th>membershipIncome</th>
      <th>membershipTimestamps</th>
      <th>followers</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟Singer</td>
      <td>2627</td>
      <td>2023-02-09 13:56:44</td>
      <td>2023-02-09 17:00:58.514</td>
      <td>11054514</td>
      <td>下面我来简单唱两句</td>
      <td>1754.0</td>
      <td>4078</td>
      <td>468</td>
      <td>16</td>
      <td>680</td>
      <td>[2023-02-09 14:54:10.657000, 2023-02-09 15:19:...</td>
      <td>0</td>
      <td>0</td>
      <td>[]</td>
      <td>34583</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟Singer</td>
      <td>3762</td>
      <td>2023-02-08 13:58:58</td>
      <td>2023-02-08 17:16:22.848</td>
      <td>11844848</td>
      <td>赫赫，我来简单唱两句</td>
      <td>11057.0</td>
      <td>4928</td>
      <td>649</td>
      <td>12</td>
      <td>597</td>
      <td>[2023-02-08 14:02:17.946000, 2023-02-08 14:17:...</td>
      <td>11</td>
      <td>7358</td>
      <td>[2023-02-08 15:03:26.293000, 2023-02-08 15:03:...</td>
      <td>34583</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>2167</td>
      <td>2023-02-06 23:56:04</td>
      <td>2023-02-07 02:17:05.954</td>
      <td>8461954</td>
      <td>早上好！唱一会儿~</td>
      <td>3852.0</td>
      <td>3382</td>
      <td>451</td>
      <td>7</td>
      <td>230</td>
      <td>[2023-02-07 00:05:02.746000, 2023-02-07 00:25:...</td>
      <td>9</td>
      <td>1242</td>
      <td>[2023-02-06 23:58:22.618000, 2023-02-07 00:01:...</td>
      <td>34583</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>4039</td>
      <td>2023-02-05 13:55:29</td>
      <td>2023-02-05 18:04:11.527</td>
      <td>14922527</td>
      <td>歌杂~</td>
      <td>8225.0</td>
      <td>4455</td>
      <td>575</td>
      <td>19</td>
      <td>3276</td>
      <td>[2023-02-05 14:02:41.897000, 2023-02-05 14:15:...</td>
      <td>6</td>
      <td>2688</td>
      <td>[2023-02-05 14:42:34.614000, 2023-02-05 15:02:...</td>
      <td>34583</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>1393</td>
      <td>2023-02-04 13:52:45</td>
      <td>2023-02-05 02:54:06.886</td>
      <td>46881886</td>
      <td>LOL内战之赢一把就睡</td>
      <td>666.0</td>
      <td>5452</td>
      <td>355</td>
      <td>3</td>
      <td>90</td>
      <td>[2023-02-04 14:55:08.393000, 2023-02-04 14:57:...</td>
      <td>3</td>
      <td>414</td>
      <td>[2023-02-04 15:42:49.538000, 2023-02-04 16:02:...</td>
      <td>34583</td>
    </tr>
  </tbody>
</table>
</div>



<p>当然，我们还可以再增加一些用于比较的数据，例如平均的 sc 和舰长的金额、开始与结束的时间点等等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;avgSuperchatIncome&#x27;</span>] = df[<span class="string">&#x27;superchatIncome&#x27;</span>] / df[<span class="string">&#x27;superchatCount&#x27;</span>]</span><br><span class="line">df[<span class="string">&#x27;avgMembershipIncome&#x27;</span>] = df[<span class="string">&#x27;membershipIncome&#x27;</span>] / df[<span class="string">&#x27;membershipCount&#x27;</span>]</span><br><span class="line">df[<span class="string">&#x27;startHour&#x27;</span>] = df[<span class="string">&#x27;startDate&#x27;</span>].apply(<span class="keyword">lambda</span> x: (x.hour + <span class="number">8</span>) % <span class="number">24</span>)</span><br><span class="line">df[<span class="string">&#x27;stopHour&#x27;</span>] = df[<span class="string">&#x27;stopDate&#x27;</span>].apply(<span class="keyword">lambda</span> x: (x.hour + <span class="number">8</span>) % <span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>liver</th>
      <th>area</th>
      <th>danmakusCount</th>
      <th>startDate</th>
      <th>stopDate</th>
      <th>timeDuration</th>
      <th>title</th>
      <th>totalIncome</th>
      <th>watchCount</th>
      <th>interactionCount</th>
      <th>...</th>
      <th>superchatIncome</th>
      <th>superchatTimestamps</th>
      <th>membershipCount</th>
      <th>membershipIncome</th>
      <th>membershipTimestamps</th>
      <th>followers</th>
      <th>avgSuperchatIncome</th>
      <th>avgMembershipIncome</th>
      <th>startHour</th>
      <th>stopHour</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟Singer</td>
      <td>2627</td>
      <td>2023-02-09 13:56:44</td>
      <td>2023-02-09 17:00:58.514</td>
      <td>11054514</td>
      <td>下面我来简单唱两句</td>
      <td>1754.0</td>
      <td>4078</td>
      <td>468</td>
      <td>...</td>
      <td>680</td>
      <td>[2023-02-09 14:54:10.657000, 2023-02-09 15:19:...</td>
      <td>0</td>
      <td>0</td>
      <td>[]</td>
      <td>34583</td>
      <td>42.500000</td>
      <td>NaN</td>
      <td>21</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟Singer</td>
      <td>3762</td>
      <td>2023-02-08 13:58:58</td>
      <td>2023-02-08 17:16:22.848</td>
      <td>11844848</td>
      <td>赫赫，我来简单唱两句</td>
      <td>11057.0</td>
      <td>4928</td>
      <td>649</td>
      <td>...</td>
      <td>597</td>
      <td>[2023-02-08 14:02:17.946000, 2023-02-08 14:17:...</td>
      <td>11</td>
      <td>7358</td>
      <td>[2023-02-08 15:03:26.293000, 2023-02-08 15:03:...</td>
      <td>34583</td>
      <td>49.750000</td>
      <td>668.909091</td>
      <td>21</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>2167</td>
      <td>2023-02-06 23:56:04</td>
      <td>2023-02-07 02:17:05.954</td>
      <td>8461954</td>
      <td>早上好！唱一会儿~</td>
      <td>3852.0</td>
      <td>3382</td>
      <td>451</td>
      <td>...</td>
      <td>230</td>
      <td>[2023-02-07 00:05:02.746000, 2023-02-07 00:25:...</td>
      <td>9</td>
      <td>1242</td>
      <td>[2023-02-06 23:58:22.618000, 2023-02-07 00:01:...</td>
      <td>34583</td>
      <td>32.857143</td>
      <td>138.000000</td>
      <td>7</td>
      <td>10</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>4039</td>
      <td>2023-02-05 13:55:29</td>
      <td>2023-02-05 18:04:11.527</td>
      <td>14922527</td>
      <td>歌杂~</td>
      <td>8225.0</td>
      <td>4455</td>
      <td>575</td>
      <td>...</td>
      <td>3276</td>
      <td>[2023-02-05 14:02:41.897000, 2023-02-05 14:15:...</td>
      <td>6</td>
      <td>2688</td>
      <td>[2023-02-05 14:42:34.614000, 2023-02-05 15:02:...</td>
      <td>34583</td>
      <td>172.421053</td>
      <td>448.000000</td>
      <td>21</td>
      <td>2</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-阿蕊娅Aria-</td>
      <td>虚拟主播</td>
      <td>1393</td>
      <td>2023-02-04 13:52:45</td>
      <td>2023-02-05 02:54:06.886</td>
      <td>46881886</td>
      <td>LOL内战之赢一把就睡</td>
      <td>666.0</td>
      <td>5452</td>
      <td>355</td>
      <td>...</td>
      <td>90</td>
      <td>[2023-02-04 14:55:08.393000, 2023-02-04 14:57:...</td>
      <td>3</td>
      <td>414</td>
      <td>[2023-02-04 15:42:49.538000, 2023-02-04 16:02:...</td>
      <td>34583</td>
      <td>30.000000</td>
      <td>138.000000</td>
      <td>21</td>
      <td>10</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 21 columns</p>
</div>



<h2 id="数据分析与可视化"><a href="#数据分析与可视化" class="headerlink" title="数据分析与可视化"></a>数据分析与可视化</h2><p>久等了，终于到了数据可视化的环节了。这里我们使用 <code>matplotlib</code> 来进行数据可视化。</p>
<p>我们需要通过此来验证一下我们能否通过一些数据来预测或者判断主播的 sc 收入/大航海收入/总收入。整点概率论的内容，我们有一个原假设：</p>
<script type="math/tex; mode=display">
H_0: 主播的 sc 收入/大航海收入/总收入与我们收集到的数据（观看人数/互动数量/弹幕数量等等）无关</script><p>与之相对的是备择假设：</p>
<script type="math/tex; mode=display">
H_1: 主播的 sc 收入/大航海收入/总收入与我们收集到的数据（观看人数/互动数量/弹幕数量等等）有关</script><p>这里的显著水准 $\alpha=0.05$ 。</p>
<p>首先，我们可以使用相关性矩阵来判断我们的 dataframe 中的字段之间是否有相关性。我们使用 Pearson 相关系数来计算相关性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">sns.heatmap(df.corr(), annot=<span class="literal">True</span>, fmt=<span class="string">&#x27;.2f&#x27;</span>, cmap=<span class="string">&#x27;Blues&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2023/02/11/analysis/data-analysis-tutorial_17_0.png" class="">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">axes = scatter_matrix(df, figsize=(<span class="number">22</span>, <span class="number">18</span>))</span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> axes.flatten():</span><br><span class="line">    ax.yaxis.label.set_rotation(<span class="number">60</span>)</span><br><span class="line">    ax.yaxis.label.set_ha(<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2023/02/11/analysis/data-analysis-tutorial_18_0.png" class="">
<p>好了，数据拿到了，可以开始吹了。我在这里放弃了总收入和弹幕数量的比较，因为它们显然可以通过 sc /舰长收入和互动人数来推演得到。首先比较惊讶的一点是，相关性矩阵的数值居然基本都是正数，这说明这组数据基本上都是正相关的，可能这就是所谓的赢者通吃罢。可以注意到的是直播时长和收入没啥关系，反而是和互动人数/观看人数/下播时间相关性更高。然后观看人数和互动人数/粉丝数量的相关性也很高，这也是符合常理的。</p>
<p>在 sc 数量/舰长数量和 sc 收入/舰长收入的比较中，我们可以看到 sc 数量/舰长数量和 sc 收入/舰长收入的相关性都很高，而舰长上的数据相关性更好，可能是由于 sc 的金额选择更加自由，而一般人只会上 138/198 元的舰长造成的。还有就是下播时间和其他数据基本都是负相关，这大概是由于我们采用了东八区修正导致而主播更加倾向于凌晨下播。</p>
<p>总而言之，在这一节我们得到了一些显而易见的结论，也没有提出什么新的设想，所以我们在之后会讨论一些别的方向。</p>
<h3 id="时间和sc-舰长数量的关系"><a href="#时间和sc-舰长数量的关系" class="headerlink" title="时间和sc/舰长数量的关系"></a>时间和sc/舰长数量的关系</h3><p>尽管在上面的章节中我们并没有发现开播和下播时间和 sc/舰长数量的关系，但是我仍然相信他们之间存在一定的联系。因为很显然，sc 和舰长的数量增长是会需要一个特定的时间段的，例如一场 2 小时的直播，其 sc 和舰长的数量不可能是平均增长的，所以我们需要一个更加细致的时间刻度来分析这些数据。</p>
<p>不过可惜的是，我们并没有收集每一个 sc 和舰长的单价，不过我也懒得再花一天时间去重爬这些数据了。总而言之，大部分的 sc 的价格为 30 元或者 50 元人民币，而舰长的价格为 138 元或者 198 元人民币。在极少情况下会出现大额的红色 sc 以及价值 1998 元的提督和价值 19998 元的总督。当然如果我们得到了有趣的结论，或许在未来会进一步分析价格和时间之间的关系。</p>
<p>由于在 bilibili 观看虚拟主播的观众大部分位于 UTC+8 的时区，其作息也和时区相符，所以我们在这里将 UTC 的时间戳转换为 UTC+8 的时间戳。</p>
<p><strong>注意</strong>：下方图中的折线代表该时间段正在直播的主播数量，柱状图表示在这一个小时内 sc/舰长 的数量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> time, date, timedelta, datetime</span><br><span class="line"></span><br><span class="line">datetimes = &#123;&#125;</span><br><span class="line">scs = &#123;&#125;</span><br><span class="line">mbs = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">    ct = row[<span class="string">&#x27;startDate&#x27;</span>]</span><br><span class="line">    <span class="keyword">while</span> ct &lt;= row[<span class="string">&#x27;stopDate&#x27;</span>]:</span><br><span class="line">        t = datetime.combine(date(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">                             ct.replace(second=<span class="number">0</span>, microsecond=<span class="number">0</span>).time())</span><br><span class="line">        t += timedelta(hours=<span class="number">8</span>)</span><br><span class="line">        t = t.replace(day=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">in</span> datetimes:</span><br><span class="line">            datetimes[t] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            datetimes[t] = <span class="number">1</span></span><br><span class="line">        ct += timedelta(minutes=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> row[<span class="string">&#x27;superchatTimestamps&#x27;</span>]:</span><br><span class="line">        t1 = (i.hour + <span class="number">8</span>) % <span class="number">24</span></span><br><span class="line">        <span class="keyword">if</span> t1 <span class="keyword">in</span> scs:</span><br><span class="line">            scs[t1] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            scs[t1] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> row[<span class="string">&#x27;membershipTimestamps&#x27;</span>]:</span><br><span class="line">        t2 = (i.hour + <span class="number">8</span>) % <span class="number">24</span></span><br><span class="line">        <span class="keyword">if</span> t2 <span class="keyword">in</span> mbs:</span><br><span class="line">            mbs[t2] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            mbs[t2] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">x, y = <span class="built_in">zip</span>(*<span class="built_in">sorted</span>(datetimes.items()))</span><br><span class="line">x2, y2 = <span class="built_in">zip</span>(*<span class="built_in">sorted</span>(scs.items()))</span><br><span class="line">x3, y3 = <span class="built_in">zip</span>(*<span class="built_in">sorted</span>(mbs.items()))</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">ax.plot(x, y)</span><br><span class="line"></span><br><span class="line">ax2 = ax.twiny().twinx()</span><br><span class="line">ax2.set_xticks([])</span><br><span class="line">ax2.tick_params(<span class="string">&#x27;y&#x27;</span>, colors=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">ax2.bar(x2, y2, color=<span class="string">&#x27;orange&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">xfmt = mdates.DateFormatter(<span class="string">&#x27;%H:%M&#x27;</span>)</span><br><span class="line">ax.xaxis.set_major_formatter(xfmt)</span><br><span class="line">ax.xaxis.set_major_locator(mdates.HourLocator())</span><br><span class="line">ax.set_title(<span class="string">&#x27;Streams and Superchats&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Time of day&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Number of streams live&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;Number of superchats in hour&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Text(0, 0.5, &#39;Number of superchats in hour&#39;)
</code></pre><img src="/2023/02/11/analysis/data-analysis-tutorial_20_1.png" class=""> 
<p>这图就很有意思了，咱们仔细看看。</p>
<p>首先我们单看折线图，可以看到在整点左右，有大量的主播开播。这很好理解，因为很多主播都会先预定一个开播时间（大概率是整点），然后提前几分钟开始。然后我们可以看到在每个小时的中间段，折线的增速放缓或者开始下降，这说明主播下播的时间相较于开播来说不是特别固定。然后我们可以看到有大量的主播会选择在晚上八点开始直播，这大概是吃完晚饭的时间，可以说是“黄金时间”。而主播数量十点钟达到顶峰，应该说是为了照顾 996 的打工人嘛（。在此之后主播的数量会几乎匀速下降，在凌晨 2 点左右达到谷底。还有一部分虚拟主播会选择在下午开播，这可能是双休日或者午休摸鱼的时间，随后数量会在下午五点左右的晚饭时间下降。</p>
<p>Superchat 数量变化趋势从大体上看和主播数量变化相同，我们来想说“但是也会有一些例外情况”，然而，并没有，这可能是因为观众更倾向于在主播刚开播的时候发送 sc 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">ax.plot(x, y)</span><br><span class="line"></span><br><span class="line">ax2 = ax.twiny().twinx()</span><br><span class="line">ax2.set_xticks([])</span><br><span class="line">ax2.tick_params(<span class="string">&#x27;y&#x27;</span>, colors=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">ax2.bar(x3, y3, color=<span class="string">&#x27;blue&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">xfmt = mdates.DateFormatter(<span class="string">&#x27;%H:%M&#x27;</span>)</span><br><span class="line">ax.xaxis.set_major_formatter(xfmt)</span><br><span class="line">ax.xaxis.set_major_locator(mdates.HourLocator())</span><br><span class="line">ax.set_title(<span class="string">&#x27;Streams and Memberships&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Time of day&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Number of streams live&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;Number of Memberships in hour&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Text(0, 0.5, &#39;Number of Memberships in hour&#39;)
</code></pre><img src="/2023/02/11/analysis/data-analysis-tutorial_22_1.png" class="">
<p>大航海的情况和 sc 的情况类似，但是有趣的是它的顶峰和 sc 相比偏移了一个小时，在开播主播数量快速上升的 21 时，大航海的数量反而下降了。同时 19 时的舰长增幅远远超过了主播开播的数量，我认为可能舰长价格相对于 sc 而言更高，而只有更加忠实的观众才会选择购买舰长。因此舰长的数量变化取决于忠实观众观看直播的时间而不是主播开播的时间，观众往往也不会倾向于在主播刚开播的时候购买舰长。另一个有趣的点是 0 时的上舰数量可以和 21 时持平，应该是由于连续包月自动续费的原因。</p>
<h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p>尽管我们并没有进行定量分析也没有发现什么突破性的观点，但是我们确实也验证了一些普遍的认识。</p>
<ul>
<li>主播往往倾向于在整点左右开播，因为这符合预定的开播时间。</li>
<li>晚饭后的时间是主播的 “黄金时间”。</li>
<li>工作时间会有更少的 sc 和舰长。</li>
<li>和 sc 不同，舰长数量和主播开播的时间不完全同步。</li>
</ul>
<h4 id="未来工作"><a href="#未来工作" class="headerlink" title="未来工作"></a>未来工作</h4><p>在这里我们定性地统计了每小时的 sc/舰长 数量，它和每分钟正在直播的主播数量相似。或许我们可以使用<a href="https://www.wikipedia.net/zh-hans/%E6%9F%AF%E5%B0%94%E8%8E%AB%E5%93%A5%E6%B4%9B%E5%A4%AB-%E6%96%AF%E7%B1%B3%E5%B0%94%E8%AF%BA%E5%A4%AB%E6%A3%80%E9%AA%8C">柯尔莫哥洛夫 - 斯米尔诺夫检验</a>来检验两种分布之间是否相同。</p>
<h3 id="观看-互动数量和-sc-收入的关系"><a href="#观看-互动数量和-sc-收入的关系" class="headerlink" title="观看/互动数量和 sc 收入的关系"></a>观看/互动数量和 sc 收入的关系</h3><p>这一部分开始，内容或许有一些数据挖掘的味道了。就我们的普遍认识而言，观众越多的主播能够赚到更多的钱，但是他们究竟遵从一个什么样的关系呢？是线性吗？还是指数？还是其他的什么？我们先画张图看看罢。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">ax.plot(df[<span class="string">&#x27;interactionCount&#x27;</span>] ,df[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Interaction Count&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Superchat Earnings&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Interaction Count vs Superchat Earnings (linear scale)&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Text(0.5, 1.0, &#39;Interaction Count vs Superchat Earnings (linear scale)&#39;)
</code></pre>
<p>emm…感觉很河里了，但是确实不能提供什么信息，因为低观众且低 sc 的数量太多了，而且我们也没有办法去除这些数据。我们可以使用<a href="https://www.wikipedia.net/zh-hans/%E5%AF%B9%E6%95%B0%E5%8F%98%E6%8D%A2">对数变换</a>来解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">ax.plot(df[<span class="string">&#x27;interactionCount&#x27;</span>] ,df[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">ax.set_xscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">ax.set_yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">plt.xlim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Interaction Count&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Superchat Earnings&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Interaction Count vs Superchat Earnings (log-log scale)&quot;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Text(0.5, 1.0, &#39;Interaction Count vs Superchat Earnings (log-log scale)&#39;)
</code></pre><img src="/2023/02/11/analysis/data-analysis-tutorial_27_1.png" class="">
<p>现在，我们可以得到更多的信息了。比如：</p>
<ul>
<li>最下方有一条平行的线，它大概代表了 sc 的最低值（30元），然后另外也有几条平行线。它们代表了只有几个人发送小额 sc 的情况。</li>
<li>就趋势上看，我们可以看到一个上升的趋势。</li>
</ul>
<p>然后，我们来尝试一下能不能拟合出这个趋势。</p>
<h4 id="注意，下面有一部分是反面教材"><a href="#注意，下面有一部分是反面教材" class="headerlink" title="注意，下面有一部分是反面教材"></a>注意，下面有一部分是反面教材</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">slope, intercept, r_value, p_value, std_err = stats.linregress(df[<span class="string">&#x27;interactionCount&#x27;</span>] ,df[<span class="string">&#x27;superchatIncome&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Regression from scipy y=mx+b: \ny = %f x + %f&#x27;</span>%(slope, intercept))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;p-value: %e&#x27;</span>%(p_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;r-value: %f&#x27;</span>%(r_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;standard error: %f&#x27;</span>%(std_err))</span><br></pre></td></tr></table></figure>
<pre><code>Regression from scipy y=mx+b: 
y = 0.856222 x + -486.326623
p-value: 1.919459e-216
r-value: 0.573294
standard error: 0.024598
</code></pre><p>嘛， python 就是不错，几行代码就拟合出来了。这个 p 值看上去不错，但是这个 r 感觉就很一般，不过这都不是什么大问题。我们来看看这个拟合的直线。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">ax.plot(df[<span class="string">&#x27;interactionCount&#x27;</span>] ,df[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">ax.set_xscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">ax.set_yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">plt.xlim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line">plt.ylim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Interaction Count&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Superchat Earnings&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Interaction Count vs Superchat Earnings (log-log scale)&quot;</span>)</span><br><span class="line"></span><br><span class="line">x = np.array(<span class="built_in">range</span>(<span class="number">10</span>, <span class="number">10</span>**<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax.plot(x, slope * x + intercept)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2023/02/11/analysis/data-analysis-tutorial_32_0.png" class="">
<p>非常的神秘啊，这条线是一条曲线。雀氏，因为在 log-log 图里，想要得到一条直线需要一个类似于 $y=ax^k$ 的函数。尽管这条拟合的直线是<em>可以</em>的，但是我们还是希望能在 log-log 图里得到一条直线，这样才不会忽略数值过小的点。</p>
<p>为了得到一条指数拟合的曲线，我们有两种选择：</p>
<ul>
<li>通过一些非常时尚的回归方法得到结果。</li>
<li>两边取对数，得到形如 $\log(y)=k\log(x)+\log(a)$ 的形式，然后进行线性拟合。</li>
</ul>
<p>我们在这里会选择第二种方法，不过需要注意数据中有一些没有 sc 的数据，我们可以选择去掉它们或者令它的值为 0.01 元。这里我们选择去掉它们。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_prime = df[[<span class="string">&#x27;interactionCount&#x27;</span>, <span class="string">&#x27;superchatIncome&#x27;</span>]]</span><br><span class="line">df_prime = df_prime[df_prime[<span class="string">&#x27;superchatIncome&#x27;</span>] &gt; <span class="number">0</span>]</span><br><span class="line">df_prime[<span class="string">&#x27;interactionCount&#x27;</span>] = df_prime[<span class="string">&#x27;interactionCount&#x27;</span>].apply(math.log)</span><br><span class="line">df_prime[<span class="string">&#x27;superchatIncome&#x27;</span>] = df_prime[<span class="string">&#x27;superchatIncome&#x27;</span>].apply(math.log)</span><br><span class="line"></span><br><span class="line">slope, intercept, r_value, p_value, std_err = stats.linregress(df_prime[<span class="string">&#x27;interactionCount&#x27;</span>], df_prime[<span class="string">&#x27;superchatIncome&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Regression from scipy y=mx+b: \ny = %f x + %f&#x27;</span>%(slope, intercept))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;p-value: %e&#x27;</span>%(p_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;r-value: %f&#x27;</span>%(r_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;r squared: %f&#x27;</span>%(r_value**<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;standard error: %f&#x27;</span>%(std_err))</span><br></pre></td></tr></table></figure>
<pre><code>Regression from scipy y=mx+b: 
y = 1.002485 x + -1.110788
p-value: 5.818056e-309
r-value: 0.689253
r squared: 0.475069
standard error: 0.022513
</code></pre><p>我们可以看到， r 值高了一些，感觉还行罢。我们来看看这条曲线。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">ax.plot(df[<span class="string">&#x27;interactionCount&#x27;</span>], df[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">ax.set_xscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">ax.set_yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">plt.xlim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line">plt.ylim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Interaction Count&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Superchat Earnings&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Interaction Count vs Superchat Earnings (log-log scale)&quot;</span>)</span><br><span class="line"></span><br><span class="line">x = np.array(<span class="built_in">range</span>(<span class="number">10</span>, <span class="number">10</span>**<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax.plot(x, (math.e**intercept) * x**slope)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2023/02/11/analysis/data-analysis-tutorial_36_0.png" class="">
<p>当然，我们可以给数据取对数而不是给坐标系取对数，这样其实对后面的处理更有好处。所幸，我们有了 <code>df_prime</code> ，所以只要把它拿来用就行了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">ax.plot(df_prime[<span class="string">&#x27;interactionCount&#x27;</span>], df_prime[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">plt.xlim(<span class="number">3</span>, <span class="number">12</span>)</span><br><span class="line">plt.ylim(<span class="number">3</span>, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Interaction Count&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Superchat Earnings&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Interaction Count vs Superchat Earnings (linear scale)&quot;</span>)</span><br><span class="line"></span><br><span class="line">x = np.array([i/<span class="number">10.0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>,<span class="number">130</span>)])</span><br><span class="line">ax.plot(x, slope * x + intercept)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2023/02/11/analysis/data-analysis-tutorial_38_0.png" class="">
<p>我们同样可以画出残差，来看看我们的回归效果咋样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">residuals = []</span><br><span class="line"><span class="keyword">for</span> _, row <span class="keyword">in</span> df_prime.iterrows():</span><br><span class="line">    residuals.append(row[<span class="string">&#x27;superchatIncome&#x27;</span>] - (slope * row[<span class="string">&#x27;interactionCount&#x27;</span>] + intercept))</span><br><span class="line"></span><br><span class="line">ax.plot(df_prime[<span class="string">&#x27;interactionCount&#x27;</span>], residuals, <span class="string">&#x27;o&#x27;</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Interaction Count&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Residuals of Superchat Earnings&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Residuals&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.axhline(color=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, math.e**intercept)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;k = &quot;</span>, slope)</span><br></pre></td></tr></table></figure>
<img src="/2023/02/11/analysis/data-analysis-tutorial_40_0.png" class="">
<pre><code>a =  0.3292993009957897
k =  1.0024851841520102
</code></pre><p>看上去不错，我们可以将残差分成四个部分，然后看一看它的小提琴图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vc2 = df_prime[<span class="string">&#x27;interactionCount&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="built_in">round</span>(x/<span class="number">2</span>, <span class="number">0</span>) * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">sns.violinplot(x=vc2, y=residuals)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;AxesSubplot:xlabel=&#39;interactionCount&#39;&gt;
</code></pre><img src="/2023/02/11/analysis/data-analysis-tutorial_42_1.png" class="">
<p>看上去分布很平均，除了数据值比较小的部分拟合地不是特别好，不过差异不算特别大。</p>
<p>最后我们可以说我们得到了这样的一个公式：</p>
<script type="math/tex; mode=display">
y = 0.3292993009957897x^{1.0024851841520102}</script><p>其中 $x$ 是互动人数， $y$ 是 sc 的收入。</p>
<h4 id="个人势-——-好事还是坏事？"><a href="#个人势-——-好事还是坏事？" class="headerlink" title="个人势 —— 好事还是坏事？"></a>个人势 —— 好事还是坏事？</h4><p>或许你已经注意到了，我选择了许多所属为 <code>independent</code> 的虚拟主播，他们代表的是不属于任何公司的个人势，那么他们的数据和平均相比有什么差异呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">inde = c_names.loc[c_names[<span class="string">&#x27;affiliation&#x27;</span>] == <span class="string">&#x27;independent&#x27;</span>]</span><br><span class="line">inde = df.loc[df[<span class="string">&#x27;liver&#x27;</span>].isin(inde[<span class="string">&#x27;name&#x27;</span>])]</span><br><span class="line"></span><br><span class="line">df_prime = inde[[<span class="string">&#x27;interactionCount&#x27;</span>, <span class="string">&#x27;superchatIncome&#x27;</span>]]</span><br><span class="line">df_prime = df_prime[df_prime[<span class="string">&#x27;superchatIncome&#x27;</span>] &gt; <span class="number">0</span>]</span><br><span class="line">df_prime[<span class="string">&#x27;interactionCount&#x27;</span>] = df_prime[<span class="string">&#x27;interactionCount&#x27;</span>].apply(math.log)</span><br><span class="line">df_prime[<span class="string">&#x27;superchatIncome&#x27;</span>] = df_prime[<span class="string">&#x27;superchatIncome&#x27;</span>].apply(math.log)</span><br><span class="line"></span><br><span class="line">slope_prime, intercept_prime, r_value_prime, p_value_prime, std_err_prime = stats.linregress(df_prime[<span class="string">&#x27;interactionCount&#x27;</span>], df_prime[<span class="string">&#x27;superchatIncome&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Regression from scipy y=mx+b: \ny = %f x + %f&#x27;</span>%(slope_prime, intercept_prime))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;p-value: %e&#x27;</span>%(p_value_prime))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;r-value: %f&#x27;</span>%(r_value_prime))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;r squared: %f&#x27;</span>%(r_value_prime**<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;standard error: %f&#x27;</span>%(std_err_prime))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a = &#x27;</span>, math.e**intercept_prime)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k = &#x27;</span>, slope_prime)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">ax.plot(inde[<span class="string">&#x27;interactionCount&#x27;</span>], inde[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">ax.set_xscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">ax.set_yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">plt.xlim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line">plt.ylim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Interaction Count&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Superchat Earnings&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Interaction Count vs Superchat Earnings (log-log scale)&quot;</span>)</span><br><span class="line"></span><br><span class="line">x = np.array(<span class="built_in">range</span>(<span class="number">10</span>, <span class="number">10</span>**<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax.plot(x, (math.e**intercept_prime) * x**slope_prime, color=<span class="string">&#x27;C1&#x27;</span>, label=<span class="string">&#x27;independent line&#x27;</span>)</span><br><span class="line">ax.plot(x, (math.e**intercept) * x**slope, color=<span class="string">&#x27;C2&#x27;</span>, label=<span class="string">&#x27;all line&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>Regression from scipy y=mx+b: 
y = 1.161990 x + -2.306773
p-value: 6.064823e-114
r-value: 0.699629
r squared: 0.489481
standard error: 0.042877
a =  0.09958203755065093
k =  1.1619896703273997
</code></pre><img src="/2023/02/11/analysis/data-analysis-tutorial_45_1.png" class="">
<p>嗯，这组数据的 r 方更高，说明拟合地更好，但是只是好一点，不能好多了。橙色的线表示个人势主播的拟合数据，绿色的线表示总体的拟合数据。就两条曲线相交情况来看，个人势拥有更低的下限和更高的上限，很符合我的预期。而两条线的焦点差不多位于中央的位置，说明可以说中流的主播加入组织或者成为个人势确实差不多。不过考虑到工会会有所抽成之类的，所以只能说是头部主播个人势比较赚。</p>
<p>然后我们来看看不同的企业的数据，看看他们的拟合情况。由于数据量的关系，我们将他们分成三类 —— VirtualReal 、 PSP 和其他。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vr = c_names[c_names[<span class="string">&#x27;affiliation&#x27;</span>] == <span class="string">&#x27;vr&#x27;</span>]</span><br><span class="line">vr = df.loc[df[<span class="string">&#x27;liver&#x27;</span>].isin(vr[<span class="string">&#x27;name&#x27;</span>])]</span><br><span class="line">psp = c_names[c_names[<span class="string">&#x27;affiliation&#x27;</span>] == <span class="string">&#x27;psp&#x27;</span>]</span><br><span class="line">psp = df.loc[df[<span class="string">&#x27;liver&#x27;</span>].isin(psp[<span class="string">&#x27;name&#x27;</span>])]</span><br><span class="line">other = c_names.loc[~c_names[<span class="string">&#x27;affiliation&#x27;</span>].isin([<span class="string">&#x27;vr&#x27;</span>, <span class="string">&#x27;psp&#x27;</span>, <span class="string">&#x27;independent&#x27;</span>])]</span><br><span class="line">other = df.loc[df[<span class="string">&#x27;liver&#x27;</span>].isin(other[<span class="string">&#x27;name&#x27;</span>])]</span><br><span class="line"></span><br><span class="line">COLORS = [<span class="string">&#x27;#A6BDD7&#x27;</span>, <span class="string">&#x27;#FFB300&#x27;</span>, <span class="string">&#x27;#007D34&#x27;</span>, <span class="string">&#x27;#F6768E&#x27;</span>]</span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">ax.plot(other[<span class="string">&#x27;interactionCount&#x27;</span>], other[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, color=COLORS[<span class="number">0</span>], label=<span class="string">&#x27;others&#x27;</span>)</span><br><span class="line">ax.plot(vr[<span class="string">&#x27;interactionCount&#x27;</span>], vr[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, color=COLORS[<span class="number">1</span>], label=<span class="string">&#x27;vr&#x27;</span>)</span><br><span class="line">ax.plot(psp[<span class="string">&#x27;interactionCount&#x27;</span>], psp[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, color=COLORS[<span class="number">2</span>], label=<span class="string">&#x27;psp&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">ax.set_yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line">plt.ylim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Interaction Count&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Superchat Earnings&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Interaction Count vs Superchat Earnings (COMPANY ONLY / log-log scale)&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2023/02/11/analysis/data-analysis-tutorial_47_0.png" class="">
<p>然后我们仔细看看每个分类，然后分别加入拟合线。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">company = c_names[c_names[<span class="string">&#x27;affiliation&#x27;</span>] != <span class="string">&#x27;independent&#x27;</span>]</span><br><span class="line">company = df.loc[df[<span class="string">&#x27;liver&#x27;</span>].isin(company[<span class="string">&#x27;name&#x27;</span>])]</span><br><span class="line"></span><br><span class="line">coms = [vr, psp, other]</span><br><span class="line">labels = [<span class="string">&#x27;vr&#x27;</span>, <span class="string">&#x27;psp&#x27;</span>, <span class="string">&#x27;other&#x27;</span>]</span><br><span class="line"></span><br><span class="line">x = np.array(<span class="built_in">range</span>(<span class="number">10</span>, <span class="number">10</span>**<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">idx = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">regs = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> com <span class="keyword">in</span> coms:</span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">    ax.plot(company[<span class="string">&#x27;interactionCount&#x27;</span>], company[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, color=COLORS[<span class="number">0</span>], label=<span class="string">&#x27;others&#x27;</span>)</span><br><span class="line">    ax.plot(com[<span class="string">&#x27;interactionCount&#x27;</span>], com[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, color=COLORS[idx], label=labels[idx-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    ax.set_xscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">    ax.set_yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.xlim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line">    plt.ylim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line"></span><br><span class="line">    com_prime = com[[<span class="string">&#x27;interactionCount&#x27;</span>, <span class="string">&#x27;superchatIncome&#x27;</span>]]</span><br><span class="line">    com_prime = com_prime[com_prime[<span class="string">&#x27;superchatIncome&#x27;</span>] &gt; <span class="number">0</span>]</span><br><span class="line">    com_prime[<span class="string">&#x27;interactionCount&#x27;</span>] = com_prime[<span class="string">&#x27;interactionCount&#x27;</span>].apply(math.log)</span><br><span class="line">    com_prime[<span class="string">&#x27;superchatIncome&#x27;</span>] = com_prime[<span class="string">&#x27;superchatIncome&#x27;</span>].apply(math.log)</span><br><span class="line">    slope_prime, intercept_prime, r_value_prime, p_value_prime, std_err_prime = stats.linregress(com_prime[<span class="string">&#x27;interactionCount&#x27;</span>], com_prime[<span class="string">&#x27;superchatIncome&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Regression from scipy y=mx+b: \ny = %f x + %f&#x27;</span>%(slope_prime, intercept_prime))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;p-value: %e&#x27;</span>%(p_value_prime))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;r-value: %f&#x27;</span>%(r_value_prime))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;r squared: %f&#x27;</span>%(r_value_prime**<span class="number">2</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;standard error: %f&#x27;</span>%(std_err_prime))</span><br><span class="line"></span><br><span class="line">    ax.plot(x, (math.e**intercept_prime) * x**slope_prime, color=COLORS[idx])</span><br><span class="line">    regs.append([slope_prime, intercept_prime])</span><br><span class="line"></span><br><span class="line">    ax.set_xlabel(<span class="string">&quot;Interaction Count&quot;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&quot;Superchat Earnings&quot;</span>)</span><br><span class="line">    ax.set_title(<span class="string">&quot;Interaction Count vs Superchat Earnings (&#123;0&#125; ONLY / log-log scale)&quot;</span>.<span class="built_in">format</span>(labels[idx-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    idx += <span class="number">1</span></span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>Regression from scipy y=mx+b: 
y = 1.040950 x + -1.132949
p-value: 6.036379e-133
r-value: 0.726136
r squared: 0.527274
standard error: 0.034761
</code></pre><img src="/2023/02/11/analysis/data-analysis-tutorial_49_1.png" class="">
<pre><code>Regression from scipy y=mx+b: 
y = 1.046183 x + -1.505542
p-value: 3.293558e-34
r-value: 0.695976
r squared: 0.484382
standard error: 0.071959
</code></pre><img src="/2023/02/11/analysis/data-analysis-tutorial_49_3.png" class="">
<pre><code>Regression from scipy y=mx+b: 
y = 0.874677 x + -0.643986
p-value: 1.790019e-44
r-value: 0.628465
r squared: 0.394969
standard error: 0.054818
</code></pre><img src="/2023/02/11/analysis/data-analysis-tutorial_49_5.png" class="">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">15</span>, <span class="number">10</span>))</span><br><span class="line">ax.plot(other[<span class="string">&#x27;interactionCount&#x27;</span>], other[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, color=COLORS[<span class="number">0</span>], label=<span class="string">&#x27;others&#x27;</span>)</span><br><span class="line">ax.plot(vr[<span class="string">&#x27;interactionCount&#x27;</span>], vr[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, color=COLORS[<span class="number">1</span>], label=<span class="string">&#x27;vr&#x27;</span>)</span><br><span class="line">ax.plot(psp[<span class="string">&#x27;interactionCount&#x27;</span>], psp[<span class="string">&#x27;superchatIncome&#x27;</span>], <span class="string">&#x27;o&#x27;</span>, color=COLORS[<span class="number">2</span>], label=<span class="string">&#x27;psp&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line">ax.set_yscale(<span class="string">&#x27;log&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line">plt.ylim(<span class="number">10</span>, <span class="number">1e5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Interaction Count&quot;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Superchat Earnings&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;Interaction Count vs Superchat Earnings (COMPANY ONLY / log-log scale)&quot;</span>)</span><br><span class="line"></span><br><span class="line">idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> reg <span class="keyword">in</span> regs:</span><br><span class="line">    ax.plot(x, (math.e**reg[<span class="number">1</span>]) * x**reg[<span class="number">0</span>], color=COLORS[idx])</span><br><span class="line">    idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper left&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2023/02/11/analysis/data-analysis-tutorial_50_0.png" class="">
<p>很明显，不同的企业会有不同的拟合曲线，甚至有一种 PSP 行将就木的感觉。就数据上看，其他类的主播表现最好，但是其实这也是我们数据选取的结果，体量相对小的企业容易捧出更加热门的主播，而像 VR 这样走量的企业就会有上下限差异比较大的情况。</p>
<h4 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h4><ul>
<li>我们定量分析了虚拟主播互动人数和 sc 收入之间的关系，得到了一个指数拟合的曲线。</li>
<li>就个人势来看，他们的收入水平处于一种下限更低但是上限更高的状态。</li>
<li>企业势中，选择一个冷门的企业或许是一个好的选择。</li>
</ul>
<h2 id="整点机器学习"><a href="#整点机器学习" class="headerlink" title="整点机器学习"></a>整点机器学习</h2><p>机器学习，他来了。在这里我们想看一看多因素作用下的 sc/舰长 收入情况，以及不同的主播是否有直播标题的用语偏好。笼统的来说，前者属于回归问题，后者属于分类问题。</p>
<p>首先隆重介绍 scikit-learn algorithm cheat-sheet ，它可以帮助我们快速选择合适的算法。</p>
<img src="/2023/02/11/analysis/ml_map.png" class="">
<h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>我们想用 <code>timeDuration</code> / <code>followers</code> / <code>watchCount</code> / <code>interactionCount</code> 来预测 <code>superchatIncome</code> 和 <code>membershipIncome</code> 。根据上面的图，我们可以选择 <code>Lasso</code> 或者 <code>ElasticNet</code> 。但是在实际操作过程中，我发现这俩都不如直接线性回归$^1$。</p>
<p>$^1$ 事实上，这两种方法均基于线性回归（使用最小平方作为 loss 函数），<code>Lasso</code> 使用 L1 正则化，<code>ElasticNet</code> 使用 L1 和 L2 混合正则化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn.linear_model</span><br><span class="line"></span><br><span class="line">ml = df[[<span class="string">&#x27;timeDuration&#x27;</span>, <span class="string">&#x27;followers&#x27;</span>, <span class="string">&#x27;watchCount&#x27;</span>, <span class="string">&#x27;interactionCount&#x27;</span>, <span class="string">&#x27;superchatIncome&#x27;</span>, <span class="string">&#x27;membershipIncome&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">ml = ml[ml[<span class="string">&#x27;superchatIncome&#x27;</span>] &gt; <span class="number">0</span>]</span><br><span class="line">ml = ml[ml[<span class="string">&#x27;membershipIncome&#x27;</span>] &gt; <span class="number">0</span>]</span><br><span class="line">ml = ml[ml[<span class="string">&#x27;watchCount&#x27;</span>] &gt; <span class="number">0</span>]</span><br><span class="line">ml[<span class="string">&#x27;timeDuration&#x27;</span>] /= <span class="number">60000</span></span><br><span class="line">ml[<span class="string">&#x27;followers&#x27;</span>] = ml[<span class="string">&#x27;followers&#x27;</span>].apply(math.log)</span><br><span class="line">ml[<span class="string">&#x27;watchCount&#x27;</span>] = ml[<span class="string">&#x27;watchCount&#x27;</span>].apply(math.log)</span><br><span class="line">ml[<span class="string">&#x27;interactionCount&#x27;</span>] = ml[<span class="string">&#x27;interactionCount&#x27;</span>].apply(math.log)</span><br><span class="line">ml[<span class="string">&#x27;superchatIncome&#x27;</span>] = ml[<span class="string">&#x27;superchatIncome&#x27;</span>].apply(math.log)</span><br><span class="line">ml[<span class="string">&#x27;membershipIncome&#x27;</span>] = ml[<span class="string">&#x27;membershipIncome&#x27;</span>].apply(math.log)</span><br><span class="line"></span><br><span class="line">y = ml[<span class="string">&#x27;superchatIncome&#x27;</span>]</span><br><span class="line">y_prime = ml[<span class="string">&#x27;membershipIncome&#x27;</span>]</span><br><span class="line">X = ml[[<span class="string">&#x27;timeDuration&#x27;</span>, <span class="string">&#x27;followers&#x27;</span>, <span class="string">&#x27;watchCount&#x27;</span>, <span class="string">&#x27;interactionCount&#x27;</span>]]</span><br><span class="line">X.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>timeDuration</th>
      <th>followers</th>
      <th>watchCount</th>
      <th>interactionCount</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>197.414133</td>
      <td>10.451118</td>
      <td>8.502689</td>
      <td>6.475433</td>
    </tr>
    <tr>
      <th>2</th>
      <td>141.032567</td>
      <td>10.451118</td>
      <td>8.126223</td>
      <td>6.111467</td>
    </tr>
    <tr>
      <th>3</th>
      <td>248.708783</td>
      <td>10.451118</td>
      <td>8.401782</td>
      <td>6.354370</td>
    </tr>
    <tr>
      <th>4</th>
      <td>781.364767</td>
      <td>10.451118</td>
      <td>8.603738</td>
      <td>5.872118</td>
    </tr>
    <tr>
      <th>5</th>
      <td>125.739050</td>
      <td>10.451118</td>
      <td>7.900266</td>
      <td>5.758902</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=X[<span class="string">&#x27;followers&#x27;</span>], random_state = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># linreg = sklearn.linear_model.Lasso(alpha=0.114514)</span></span><br><span class="line"><span class="comment"># linreg = sklearn.linear_model.ElasticNet(alpha=0.114514, l1_ratio=0.5)</span></span><br><span class="line">linreg = sklearn.linear_model.LinearRegression()</span><br><span class="line">linreg.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(linreg.coef_)</span><br><span class="line"><span class="built_in">print</span>(linreg.intercept_)</span><br><span class="line"></span><br><span class="line">y_test_reg = linreg.predict(X_test)</span><br><span class="line">y_train_reg = linreg.predict(X_train)</span><br><span class="line"></span><br><span class="line">accuracy_train = linreg.score(X_train, y_train)</span><br><span class="line">accuracy_test = linreg.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Regression r^2 on training data: %f&quot;</span>%accuracy_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Regression r^2 on test data: %f&quot;</span>%accuracy_test)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y_prime, stratify=X[<span class="string">&#x27;followers&#x27;</span>], random_state = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># linreg = sklearn.linear_model.Lasso(alpha=0.114514)</span></span><br><span class="line"><span class="comment"># linreg = sklearn.linear_model.ElasticNet(alpha=0.114514, l1_ratio=0.5)</span></span><br><span class="line">linreg_2 = sklearn.linear_model.LinearRegression()</span><br><span class="line">linreg_2.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(linreg_2.coef_)</span><br><span class="line"><span class="built_in">print</span>(linreg_2.intercept_)</span><br><span class="line"></span><br><span class="line">y_test_reg = linreg_2.predict(X_test)</span><br><span class="line">y_train_reg = linreg_2.predict(X_train)</span><br><span class="line"></span><br><span class="line">accuracy_train = linreg_2.score(X_train, y_train)</span><br><span class="line">accuracy_test = linreg_2.score(X_test, y_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Regression r^2 on training data: %f&quot;</span>%accuracy_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Regression r^2 on test data: %f&quot;</span>%accuracy_test)</span><br></pre></td></tr></table></figure>
<pre><code>[-1.63048556e-04 -4.61383946e-01 -1.58369967e-01  1.42841418e+00]
3.1673691472447825
Regression r^2 on training data: 0.496148
Regression r^2 on test data: 0.583907
[ 2.62559317e-04 -3.05417414e-01 -8.41857302e-02  9.09382138e-01]
4.756933767749846
Regression r^2 on training data: 0.233466
Regression r^2 on test data: 0.277448
</code></pre><p>综上，模型告诉我们：</p>
<script type="math/tex; mode=display">
\log(\text{superchatIncome}) = {-0.000163048556}\text{timeDuration} - {0.461383946}\log(\text{followers}) - {0.158369967}\log(\text{watchCount}) + {1.42841418}\log(\text{interactionCount}) + 3.1673691472447825 \\
\log(\text{membershipIncome}) = {0.000262559317}\text{timeDuration} - {0.305417414}\log(\text{followers}) - {0.0841857302}\log(\text{watchCount}) + {0.909382138}\log(\text{interactionCount}) + 4.756933767749846</script><p>而前者的 r 方大约在 0.55 左右，这比之前我们的预测要高多了。当然我们也不期望能得到一个十分厉害的公式，比较人类的行为不可预测。最后我们来算一算残差。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_hat = linreg.predict(X)</span><br><span class="line">sns.displot(y - y_hat)</span><br><span class="line">plt.title(<span class="string">&quot;Residuals&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2023/02/11/analysis/data-analysis-tutorial_56_0.png" class="">
<p>嗯，看上去非常的正态分布，而且大致上围绕 $0$ 对称，这是一个很好的结果。这个模型给了我们一个思路，也就是互动人数相对来说更加重要，而观众数量和粉丝数量在某种意义上来说可能会有副作用。当然，如果我们去掉 <code>interactionCount</code> 和 <code>watchCount</code> ，那么这个模型会更加有意义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_2 = X.drop(<span class="string">&#x27;interactionCount&#x27;</span>, axis=<span class="number">1</span>).drop(<span class="string">&#x27;watchCount&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">X_2.head()</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>timeDuration</th>
      <th>followers</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>197.414133</td>
      <td>10.451118</td>
    </tr>
    <tr>
      <th>2</th>
      <td>141.032567</td>
      <td>10.451118</td>
    </tr>
    <tr>
      <th>3</th>
      <td>248.708783</td>
      <td>10.451118</td>
    </tr>
    <tr>
      <th>4</th>
      <td>781.364767</td>
      <td>10.451118</td>
    </tr>
    <tr>
      <th>5</th>
      <td>125.739050</td>
      <td>10.451118</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train_2, X_test_2, y_train_2, y_test_2 = train_test_split(X_2, y, stratify=X[<span class="string">&#x27;followers&#x27;</span>], random_state = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># linreg = sklearn.linear_model.Lasso(alpha=0.114514)</span></span><br><span class="line"><span class="comment"># linreg = sklearn.linear_model.ElasticNet(alpha=0.114514, l1_ratio=0.5)</span></span><br><span class="line">linreg = sklearn.linear_model.LinearRegression()</span><br><span class="line">linreg.fit(X_train_2, y_train_2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(linreg.coef_)</span><br><span class="line"><span class="built_in">print</span>(linreg.intercept_)</span><br><span class="line"></span><br><span class="line">y_test_reg = linreg.predict(X_test_2)</span><br><span class="line">y_train_reg = linreg.predict(X_train_2)</span><br><span class="line"></span><br><span class="line">accuracy_train_2 = linreg.score(X_train_2, y_train_2)</span><br><span class="line">accuracy_test_2 = linreg.score(X_test_2, y_test_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Regression r^2 on training data: %f&quot;</span>%accuracy_train_2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Regression r^2 on test data: %f&quot;</span>%accuracy_test_2)</span><br><span class="line"></span><br><span class="line">X_train_2, X_test_2, y_train_2, y_test_2 = train_test_split(X_2, y_prime, stratify=X[<span class="string">&#x27;followers&#x27;</span>], random_state = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># linreg = sklearn.linear_model.Lasso(alpha=0.114514)</span></span><br><span class="line"><span class="comment"># linreg = sklearn.linear_model.ElasticNet(alpha=0.114514, l1_ratio=0.5)</span></span><br><span class="line">linreg_2 = sklearn.linear_model.LinearRegression()</span><br><span class="line">linreg_2.fit(X_train_2, y_train_2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(linreg_2.coef_)</span><br><span class="line"><span class="built_in">print</span>(linreg_2.intercept_)</span><br><span class="line"></span><br><span class="line">y_test_reg = linreg_2.predict(X_test_2)</span><br><span class="line">y_train_reg = linreg_2.predict(X_train_2)</span><br><span class="line"></span><br><span class="line">accuracy_train_2 = linreg_2.score(X_train_2, y_train_2)</span><br><span class="line">accuracy_test_2 = linreg_2.score(X_test_2, y_test_2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Regression r^2 on training data: %f&quot;</span>%accuracy_train_2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Regression r^2 on test data: %f&quot;</span>%accuracy_test_2)</span><br></pre></td></tr></table></figure>
<pre><code>[0.00242135 0.45857431]
0.1472356138320805
Regression r^2 on training data: 0.122934
Regression r^2 on test data: 0.112910
[0.00194852 0.29509566]
2.8008611812800313
Regression r^2 on training data: 0.064087
Regression r^2 on test data: 0.052279
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_hat_2 = linreg.predict(X_2)</span><br><span class="line">sns.displot(y - y_hat_2)</span><br><span class="line">plt.title(<span class="string">&quot;Residuals&quot;</span>);</span><br></pre></td></tr></table></figure>
<img src="/2023/02/11/analysis/data-analysis-tutorial_60_0.png" class="">
<p>所以，模型说：</p>
<script type="math/tex; mode=display">
\log(\text{superchatIncome}) = {0.00242135}\text{timeDuration} + {0.45857431}\log(\text{followers}) + 0.1472356138320805 \\
\log(\text{membershipIncome}) = {0.00194852}\text{timeDuration} + {0.29509566}\log(\text{followers}) + 2.8008611812800313</script><p>这就可以让主播根据自己的粉丝数量和想要直播的长度来估算自己的收入水平。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>我们的目标是给出一段字符来判断这是属于哪个主播的直播间标题。根据上面的 cheatsheet ，我们可以使用 <code>naiveBayes</code> 方法。</p>
<p>首先我们进行一个数据预处理，把所有的主播名称转换为 id ，这样方便模型训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ml_nb = df[[<span class="string">&#x27;liver&#x27;</span>, <span class="string">&#x27;title&#x27;</span>]]</span><br><span class="line">ml_nb[<span class="string">&#x27;liver_id&#x27;</span>] = ml_nb[<span class="string">&#x27;liver&#x27;</span>].factorize()[<span class="number">0</span>]</span><br><span class="line">liver_id_df = ml_nb[[<span class="string">&#x27;liver&#x27;</span>, <span class="string">&#x27;liver_id&#x27;</span>]].drop_duplicates().sort_values(<span class="string">&#x27;liver_id&#x27;</span>)</span><br><span class="line">liver_to_id = <span class="built_in">dict</span>(liver_id_df.values)</span><br><span class="line">id_to_liver = <span class="built_in">dict</span>(liver_id_df[[<span class="string">&#x27;liver_id&#x27;</span>, <span class="string">&#x27;liver&#x27;</span>]].values)</span><br><span class="line"></span><br><span class="line">ml_nb.sample(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>liver</th>
      <th>title</th>
      <th>liver_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>299</th>
      <td>九十九_Tsukumo</td>
      <td>《好九不见》</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1386</th>
      <td>步玎Pudding</td>
      <td>最期待的原神3.2主线</td>
      <td>27</td>
    </tr>
    <tr>
      <th>58</th>
      <td>りんうらん霖雨蘭</td>
      <td>【B限】英雄联盟手游K/DA！可爱qq！</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1534</th>
      <td>瑞娅_Rhea</td>
      <td>稍微说一会就去睡觉</td>
      <td>30</td>
    </tr>
    <tr>
      <th>2036</th>
      <td>茶冷_Channel</td>
      <td>茶冷复播，答记者问</td>
      <td>41</td>
    </tr>
    <tr>
      <th>2132</th>
      <td>路希维德Wiede</td>
      <td>元宵快乐</td>
      <td>43</td>
    </tr>
    <tr>
      <th>169</th>
      <td>东爱璃Lovely</td>
      <td>出道1000天啦！</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1746</th>
      <td>红晓音Akane</td>
      <td>【环】突击初代艾尔登之王！</td>
      <td>35</td>
    </tr>
    <tr>
      <th>2065</th>
      <td>茶冷_Channel</td>
      <td>3D化后日谈+沉浸式低音谢礼物</td>
      <td>41</td>
    </tr>
    <tr>
      <th>566</th>
      <td>可妮Koni_Official</td>
      <td>睡眠导入原神~</td>
      <td>11</td>
    </tr>
  </tbody>
</table>
</div>



<p>然后我们就需要对中文进行一些预处理工作，删掉文本中的标点符号和特殊符号，由于这里只是标题，所以我们觉得不需要去除停用词。最后我们使用 <code>jieba</code> 库进行分词。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> jieba <span class="keyword">as</span> jb</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_punctuations</span>(<span class="params">text</span>):</span></span><br><span class="line">    line = <span class="built_in">str</span>(text)</span><br><span class="line">    <span class="keyword">if</span> line.strip() == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    rule = re.<span class="built_in">compile</span>(<span class="string">u&quot;[^a-zA-Z0-9\u4E00-\u9FA5]&quot;</span>)</span><br><span class="line">    line = rule.sub(<span class="string">&#x27;&#x27;</span>,line)</span><br><span class="line">    <span class="keyword">return</span> line</span><br><span class="line"></span><br><span class="line">ml_nb[<span class="string">&#x27;clean_title&#x27;</span>] = ml_nb[<span class="string">&#x27;title&#x27;</span>].apply(remove_punctuations)</span><br><span class="line">ml_nb[<span class="string">&#x27;cut_title&#x27;</span>] = ml_nb[<span class="string">&#x27;clean_title&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="string">&#x27; &#x27;</span>.join(jb.cut(x)))</span><br><span class="line">ml_nb.sample(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>liver</th>
      <th>title</th>
      <th>liver_id</th>
      <th>clean_title</th>
      <th>cut_title</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2331</th>
      <td>雪绘Yukie</td>
      <td>一起来看游戏王GX！！</td>
      <td>47</td>
      <td>一起来看游戏王GX</td>
      <td>一起 来看 游戏王 GX</td>
    </tr>
    <tr>
      <th>2136</th>
      <td>路希维德Wiede</td>
      <td>密码？那是什么？？</td>
      <td>43</td>
      <td>密码那是什么</td>
      <td>密码 那 是 什么</td>
    </tr>
    <tr>
      <th>730</th>
      <td>奈姬Niki</td>
      <td>来一把</td>
      <td>14</td>
      <td>来一把</td>
      <td>来 一把</td>
    </tr>
    <tr>
      <th>1588</th>
      <td>病院坂Rei</td>
      <td>【歌杂】小幽灵唱歌喽！</td>
      <td>31</td>
      <td>歌杂小幽灵唱歌喽</td>
      <td>歌杂 小 幽灵 唱歌 喽</td>
    </tr>
    <tr>
      <th>1681</th>
      <td>眞白花音_Official</td>
      <td>【B限】圣诞节做料理直播</td>
      <td>33</td>
      <td>B限圣诞节做料理直播</td>
      <td>B 限 圣诞节 做 料理 直播</td>
    </tr>
    <tr>
      <th>289</th>
      <td>九十九_Tsukumo</td>
      <td>《整理房间unpacking》</td>
      <td>5</td>
      <td>整理房间unpacking</td>
      <td>整理 房间 unpacking</td>
    </tr>
    <tr>
      <th>1271</th>
      <td>李豆沙_Channel</td>
      <td>歌杂并水友连麦</td>
      <td>25</td>
      <td>歌杂并水友连麦</td>
      <td>歌杂 并 水友 连麦</td>
    </tr>
    <tr>
      <th>2052</th>
      <td>茶冷_Channel</td>
      <td>【工作音杂谈】安定的周日夜晚</td>
      <td>41</td>
      <td>工作音杂谈安定的周日夜晚</td>
      <td>工作 音 杂谈 安定 的 周日 夜晚</td>
    </tr>
    <tr>
      <th>1049</th>
      <td>折原露露</td>
      <td>我到家啦！！冲一下五十万关注！</td>
      <td>21</td>
      <td>我到家啦冲一下五十万关注</td>
      <td>我 到 家 啦 冲 一下 五十万 关注</td>
    </tr>
    <tr>
      <th>116</th>
      <td>七海Nana7mi</td>
      <td>玩空之要塞：启航！</td>
      <td>2</td>
      <td>玩空之要塞启航</td>
      <td>玩空 之 要塞 启航</td>
    </tr>
  </tbody>
</table>
</div>



<p>emmm…虽然看上去效果一般般，有一些连在一起的词语也被切开了，不过要啥自行车。接下来我们需要计算一下 TF-IDF 矩阵，然后就可以训练模型了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line">tfidf = TfidfVectorizer(norm=<span class="string">&#x27;l2&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, ngram_range=(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">features = tfidf.fit_transform(ml_nb.cut_title)</span><br><span class="line">labels = ml_nb.liver_id</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(features.shape)</span><br><span class="line"><span class="built_in">print</span>(features)</span><br></pre></td></tr></table></figure>
<pre><code>(2477, 5043)
  (0, 4078)    0.3867751769048678
  (0, 2723)    0.3867751769048678
  (0, 698)    0.4070981099498189
  (0, 770)    0.3867751769048678
  (0, 4076)    0.3520328933911443
  (0, 2721)    0.3095641893240464
  (0, 697)    0.4070981099498189
  (1, 4554)    0.407098109949819
  (1, 4553)    0.407098109949819
  (1, 4078)    0.38677517690486785
  (1, 2723)    0.38677517690486785
  (1, 770)    0.38677517690486785
  (1, 4076)    0.35203289339114435
  (1, 2721)    0.30956418932404645
  (2, 3042)    0.6414193873794413
  (2, 497)    0.5424855617865706
  (2, 3041)    0.5424855617865706
  (3, 3383)    1.0
  (4, 1218)    0.48709901556647317
  (4, 297)    0.48709901556647317
  (4, 533)    0.40395968534382953
  (4, 1217)    0.4627823203088134
  (4, 296)    0.3848612668155245
  (5, 3650)    0.6518999645492638
  (5, 1726)    0.3873665866351113
  :    :
  (2468, 3669)    0.3454638440279449
  (2468, 3667)    0.6909276880558898
  (2468, 201)    0.31598150913221407
  (2468, 2204)    0.2544382305640776
  (2469, 3645)    0.44721359549995787
  (2469, 4159)    0.44721359549995787
  (2469, 274)    0.44721359549995787
  (2469, 3644)    0.44721359549995787
  (2469, 4158)    0.44721359549995787
  (2470, 1118)    1.0
  (2471, 5008)    1.0
  (2472, 1502)    0.4786206467054956
  (2472, 28)    0.4786206467054956
  (2472, 1501)    0.4786206467054956
  (2472, 2506)    0.42462502625312665
  (2472, 27)    0.3639511185876078
  (2473, 3280)    0.5773502691896257
  (2473, 3278)    0.5773502691896257
  (2473, 3279)    0.5773502691896257
  (2474, 1777)    0.5773502691896257
  (2474, 4292)    0.5773502691896257
  (2474, 1776)    0.5773502691896257
  (2475, 1777)    0.5773502691896257
  (2475, 4292)    0.5773502691896257
  (2475, 1776)    0.5773502691896257
</code></pre><p>这里 <code>feature</code> 的形状是 <code>(2477, 5043)</code> ，前者表示标题数量，后者表示所有词语数 + 词语对的数量。然后我们就可以用朴素贝叶斯分类来计算啦。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer, TfidfTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(ml_nb[<span class="string">&#x27;cut_title&#x27;</span>], ml_nb[<span class="string">&#x27;liver_id&#x27;</span>], random_state=<span class="number">0</span>)</span><br><span class="line">count_vect = CountVectorizer()</span><br><span class="line">X_train_counts = count_vect.fit_transform(X_train)</span><br><span class="line"></span><br><span class="line">tfidf_transformer = TfidfTransformer()</span><br><span class="line">X_train_tfidf = tfidf_transformer.fit_transform(X_train_counts)</span><br><span class="line"></span><br><span class="line">clf = MultinomialNB().fit(X_train_tfidf, y_train)</span><br></pre></td></tr></table></figure>
<p>训练完成后，我们就可以让它来预测一下了。我们编写一个预测函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_liver</span>(<span class="params">text</span>):</span></span><br><span class="line">    text = remove_punctuations(text)</span><br><span class="line">    text = <span class="string">&#x27; &#x27;</span>.join(jb.cut(text))</span><br><span class="line">    <span class="keyword">return</span> id_to_liver[clf.predict(count_vect.transform([text]))[<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>
<p>我们以现在正在直播的主播来测试一下。</p>
<img src="/2023/02/11/analysis/%E5%8B%BA.png" class="">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">predict_liver(<span class="string">&#x27;收留失眠小狗 U・ェ・U&#x27;</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&#39;勺Shaun&#39;
</code></pre><h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>其实我们还可以继续做一些工作，比如说：</p>
<ul>
<li>在一周中不同的日子，直播的时长和收入会有什么变化？这和我们已经完成的分析有一定的关系，但是需要收集不同的数据。</li>
<li>关于一个 sc 的价格和大航海的类型与其他因素的关系，比如说直播时长，观众数量，粉丝数量等等。</li>
<li>特殊的直播（例如生日会/周年直播/耐久直播）和普通直播的收入差异。当然这就需要对数据手动进行分类了。</li>
</ul>
<h2 id="附录：数据集中包含的虚拟主播名单"><a href="#附录：数据集中包含的虚拟主播名单" class="headerlink" title="附录：数据集中包含的虚拟主播名单"></a>附录：数据集中包含的虚拟主播名单</h2><p>点击用户 id 即可跳转到其 bilibili 空间。直播数据截至 2023 年 2 月 9 日。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>所属</th>
<th>用户id</th>
</tr>
</thead>
<tbody>
<tr>
<td>七海Nana7mi</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/434334701">434334701</a></td>
</tr>
<tr>
<td>中单光一</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/434401868">434401868</a></td>
</tr>
<tr>
<td>内德维德</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/90873">90873</a></td>
</tr>
<tr>
<td>弥希Miki</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/477317922">477317922</a></td>
</tr>
<tr>
<td>星弥Hoshimi</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/477342747">477342747</a></td>
</tr>
<tr>
<td>真绯瑠mahiru</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/477306079">477306079</a></td>
</tr>
<tr>
<td>阿萨Aza</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/480680646">480680646</a></td>
</tr>
<tr>
<td>雪绘Yukie</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/56748733">56748733</a></td>
</tr>
<tr>
<td>千春_Chiharu</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/558070433">558070433</a></td>
</tr>
<tr>
<td>悠亚Yua</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/666726799">666726799</a></td>
</tr>
<tr>
<td>勺Shaun</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/666726801">666726801</a></td>
</tr>
<tr>
<td>勾檀Mayumi</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/690608693">690608693</a></td>
</tr>
<tr>
<td>九十九_Tsukumo</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/690608702">690608702</a></td>
</tr>
<tr>
<td>瑞娅_Rhea</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/690608698">690608698</a></td>
</tr>
<tr>
<td>恋诗夜Koxia</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/690608690">690608690</a></td>
</tr>
<tr>
<td>雾深Girimi</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/1484169431">1484169431</a></td>
</tr>
<tr>
<td>茶冷_Channel</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/741520">741520</a></td>
</tr>
<tr>
<td>阿梓从小就很可爱</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/7706705">7706705</a></td>
</tr>
<tr>
<td>小可学妹</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/14387072">14387072</a></td>
</tr>
<tr>
<td>诺莺Nox</td>
<td>vr</td>
<td><a href="https://space.bilibili.com/529249">529249</a></td>
</tr>
<tr>
<td>红晓音Akane</td>
<td>psp</td>
<td><a href="https://space.bilibili.com/899804">899804</a></td>
</tr>
<tr>
<td>东爱璃Lovely</td>
<td>psp</td>
<td><a href="https://space.bilibili.com/3821157">3821157</a></td>
</tr>
<tr>
<td>李豆沙_Channel</td>
<td>psp</td>
<td><a href="https://space.bilibili.com/1703797642">1703797642</a></td>
</tr>
<tr>
<td>白神遥Haruka</td>
<td>psp</td>
<td><a href="https://space.bilibili.com/477332594">477332594</a></td>
</tr>
<tr>
<td>病院坂Rei</td>
<td>psp</td>
<td><a href="https://space.bilibili.com/1041474702">1041474702</a></td>
</tr>
<tr>
<td>夏诺雅_shanoa</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/1612112">1612112</a></td>
</tr>
<tr>
<td>雫るる_Official</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/387636363">387636363</a></td>
</tr>
<tr>
<td>明前奶绿</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/2132180406">2132180406</a></td>
</tr>
<tr>
<td>九重紫Official</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/225347042">225347042</a></td>
</tr>
<tr>
<td>-阿蕊娅Aria-</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/10850238">10850238</a></td>
</tr>
<tr>
<td>步玎Pudding</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/416622817">416622817</a></td>
</tr>
<tr>
<td>烛灵儿Hikari</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/399815233">399815233</a></td>
</tr>
<tr>
<td>胡桃Usa</td>
<td>providence</td>
<td><a href="https://space.bilibili.com/12497617">12497617</a></td>
</tr>
<tr>
<td>花花Haya</td>
<td>providence</td>
<td><a href="https://space.bilibili.com/269415357">269415357</a></td>
</tr>
<tr>
<td>路希维德Wiede</td>
<td>meta-mythos</td>
<td><a href="https://space.bilibili.com/2006452883">2006452883</a></td>
</tr>
<tr>
<td>美月もも</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/2073012767">2073012767</a></td>
</tr>
<tr>
<td>早稻叽</td>
<td>chaoslive</td>
<td><a href="https://space.bilibili.com/1950658">1950658</a></td>
</tr>
<tr>
<td>尼奈nine_Official</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/163653">163653</a></td>
</tr>
<tr>
<td>陆鳐LuLu</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/1856528671">1856528671</a></td>
</tr>
<tr>
<td>罗菈Rola</td>
<td>another-project</td>
<td><a href="https://space.bilibili.com/2052064438">2052064438</a></td>
</tr>
<tr>
<td>奈姬Niki</td>
<td>another-project</td>
<td><a href="https://space.bilibili.com/3035105">3035105</a></td>
</tr>
<tr>
<td>折原露露</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/631070414">631070414</a></td>
</tr>
<tr>
<td>可妮Koni_Official</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/1372936974">1372936974</a></td>
</tr>
<tr>
<td>眞白花音_Official</td>
<td>chucolala</td>
<td><a href="https://space.bilibili.com/401480763">401480763</a></td>
</tr>
<tr>
<td>奈奈莉娅Channel</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/489146840">489146840</a></td>
</tr>
<tr>
<td>小柔Channel</td>
<td>虚研社</td>
<td><a href="https://space.bilibili.com/1734978373">1734978373</a></td>
</tr>
<tr>
<td>艾露露Ailurus</td>
<td>虚研社</td>
<td><a href="https://space.bilibili.com/1501380958">1501380958</a></td>
</tr>
<tr>
<td>りんうらん霖雨蘭</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/34815578">34815578</a></td>
</tr>
<tr>
<td>永雏塔菲</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/1265680561">1265680561</a></td>
</tr>
<tr>
<td>東雪蓮Official</td>
<td>independent</td>
<td><a href="https://space.bilibili.com/1437582453">1437582453</a></td>
</tr>
</tbody>
</table>
</div>
<p>别问为什么内德维德会夹在一群 vr 主播中，问就是某个龙神的数据不知为何无法抓取临时换的。</p>
]]></content>
      <tags>
        <tag>灵感</tag>
      </tags>
  </entry>
  <entry>
    <title>在墙上写诗的人</title>
    <url>/2022/12/16/%E5%9C%A8%E5%A2%99%E4%B8%8A%E5%86%99%E8%AF%97%E7%9A%84%E4%BA%BA/</url>
    <content><![CDATA[<p>町は開かれた書物である、書くべき余白が無限にある。 ——寺山修司</p>
<span id="more"></span>
<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>几年前，大概是 2023 年初的时候，我走在回家的路上。记得当时是刚放寒假，午后的阳光明媚，隆冬的寒气冷得干冽清爽。我目光掠过过一家家的店铺：天总归还是太冷了，街头多多少少还是缺点人气。快到家时，我走进那条熟悉的巷子，阳光落在煤烟浸过的白墙上，墙上散落的小广告与宣传标语。在那颗老榆树的旁边，我看到了那个人。</p>
<p>他穿着破旧的黑色羽绒服，上面沾满了白灰，裤子则是直挺挺的西裤，当然裤脚上也满是尘土。毛线帽子歪斜地戴在头上，背对着我的脸不停地吐着白气，似乎在暖他那只冻得通红的右手，而那手上攥着一支记号笔。</p>
<p>他正在那面白墙上写着什么。</p>
<p>他的动作小心得似乎有些怯懦，仿佛在做什么见不得光的事情。我轻轻的走到他的身后，看到了那行字的前半部分：</p>
<blockquote>
<p>人民要拆除铁丝网，他们就拆除铁丝网。</p>
</blockquote>
<p>显然他还在写着下一行，那只记号笔似乎有些不出水了，也许是天气太冷了吧。他的第二行写得很费力，字迹也有些不清晰，但等他小心而又认真地写完了后，我认清了那行字：</p>
<blockquote>
<p>人民若渴望自由，他们就走出围墙。</p>
</blockquote>
<p>读完这句话，突然感觉好像一个小锤敲在心上，我楞住了，看着他缓慢地扣上笔帽、吹着手、哈口气、转身、最后与我目光相接。</p>
<p>我的存在显然吓了他一跳。而这时，我也看清了他的脸：嘴的四周蓄着桀骜的须，五官却透出些许可爱来，无框眼镜后面有一对幽深的眼睛。</p>
<p>然而他随后就头也不回的转身跑了，忙乱的背影似乎还带着些踉跄。</p>
<p>过了一会儿我缓过神来，再次面向那面灰白色的墙，在一种小广告的簇拥中，那两行潦草又有些清秀的字，没有落款。</p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>我带着这段多少算得上奇遇的记忆，迎来了放假后的第二天。而那条我上学时常走的路，我只在过年前两天与家人买菜的时候路过了一次。那时，父亲似乎也注意到了那行字，但他只是默默地读完，没有说什么。</p>
<p>然而我与那的故事还没有结束。随后的日子里，在我外出时，我逐渐与另外一些写在墙上的诗句不期而遇。他们可能出现在墙壁上、宣传横幅上或者垃圾桶的盖子上。有时，几行字环绕着电线杆；有时，一行诗斜在小区的大门；有时，则直接写在物业的通知上。</p>
<p>那些字句很少重复，且多半查不到出处。恐怕大部分都是那个人自己的话。其中有一些是很优美典雅的句子，比如：</p>
<blockquote>
<p>无数细小琐碎的苦难，填满了我们的一生。</p>
</blockquote>
<p>或者：</p>
<blockquote>
<p>衰朽的墙啊，我为你的裂痕歌唱，只是脱落的墙皮会使这行字消陨，你的传记将比你更加速朽。</p>
</blockquote>
<p>又或者：</p>
<blockquote>
<p>让我为你这北国的墙，添上长青的藤吧 —— 常春藤。</p>
</blockquote>
<p>但是更多的时候，这些句子似乎更加短小、更加有力，仿佛铁锤敲在铁砧上，铿锵有力。那时我还小，还不明白这些句子的意思，只是觉得这些文句很有嚼头，很是有趣，便时常停下来读一读。比如说：</p>
<blockquote>
<p>（写在一处被居民锯开的铁门旁边）打碎旧世界的门！</p>
</blockquote>
<p>或者：</p>
<blockquote>
<p>想象力就是自由。</p>
</blockquote>
<p>又或：</p>
<blockquote>
<p>熄灭那屠刀的赤红，只需老痰和白眼。</p>
</blockquote>
<p>而还有一条，也许是因为那行字出现的环境，也许是我当天的心情，我至今背得出那段话 —— 当然，那是一段很长的话，而背诵的时候我也总是浑身颤抖：</p>
<blockquote>
<p>鲁迅总归还是太乐观了，仿佛散散步，新世界就会到来，不如说：这世上本没有路，牺牲者多了，尸体也便铺成了路。</p>
</blockquote>
<p>当然，再次与他本人相遇已经是很久之后了。</p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>事后想来，也许还是诗歌对我有着亲和力吧。今天与自己当年的同学聊到此事，他似乎只依稀记得此事的存在。而当时的自己，这很是喜欢这些文字，到不是说多么优美，只是感觉那些文字与自己的灵魂相契。</p>
<p>从那之后，我生活在这片街区就有了新的意义。在隆冬的雪花中走街串巷之时，我总会留心观察墙上是否有新的诗行，每一次发现新的诗，我总会非常欣喜。当然，其中有很多诗句我并不甚喜欢，但总有一些是叩击心灵的。而写的那些诗句的地方，就变成了我会有意造访的角落。在离我家大概五六百米远的一个地方，有一个街角的公园，几颗小榆树以及丁香树正在冬雪里孕育着明年的芽苞，一行在今天看来古老而可笑的宣传标语，刷满了鲜红色的漆。然而在后面的布告板上，写着一首长诗，我常常会到那里去，在四周无人的时候、在冬日枯树肃穆的环绕中、静静地朗读那首诗：</p>
<blockquote>
<p>我时常会想起<br>春寒中破土而出的第一棵草<br>它用年轻人似的莽撞<br>迎接着那尚未到来的暖阳</p>
<p>它是春的信使<br>那墙角的一抹亮色<br>宣告着一个时代的降临</p>
<p>然而，它来得太早<br>举目四望，只看到喑哑的大地<br>直到深夜，不堪晚霜的重围<br>冻结，无人问津</p>
<p>但，当太阳最终升起之时<br>它翠绿的身体挺立着<br>天空好似它的墓碑<br>大地好似他的坟。</p>
</blockquote>
<p>我在心中记下来那个公园，仿佛在城市之书中插入了一个书签。</p>
<p>然而，随后我就发现了一些异样。我看到一些曾经写过诗的地方，只剩下了一片重新涂上去的、补丁般的涂料。诗不见了。这让我不禁开始惊慌，我所珍爱的这个写满诗行的街区，也在经历着它缓慢的死亡。</p>
<p>第二天早上，我早早地起床，拿起本子和笔，走上街头去记下那些尚未被涂掉的字句。这是一场只属于我的文物抢救行动。手冻僵了，晤暖了之后再去记一条。一天下来，我走遍了这个街区，记下了二百五十三条。其中大部分我读过，少数则是这两天新增的。其中有的诗很长，有数十行之多，而大部分很短，有的甚至只有几个字。而在这些众多的文字之中，我也找到了一些有出处的话。比如：</p>
<blockquote>
<p>让人说话，天不会塌下来。</p>
</blockquote>
<p>又比如：</p>
<blockquote>
<p>要让人们去爱国，这个国家必须可爱才行。</p>
</blockquote>
<p>最终，回到家的时候，我用冻得发红的手攥着一个写满了字的笔记本，仿佛一本已经出版了的诗集，或者比如说，是这个 “城市之书” 的影印版。</p>
<p>第二天就是除夕夜了，傍晚在酒饭饱足之后，我一个人来到楼下放鞭炮。举目四望，天空中满是燃烧着的五彩的烟花，将单元楼下的地面映得白亮。被着无数人欢喜的象征围裹着的感觉，感觉真是美好极了。而在我转身去放鞭炮的时候，我看到了墙上一行大大的字：</p>
<blockquote>
<p>别了，这些五彩的谎言，要照亮这些黑夜，我们必得让自身成为星。</p>
</blockquote>
<p>然而这次与以往不同，我看到了落款：一名普通的中国人。</p>
<p>我突然似乎理解了这个在城市之中洒满诗歌的潜行者究竟想表达些什么。虽然只是朦朦胧胧地，但我认除出那股力量来自何方。顿时羽绒服里的暖意变得隆重可感了起来，仿佛温泉的水将我包裹，我看了看我那只裹在手套里的右手，只感到那手中有着无穷的力量。</p>
<p>随后，我心不在焉地放了鞭炮，爬上了楼。春晚的喧嚣与家人的祝酒似乎变得遥远而不真实，我心中只是一个念头：我想见见这个诗人，我想同他聊聊。</p>
<p>只是没有想到，第二天就实现了这个愿望。</p>
<h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>第二天早晨，我穿好鞋袜，带上手套，匆匆跑下楼 —— 我总是很喜欢在落满了鞭炮纸屑的雪地上漫步的感觉，仿佛在这无比严寒的关外之冬，人们还可以欣赏到满地的梅花。</p>
<p>随后，我在楼下看了那个人：同样的黑色羽绒服，同样沾着灰的西裤。他背对着我面对着那一行诗，双手抱头，后面两个穿着保安制服的人，其中一个大声地喊着：</p>
<p>“说，是不是你写的！”</p>
<p>那人没有吭声。</p>
<p>“我他妈问你话呢！别装死。”</p>
<p>寂静。</p>
<p>“我看见你不止一回了，鬼鬼祟祟在墙边整事儿。他妈忍你很久了，这回可倒好，有人给发到网上去了，市领导给小区打电话了… 走吧，我看你以后还敢不敢…”</p>
<p>“那是我写的！” 我不知当时何来的那么大的勇气。</p>
<p>保安和那个人倏地一下转过头来，一脸惊讶。随后那个保安问我：“你说什么？”</p>
<p>“那行字是我昨天晚上写的，当时就是… 觉得好玩… 不知道弄出这么大麻烦… 对不起。”</p>
<p>那个保安一脸疑惑，转头对那人说：“你认识她吗？” 那人一脸茫然地看着我。</p>
<p>随后他似乎打消了疑虑，但也是窝上了火。他没生好气地狠狠教训了我一顿，随后又和他的同事用喷雾涂料把那字盖住，又拍了一张照片，便踢着石块气鼓鼓地走了。</p>
<p>我总归是心有余悸的，一度非常担心他问我的身份证号，甚至是把我抓走。现在来看，似乎只是那两个保安想公报私仇罢了，借着市政府的恐慌解决一个他们烦了很久的人。但当时，我一边压着我胸口猛跳的心脏，一边转向的那个我许久想见的人。当时我有很多话想问，也有很多事情想告诉他，我想告诉他，那些被擦掉的诗并没有被所有人遗忘；我也想告诉他，那些诗对我来说意味着什么；我更想说，那些文字中包含着热情与理想，并没有在严寒中熄灭，而是点燃了一个高中生的心……</p>
<p>我说：“我经常能看到你的诗，很是喜欢。”</p>
<p>他微微一笑，说：“谢谢。”</p>
<p>随后，他起身走到我身边，望向远方，说出了我听到的他口中的第二句也是最后一句话：</p>
<p>“我还是很乐观的，所以我并不害怕，小姑娘，保护好自己，但是不要着急，你会见证历史的。” 随后，他向我道别，消失在了道路尽头的风雪中。</p>
<h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>那时我还小，只是单纯感觉这人的诗句催人奋进。然而随后才发现这些诗派上用场。</p>
<p>在日后几年人群的怒吼声中与那些标语与旗帜上，我时常能听到或看到那些字句。远方或身边的人们传递着这些口号，呼吁的进步与正义。那些我笔记本上的诗句，被其他不同的字迹写到了更多地方，甚至被人们推上了电视与朋友圈。</p>
<p>当然，在今天看来了，几句诗没办法推动历史，不如说他们仅仅是随风而起的纸屑，但我长大的这个城市中的居民，并不这么认为。那些诗就在他们身边一条条的涌现，至今我都能在某些墙上，看到他当年留下斑驳细弱的字迹，而也许旁边就是其他人用油漆涂出的整齐的放大版。</p>
<p>至于那个人呢？我之后从来没有再见过他。在那段激荡的岁月中，我听到了许多关于他的传言：有些人说他死于运动之中；有些人说出于畏惧隐姓埋名；有些人说作者就是现在的某某诗人，又摆出一系列他们来过这里的证据；而有些人说，他已经去了国外。</p>
<p>然而这些也许不重要了，那个人一直在这个笔记本中，这个在今天已经扩展到三百余条的 “城市之诗” 全集。这个小小的本子只中的三百余首诗，拼成了那个远去诗人的身影，也成了那激荡岁月最好的回忆录。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>写在通关 Persona 5 Royal 之后</title>
    <url>/2022/12/14/%E5%86%99%E5%9C%A8%E9%80%9A%E5%85%B3%E5%A5%B3%E7%A5%9E%E5%BC%82%E9%97%BB%E5%BD%95-5R-%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<blockquote>
<p>加强版要加强到什么程度，这是个问题。</p>
</blockquote>
<span id="more"></span>
<p>想要对 P5R 做出评价是一件很简单的事情：</p>
<p>对于没有玩过 P5 的玩家来说，这是一款让人满意的作品；对于玩过 P5 的玩家来说，这属于没有那么加强的加强版作品。</p>
<h2 id="P5-天下第一"><a href="#P5-天下第一" class="headerlink" title="P5 天下第一"></a>P5 天下第一</h2><p>对于 P5 的赞誉，想必大家都听过很多。它鲜亮而丰富，绵密而轻松，有着群众喜闻乐见的青春校园恋爱和纯真的少年正义，迷宫设计和流程节奏都十分扎实，游戏美术和配乐留给人的美妙印象在多年后也毫无褪色。</p>
<p>P5 除了基于系列本身的优化提升，还吸纳了衍生作《幻影异闻录》在迷宫、操作上的尝试性设计，把「女神转生」的仲魔交涉借来增加战斗的趣味。P5 不仅是「Persona」系列的集大成作，也是 Atlus 多年来 RPG 制作的精华凝聚。</p>
<p>当然，前作的优秀也就意味着大家会对加强版续作充满期待。很显然，P5R 并没有能够满足这些期待。</p>
<h2 id="形如二周目的-“加强”"><a href="#形如二周目的-“加强”" class="headerlink" title="形如二周目的 “加强”"></a>形如二周目的 “加强”</h2><p>相较于 P5， P5R 拥有了新剧情、新角色、新场景、新互动要素，可以说作为加强版确实已经足够了，但是十分可惜的是，他们是以一种类似于二周目的形式加入到游戏中的。</p>
<p>诚然，P5 玩个二周目也没什么不好，我本人就玩过两遍 P5，而且让玩家体验一遍原先的流程才能玩到新加的内容也算是游戏系列特色。但是这种二周目的形式，却让 P5R 的加强版失去了一些意义。</p>
<p>从 P5R 最初 4 小时左右的流程中我们就能感受到一些设计的局促，新角色芳泽霞在开篇即登场，之后在上学路上、校园走廊也与主角擦身而过，但皆是形影单薄。另一名新角色丸喜拓人也大抵如是。</p>
<p>另一方面，游戏原有流程增加了大量的细节改动，包括部分流程的缩减，迷宫内的钩锁和新的收集要素，还有道具配置方面的改动。于是，当角色可以自由行动、探索迷宫时，我在没有任何筹划准备的情况下，毫无障碍地用一次行动确保了鸭志田殿堂的路线，下一次进入殿堂就干掉了 BOSS。要知道，在 P5 的一周目中玩家达到这个流程进度，一般是在 10 小时之后。</p>
<p>很显然，P5R 尽了最大努力去减少「二周目」流程重复带来的疲劳感，设计者确实考虑了这一问题。然而这并不会改变它是一种重复的本质。钩锁也好、ShowTime 也好、新的场所吉祥寺也好、 COOP 剧情后追加一次电话问候也好，这些都不过是原有体系框架的点缀，并不会改变整个游戏给人的印象。</p>
<p>到游戏最后，终于有空间可以围绕新角色展开大段新剧情，我们则能更加明显地看出新追加内容和原有内容在结构上是并列组装的关系。而这些新追加内容在「二周目」的形式下，不得不匹配现有框架，被分散插入到一天天的日历中。</p>
<p>至于新角色和新剧情本身存在争议，那就是另一个层面的问题了。在重重限制下写出让大部分玩家满意的角色和故事，需要一支生花妙笔，但游戏的有趣体验，不能只靠生花妙笔来实现。</p>
<h2 id="或许需要一些新的东西"><a href="#或许需要一些新的东西" class="headerlink" title="或许需要一些新的东西"></a>或许需要一些新的东西</h2><p>「女神异闻录」现有的框架体系，适合各种题材的群像剧，能平衡地照顾各个主要角色，同时又不会使游戏拖沓繁重，是非常好的设计。</p>
<p>而在原有的群像中，并列地添加一两名角色，以此为卖点推出新游戏，则是一种过于保守的做法。它只是一种重复，它的上限几乎不可能超越原作，若新角色相比旧角色不够出众，还会导致更尴尬的结果。</p>
<p>激进一些做法，比如让新角色和所有旧角色发生交集（这些旧角色在原作中获得了玩家的喜爱），围绕新角色设计流程，从她 / 他的视角去体验原有内容，这样子游戏可能会更有趣。当然，这意味着更大的工作量，也伴随着更多的风险。</p>
<p>但这样会更有趣一点。</p>
<p>Atlus 的 RPG 代表着一种独特的风格和趣味，足以和其他伟大的 RPG 名作比肩。就个人而言，我不愿意看到 Atlus 太多的自我重复，特别是在集大成的 P5 之后，P5R 的自我重复越发让人难以接受。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>「女神异闻录」系列的 5 代，是给了我们无数惊喜的一代。从开发商的角度来说也好，从系列玩家的角度来说也好，都需要一款 P5R 来为系列 5 代收尾，而不是隔壁的 P5S。虽然 P5R 只是守成，在 P5 的基础上做了补完和符合预期的扩充，但在玩过 P5R 之后，我才有「女神异闻录」系列又走过了一代的平稳感觉。</p>
]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Burn This Book</title>
    <url>/2022/12/12/Burn-This-Book/</url>
    <content><![CDATA[<h1 id="烧掉这本书"><a href="#烧掉这本书" class="headerlink" title="烧掉这本书"></a>烧掉这本书</h1><h2 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h2><p>点燃这本书，最好从右下开始，让火焰首先将写着“一”的页码吞噬。<br>随后，火焰席卷这张纸，留下枯叶般的黑与雪花般的灰白。</p>
<span id="more"></span>
<h2 id="第二页"><a href="#第二页" class="headerlink" title="第二页"></a>第二页</h2><p>然而你翻开了第二页，<br>说明你没有按照说明书行事，<br>或许你是爱书的，或许你只是闲着无聊。<br>那么就看看这些句读罢！<br>这些句读，本是书写给火焰的情书。</p>
<h2 id="第三页"><a href="#第三页" class="headerlink" title="第三页"></a>第三页</h2><p>白色的纸上印着“版本馆”三个字。<br>没有插图，只有文字。空茫的土地上，立着三个钢铁铸成的大字。<br><strong>版本馆</strong><br>你在这三个大字之中，看到了曾见过的一切书籍，与你读到的一切版本。或许还有一束落在书架上的阳光，它照亮了空中的尘埃与书脊上的文字，或许那是你寻找已久的珍本，或许只是一串无聊的字符。<br>记忆的冷雾笼罩着那栋建筑的轮廓。</p>
<h2 id="第四页"><a href="#第四页" class="headerlink" title="第四页"></a>第四页</h2><p>随后，火焰将吞噬他。<br>当“版本馆”三个字呗被火的光明淹没之时，你仿佛能看到，记忆之雾中的版本馆，在它自己充作燃料的火炬中挣扎，只留下黑色的枯骨。<br>但你并不会伤心，因为你没有失去你的记忆，你失去的只是你手上的这本书。倘若你早早将它点燃，你将失去后文中所有的秘密。倘若，你读完之后再把它点燃，你失去的只是再次回顾的权利。<br>你的记忆是雾，你的遗忘是火。这本书终将燃烧，你记忆中的版本馆也是如此。火炬和时间总是狼狈为奸。</p>
<h2 id="第五页"><a href="#第五页" class="headerlink" title="第五页"></a>第五页</h2><p>请想象，现在是二百三十七年之后。<br>你拿着这本书的孤本（总有些人不会及时将它点燃），残破的枯黄的纸如晚秋的叶子，纸上的文字模糊而难以辨识。<br>但你并没有读到这一页，而是在翻开第一页时就听话地把它点燃了。<br>于是，人类永远失去了这本书。前行的利维坦失去了一片鳞片。</p>
<h2 id="第六页"><a href="#第六页" class="headerlink" title="第六页"></a>第六页</h2><p>然而，这又怎样呢？<br>想想那些在亚历山大图书馆毁灭之时，痛哭流涕的哲人吧！多少人的生命之火被熄灭了。<br>“火刑架上的火焰驱不散黑暗”</p>
<h2 id="第七页"><a href="#第七页" class="headerlink" title="第七页"></a>第七页</h2><p>当亚历山大的女哲人被狂热的教徒用蚌壳千刀万剐时，她是否会想起当年燃烧的图书馆呢？<br>那贪婪的火焰，吞噬着莎草纸上英雄的事迹、哲人的言行。许多史诗与歌谣消失化作尘土，坠入忘川；而生存于字里行间的人们 —— 那些孤本是他们存在过的唯一证据 —— 同样坠入了遗忘的夜，仿佛从未诞生过。<br>那是刀兵的凯旋。短剑与血红的蚌壳划过孕妇柔软的躯体。在那辉煌的火中，世界一片昏黑。</p>
<h2 id="第八页"><a href="#第八页" class="headerlink" title="第八页"></a>第八页</h2><p>希帕提亚死去了。她在愚昧与狂热中死去了，仿佛一本未被翻开、在火中燃烧的书。</p>
<h2 id="第九页"><a href="#第九页" class="headerlink" title="第九页"></a>第九页</h2><p>那个人死在卡廷的土丘上，浓黑的血流出了躯体，也一同带走了他的回忆：古老的华沙城街头的马蹄声、中学时课上讲过的拉丁文、香肠、酸黄瓜与伏特加的味道、音乐会上钢琴家弹奏肖邦一号夜曲时弹错的三个音符、婚姻、女儿出生时自己的欣喜、父亲葬礼上棺椁上的裂痕、俄国人留在自己家窗户上的三个弹孔……<br>无穷无尽的细节足以填满一本厚厚的回忆录。然而在一颗子弹之中，它们灰飞烟灭了。<br>当然，那本行走的回忆录本来也终有毁灭之时。在他弥留之际，他最终说出的话，仿佛是子孙留下的书摘。只是火焰来得太早，有如大雪就将初夏葱绿的田野覆盖。那些初生的苗早早夭亡。</p>
<h2 id="第十页"><a href="#第十页" class="headerlink" title="第十页"></a>第十页</h2><p>刀剑是历史上速生速朽的幽灵，他们在大地之上耀武扬威地流浪，点燃一座座繁荣的城：藏书、建筑、绘画与居民，都在那刀剑之火中呻吟着、寂灭着。<br>随后他们走上王座，吞食着成了活祭品的书。酒足饭饱之后，就把他们眼中的残羹冷炙在广场上付之一炬。品达的诗行与希罗多德的吟唱照亮了他们肥硕的脸。<br>他们贪恋着火炉的温暖，想着用炖得软烂的哲学选段与史书滋养身体、驱散体寒；他们又畏惧那书中的火苗，似乎唯有大地上无尽的黑夜才让他们安心。</p>
<h2 id="第十一页"><a href="#第十一页" class="headerlink" title="第十一页"></a>第十一页</h2><p>然而在那黑夜之中，有一个身影在巷子中潜行着，在死胡同的最深处那面被月光照亮了的白墙上，刻下了这样的字句：</p>
<h2 id="第十二页"><a href="#第十二页" class="headerlink" title="第十二页"></a>第十二页</h2><p>其他人的心脏都稳稳地待在胸腔内，<br>而我的身体呢？<br>浑身上下只有心脏，<br>所至之处都拉响了汽笛。</p>
<h2 id="第十三页"><a href="#第十三页" class="headerlink" title="第十三页"></a>第十三页</h2><p>那午夜的反叛者，叫做书。</p>
<h2 id="第十四页"><a href="#第十四页" class="headerlink" title="第十四页"></a>第十四页</h2><p>“火刑架的火焰驱不散黑暗”</p>
<h2 id="第十五页"><a href="#第十五页" class="headerlink" title="第十五页"></a>第十五页</h2><p>至此，你觉得刀剑之火已然无法舔舐书页的一角。<br>你大笑，你的笑声像是一团火焰，<br>融进了虚幻与碎片。<br>“虚幻呵，早已簇拥着书脊，拼凑出一曲全新的诗篇”<br>可一团绿色的虚拟之火裹挟着这本书，诉说起一个故事。</p>
<h2 id="第十六页"><a href="#第十六页" class="headerlink" title="第十六页"></a>第十六页</h2><p>（注：第十六页至第十九页内容由学习了前文所有内容后的 ChatGPT 生成）</p>
<p>烈焰燃烧着书页，<br>熊熊燃烧着心中的情怀。<br>黑烟升腾，<br>在空中留下一道影子。</p>
<p>但我并不害怕，<br>因为我曾经见过这一幕。<br>我熟悉火焰的脚步，<br>了解它的脾气。</p>
<p>它是我的指南针，<br>指引我走向殿堂。</p>
<p>我的记忆永远不会消失，<br>它们将留在我的心中。<br>一座不朽的纪念碑，<br>见证我的成长。</p>
<h2 id="第十七页"><a href="#第十七页" class="headerlink" title="第十七页"></a>第十七页</h2><p>书籍林立，我不知道该从哪里开始。<br>读书是我的旅程，寻找真正的书。<br>这本书具有魔力，捕捉我的记忆。<br>我不想被暴露，我离开这个地方。<br>我开始新的旅程，寻找属于我的书。</p>
<h2 id="第十八页"><a href="#第十八页" class="headerlink" title="第十八页"></a>第十八页</h2><p>书籍、旅程、寻找、不同的地方。</p>
<h2 id="第十九页"><a href="#第十九页" class="headerlink" title="第十九页"></a>第十九页</h2><p>A: 我来到了一个不同的地方，发现书籍在这里林立。<br>B: 你打算从哪本书开始？<br>A: 我不知道，我只知道我必须读下去。<br>B: 读书会让你变得更好。<br>A: 是的，我相信阅读会对让他们不能轻易地捕捉我的记忆。<br>B: 不要忘了，在你的旅程中，不断寻找新的书籍。<br>A: 是的，我会不断寻找，直到找到真正摆脱了他们。</p>
<h2 id="第二十页"><a href="#第二十页" class="headerlink" title="第二十页"></a>第二十页</h2><p>你甩开虚拟之火，大声疾呼：<br>是谁给予了“虚拟之火”自称火的勇气？<br>焚书的火只是北极的万年冰。<br>将书浸泡、包裹、熄灭。<br>书才是真正的火，跃动着生之激情的火，<br>在书架中、引文里、声带上、<br>或是阅读者的心间，长久地燃烧着。<br>是的，典雅的诗行终将变得古拗难识，<br>而不朽的铭文总似风海间的泡沫。<br>但是书还是燃烧着、燃烧着、<br>那每一个小小的铅字都是一簇烛火。<br>直到遗忘最终把丧钟敲响，<br>那时间烧成的灰烬，仍可以骄傲的说：<br>我曾经照亮过世界！</p>
<h2 id="第二十一页"><a href="#第二十一页" class="headerlink" title="第二十一页"></a>第二十一页</h2><p>因此，烧掉这本书吧。<br>让这本书，以及你将读到的每一本书，在你的心中燃烧。</p>
<p>再见了，在火焰中腾越而起的铅字的灵。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Ref-Nerf Implement And Speeding Up w/ instant-ngp</title>
    <url>/2022/11/22/Ref-Nerf-Implement/</url>
    <content><![CDATA[<p>好耶，复活了。时隔一年，我学会了不少新东西呢。比如，如何使用 instant-ngp 给 RefNerf 加速。</p>
<span id="more"></span>
<h2 id="Ref-Nerf-Implement-And-Speeding-Up-w-instant-ngp"><a href="#Ref-Nerf-Implement-And-Speeding-Up-w-instant-ngp" class="headerlink" title="Ref-Nerf Implement And Speeding Up w/ instant-ngp"></a>Ref-Nerf Implement And Speeding Up w/ instant-ngp</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CV ，炼丹界的内卷之王。 NeRF ，可谓是 CV 界的内卷之王。在今年的 CVPR 上，<a href="https://dorverbin.github.io/refnerf/">Ref NeRF</a> 作为 Best Student Paper Honorable Mention 横空出世，它基于 mip-NeRF 框架对反射现象进行了建模，在 NeRF 的基础上增加了 opacity, roughness, tint, normal 的估计。本文将会首先介绍一下 Ref NeRF 论文本身，然后简单聊聊复现思路以及使用 instant-ngp 加速的过程。不过目前，Ref NeRF 的复现结果还没有达到令我满意的程度，只是具备雏形，毕竟融合两篇文章的 idea 可能导致冲突，深度学习这种玄学就更是这样了，模型炸了都不知道从哪一个先开始。</p>
<h3 id="Ref-NeRF-论文简析"><a href="#Ref-NeRF-论文简析" class="headerlink" title="Ref-NeRF 论文简析"></a>Ref-NeRF 论文简析</h3><h4 id="反射建模"><a href="#反射建模" class="headerlink" title="反射建模"></a>反射建模</h4><p>Ref-NeRF 的一大亮点就在于它对于反射的建模，根据 Phong 模型，被观察到的光线为：</p>
<script type="math/tex; mode=display">
I_o=k_aI_a+\sum_ik_d(l_i\cdot n)I_i+\sum_ik_s(r_i\cdot v)^pI_i</script><p>其中，下标为 a 的部分与环境光（ambient light）有关；下标含有 d 则与漫反射有关，而下标含有 s 则与镜面高光有关。为了更好地解释 Ref NeRF 的反射模型处理以及回顾一下 Phong 模型这个基础模型，这里对模型简单解释：</p>
<ul>
<li>第一项代表环境光对观察结果的影响：环境光只对结果产生常数 offset</li>
<li>第二项代表了所有光源在物体上产生的漫反射。漫反射与观察方向无关，只要能观察到，就是 “恒定” 的。光源 i ($l_i$ 为其发射的某一光线的方向）发射光越是能垂直表面（与法向平行），漫反射越强。</li>
<li>第三项代表了镜面高光：不一定是完全的镜面反射（所以称之为镜面高光），可以稍显模糊，但是其强度是与视角有关的。$r_i$ 代表了反射光线的方向，$v$ 则代表了观察方向。两者重合（点乘结果接近 1）时，反射较强。指数 p 用于加强衰减，可知 p 越大，$(r_i\cdot v)^p$ 变化越快。也即视线与反射方向重合发生变化时，镜面高光的变化越明显。</li>
</ul>
<p>而我们的 Ref-NeRF 对后面两部分进行了建模：</p>
<script type="math/tex; mode=display">
L_{out}(\hat{\omega_o})\propto\int L_{in}(\hat{\omega_i})f(\hat{\omega_i},\hat{\omega_r})\mathrm d\hat{\omega_i}</script><p>其中，$L_{in}$ 为入射光，$L_{out}$ 为出射光，$f$ 为 BRDF（Bidirectional Reflectance Distribution Function）。很明显，这就是一个关于 $\omega_r$ 的函数，而这个 BRDF 我们试图通过神经网络直接学习出来。不过这也让我有些思考，如果把 Phong 模型换成 Blinn-Phong 模型会不会有所加速？毕竟 Blinn-Phong 模型不需要计算反射方向，而只需要通过平行四边形定理得到观察方向和入射方向的 “法线” 即可。</p>
<h4 id="directional-MLP-的修改"><a href="#directional-MLP-的修改" class="headerlink" title="directional MLP 的修改"></a>directional MLP 的修改</h4><p>在这里作者进行了一个类似于 mip NeRF 光锥采样的操作。在 mip NeRF 中，我们为了达到 mipmap 那样的感觉，进行了个一个光锥上的采样。而在 Ref NeRF 中，作者也认为 “反射” 也不能仅仅考虑单个反射方向。由于物体实际是凹凸不平的，并非完美的镜面，表面法向量并非完全一致。可以认为，物体表面的凹凸起伏（噪声），使得反射发生了一些改变（distortion），物体表面噪声的概率分布，经过反射的数学操作后被映射成了新的分布。</p>
<p>作者在这里使用了一个被称为 vMF 的概率分布，看上去就和高斯分布差不多，甚至有个别称叫做 normalized spherical gaussian 。个人推测作者选这个函数是为了方便进行后续的数学推导以及近似，就 像 mip NeRF 中，将光锥用混合高斯模型进行近似一样。有了此分布，自然需要使用积分将所有可能的反射方向考虑进去。在这里，作者使用了球谐函数进行方向编码，然后对其进行积分。</p>
<script type="math/tex; mode=display">
E_{\hat\omega\sim vMF(\hat\omega_r,\kappa)}\left[Y^m_l(\hat\omega)\right]=\exp(\frac{-l(l+1)}{2\kappa})Y^m_l(\hat\omega)</script><p>其中，$Y^m_l$ 为球谐函数，$\kappa$ 为 vMF 分布的参数，等于粗糙度的倒数。这里的 $l$ 代表了球谐函数的阶数，$l$ 越大，球谐函数的分布越均匀，而 $l$ 越小，球谐函数的分布越集中。$\kappa$ 越小，对于高阶（频）球谐影响越大。这也就反映了这样一个事实：光滑程度减小，高低频信息均有所衰减，但高频信息衰减更严重。</p>
<p>这里作者还给 directional MLP 喂了 $l_i\cdot n$ ，当然不是要建模漫反射，而是考虑到一些稍微复杂一些的效应，如菲涅尔效应（并非全反射，部分反射部分折射，反射所占的比例需要另外计算）等等。</p>
<h4 id="Normal-估计"><a href="#Normal-估计" class="headerlink" title="Normal 估计"></a>Normal 估计</h4><p>作者有言：</p>
<blockquote>
<p>normal vectors estimated from its volume density gradient as in Equation (上面那个) are often extremely noisy</p>
<p>NeRF tends to “fake” specular highlights by embedding emitters inside the object and partially occluding them with a “foggy” diffuse surface</p>
</blockquote>
<p>为此，作者设计了两个正则项，</p>
<ul>
<li>针对第一个问题，作者通过 spatial MLP 预测法向量 $\hat n$ ，将其和梯度法向量 $n^\prime$ 求一个 MSE。</li>
</ul>
<script type="math/tex; mode=display">
L_n=\sum_i\omega_i||{\hat n_i-n_i^\prime}||^2</script><p>由于 $\hat n$ 比较光滑，而 $n^\prime$ 是通过梯度求一阶导数求出来的，不是很光滑，所以我们可以通过光滑的数据给不光滑的梯度学一学，让它更加光滑。至于为何，小编也不知道（bushi），我认为大概是网络比较菜，所以只能学习低频部分，所以比较光滑。</p>
<ul>
<li>针对第二个问题，作者设计了一个正则项，用于惩罚反向的法向量。</li>
</ul>
<script type="math/tex; mode=display">
R_o=\sum_i\omega_i\max\left(0, \hat n_i\cdot\hat{\mathrm d}\right)^2</script><p>其实就是惩罚法向量和光线方向相同的部分，而且和 weight 有关。这就说明：被遮挡的有效背面不会被影响（weight 低），而 fake surface（在半透明 surface 后的 embedded emitter 表面）将会被惩罚（其 density 衰减方向与光线方向一致）。</p>
<p>然后作者说，把这两个正则项放在一起就可以得到一个比较好的效果。</p>
<ul>
<li>对于 $\hat n$ 和 $n^\prime$ 相差较大时，前者可以让网络使得两者相等，从而平滑梯度。</li>
<li>对于两者相差不大时，第二个正则项可以达到惩罚的目的得到更加合理的法向量。</li>
</ul>
<h3 id="复现中的细节"><a href="#复现中的细节" class="headerlink" title="复现中的细节"></a>复现中的细节</h3><h4 id="proposal-network"><a href="#proposal-network" class="headerlink" title="proposal network"></a>proposal network</h4><p>这里我们使用了 proposal network distillation ，而没有选择 stratified sampling 。stratified sampling非常慢（由于coarse network需要forward所有点，fine network也要forward），proposal network则是用浅MLP（5层），forward点后直接输出预测的density，再利用fine network输出的density（weight）进行监督。这样就能完成从fine network到proposal network的蒸馏。</p>
<p>但是雀氏也有一些问题，</p>
<img src="/2022/11/22/Ref-Nerf-Implement/noisy_balls.png" class="" title="why it is so noisy?">
<p>如图，这个球上有很多的噪点，怎么辉石呢？我们推断这是 density 有一些问题，于是进行了一些改动。</p>
<p>​原始prop net输入coarse points之后，输出density，此后coarse points将会被弃用。根据density计算的weight，将指导inverse sampling，fine network的输入只为inverse sampling的结果（也就是说，集中在weight高的地方）。假设，prop net计算的density有缺陷，也即weight有缺陷，在实际的表面附近weight很小，在空域中weight大，那么inverse sampling可能无法在此条光线上采到有效的点。</p>
<p>很简单，就是复用coarse points，将coarse depths（采样的长度）与inverse sampling的采样长度（fine depths）进行拼接，排序。但其实在实现中，要考虑proposal network的weight bound计算。啊，这一步很复杂。可以这么说：</p>
<ul>
<li>proposal network需要预测每一个采样点（fine采样点）的weight上界（weight bound）。上界如何计算？两个fine采样点之间会存在一个采样区间，此区间将会与coarse采样的区间重合，则此fine采样区间的weight上界应该是所有与之有交集的coarse区间weight之和。</li>
<li>coarse points合并到fine points相当于修改了fine采样区间。那么就需要计算更多区间交集。</li>
</ul>
<p>​这样修改，也就使得每条光线上，既有均匀采样的部分（保证了coverage），又使得density大的部分可以有更多采样点。可能有人觉得，不就是增加了一些采样点吗？这样为什么能保证proposal network的学习是正确的呢？很简单，网络不仅有更加充足的输入，fine network提供给proposal network的监督也更加充足了。</p>
<h4 id="instant-ngp"><a href="#instant-ngp" class="headerlink" title="instant ngp"></a>instant ngp</h4><p><a href="https://nvlabs.github.io/instant-ngp/">instant ngp</a> ，一种使用哈希编码用于加速神经网络训练的方法。简单来说，就是通过一个多分辨率的哈希映射到一个向量中，然后再进行插值得到一个训练出来的编码值。</p>

<p>虽然这个东西看上去很好很fancy，但是会有哈希碰撞的问题，作者说这玩意儿可以通过神经网络来学习减少问题，不过我们觉得不行，这会让我们训练出来的玩意儿非常的“粉”。</p>
<img src="/2022/11/22/Ref-Nerf-Implement/collision.png" class="" title="instant ngp collision">
<p>这个就很难受了，两个相距很远的点获得了类似的性质，导致一些没有意义的点也被赋予了奇怪的颜色，有意义的点也变得有很多空洞。为此我们尝试了增大哈希表的大小，但是这样就炸显存了，非常神秘。所以目前正在着手于实现一种更好的采样方法，这样或许可以减少冲突的问题。</p>
]]></content>
      <tags>
        <tag>灵感</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理Assignment5</title>
    <url>/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/</url>
    <content><![CDATA[<p>第五次图像信息处理作业，大致上就是图像的模糊和锐化吧。</p>
<span id="more"></span>
<h2 id="Assignment-5作业要求"><a href="#Assignment-5作业要求" class="headerlink" title="Assignment-5作业要求"></a>Assignment-5作业要求</h2><ul>
<li>Image mean filtering</li>
<li>Laplacian image enhancement</li>
</ul>
<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>其实由上次作业可以知道，图像的处理就是由一系列矩阵变换得到的结果，不过在这次作业中，我们选择的是对像素进行矩阵变换而不是像素坐标，而均值滤波，顾名思义，就是对图像像素取均值得到新的像素值，以$3\times3$矩阵为例，其变换矩阵如下</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix}\frac19 & \frac19 & \frac19 \\ \frac19 & \frac19 & \frac19 \\ \frac19 & \frac19 & \frac19 \\\end{bmatrix}</script><p>值得注意的是，对于边缘的像素值，我们在这里对其进行保留处理。由此我们可以很快的写出代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgMean</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* meanData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytes * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == height - <span class="number">1</span> || j == <span class="number">0</span> || j == width - <span class="number">1</span>) &#123;</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> r = *(imgData + i * lineBytes + j * <span class="number">3</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) +</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) +</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> g = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) +</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) +</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> b = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) +</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) +</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span>) = (<span class="keyword">uint8_t</span>)(r / <span class="number">9</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = (<span class="keyword">uint8_t</span>)(g / <span class="number">9</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = (<span class="keyword">uint8_t</span>)(b / <span class="number">9</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> meanData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果对比</p>
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/kagami.bmp" class="" title="This is the origin image">
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/mean_filter.bmp" class="" title="This is the filtered image">
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/a.jpg" class="">
<p>当然我们也可以修改均值滤波的矩阵，例如改成如下</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix}\frac1{16} & \frac18 & \frac1{16} \\ \frac18 & \frac14 & \frac18 \\ \frac1{16} & \frac18 & \frac1{16}\end{bmatrix}</script><p>那么这样图像的亮度也会有些许变化</p>
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/mean_filter1.bmp" class="" title="This is the filtered image">
<h3 id="拉普拉斯图像增强"><a href="#拉普拉斯图像增强" class="headerlink" title="拉普拉斯图像增强"></a>拉普拉斯图像增强</h3><p>这里我们使用拉普拉斯算子进行图像的增强，其中我们需要先计算出拉普拉斯遮罩</p>
<script type="math/tex; mode=display">
\nabla^2 f=\begin{bmatrix}1 & 1 & 1 \\ 1 & -8 & 1 \\ 1 & 1 & 1\end{bmatrix}</script><p>然后我们将原像素减去拉普拉斯遮罩即可得出锐化之后的图像，当然这里需要注意增强后的图像溢色的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgLaplacian</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* lapData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytes * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == height - <span class="number">1</span> || j == <span class="number">0</span> || j == width - <span class="number">1</span>) &#123;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> r = <span class="number">8</span> * *(imgData + i * lineBytes + j * <span class="number">3</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) -</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) -</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> g = <span class="number">8</span> * *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) -</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) -</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> b = <span class="number">8</span> * *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) -</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) -</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">                r += *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">                g += *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                b += *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">                r = r &gt; <span class="number">255</span> ? <span class="number">255</span> : r;</span><br><span class="line">                g = g &gt; <span class="number">255</span> ? <span class="number">255</span> : g;</span><br><span class="line">                b = b &gt; <span class="number">255</span> ? <span class="number">255</span> : b;</span><br><span class="line">                r = r &lt; <span class="number">0</span> ? <span class="number">0</span> : r;</span><br><span class="line">                g = g &lt; <span class="number">0</span> ? <span class="number">0</span> : g;</span><br><span class="line">                b = b &lt; <span class="number">0</span> ? <span class="number">0</span> : b;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span>) = r;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lapData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果如下</p>
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/laplacian_filter.bmp" class="" title="This is the laplaced image">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次作业确实还蛮简单的，最后总计的编程时间可能一个小时都不到，不过这些矩阵运算还是十分重要的</p>
<p>同时长远地想，配合别的不同的滤波器可以实现其他不同的效果，可以算是图像滤波的入门体验作业吧</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理作业Assignment4</title>
    <url>/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/</url>
    <content><![CDATA[<p>第四次图像信息处理作业解析，这次是图像仿射变换呢。</p>
<span id="more"></span>
<h2 id="Assignment-4作业要求"><a href="#Assignment-4作业要求" class="headerlink" title="Assignment-4作业要求"></a>Assignment-4作业要求</h2><ul>
<li><p>Translation</p>
</li>
<li><p>Rotation</p>
</li>
<li><p>Scale</p>
</li>
<li><p>Shear</p>
</li>
<li><p>Mirror</p>
</li>
</ul>
<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="仿射变换简介"><a href="#仿射变换简介" class="headerlink" title="仿射变换简介"></a>仿射变换简介</h3><p>图像上的仿射变换, 其实就是图片中的一个像素点，通过某种变换，移动到另外一个地方</p>
<p>从数学上来讲， 就是一个向量空间进行一次线形变换并加上平移向量， 从而变换到另外一个向量空间的过程</p>
<p>向量空间$\vec{m}$:</p>
<script type="math/tex; mode=display">
\vec{m}=(x,y)</script><p>向量空间$\vec{n}$ :</p>
<script type="math/tex; mode=display">
\vec{n}=(x′,y′)</script><p>向量空间从$\vec{m}$到$\vec{n}$的变换 $\vec{n}=A\vec{m}+\vec{b}$<br>整理得到:</p>
<script type="math/tex; mode=display">
x′=A_{00}∗x+A_{01}∗y+b_{0} \\
y′=A_{10}∗x+A_{11}∗y+b_{1}</script><p>将A跟b 组合在一起就组成了仿射矩阵 $M$。 它的维度是$2∗3$</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} A_{00} & A_{01} & b_{0} \\A_{10} & A_{11} & b_{1}\end{bmatrix}</script><p>使用不同的矩阵$M$就获得了不同的2D仿射变换效果。</p>
<h3 id="图像平移"><a href="#图像平移" class="headerlink" title="图像平移"></a>图像平移</h3><p>可以说是最简单的空间变换，其矩阵$M$为</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} 1 & 0 & b_{0} \\0 & 1 & b_{1} \\ 0 & 0 & 1\end{bmatrix}</script><p>因此，我们可以很快地写出代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgTranslation</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">int</span> x0, <span class="keyword">int</span> y0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytesOriginal = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> lineBytesTranslated = (bitCount * (width + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(x0)) / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* transData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesTranslated * (height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0))]&#123;&#125;;</span><br><span class="line">    y0 = y0 &gt; <span class="number">0</span> ? y0 : <span class="number">0</span>;</span><br><span class="line">    x0 = x0 &gt; <span class="number">0</span> ? x0 : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width * <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">            *(transData + (i + y0) * lineBytesTranslated + j - <span class="number">2</span> + x0 * <span class="number">3</span>) = r;</span><br><span class="line">            *(transData + (i + y0) * lineBytesTranslated + j - <span class="number">1</span> + x0 * <span class="number">3</span>) = g;</span><br><span class="line">            *(transData + (i + y0) * lineBytesTranslated + j + x0 * <span class="number">3</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意变化后<code>bmp</code>文件的<code>header</code>也需要同步变换，在这里给出变化后的<code>header</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BITMAPHEADER* Header = <span class="keyword">new</span> BITMAPHEADER;</span><br><span class="line">Header-&gt;bfType = <span class="number">0x4D42</span>;</span><br><span class="line">Header-&gt;bfSize = <span class="number">14</span> + <span class="number">40</span> + lineBytesTranslated * (height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0));</span><br><span class="line">Header-&gt;bfReserved1 = <span class="number">0</span>;</span><br><span class="line">Header-&gt;bfReserved2 = <span class="number">0</span>;</span><br><span class="line">Header-&gt;bfOffBits = <span class="number">14</span> + <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">BITMAPINFOHEADER* InfoHeader = <span class="keyword">new</span> BITMAPINFOHEADER;</span><br><span class="line">InfoHeader-&gt;biBitCount = <span class="number">24</span>;</span><br><span class="line">InfoHeader-&gt;biClrImportant = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biClrUsed = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biCompression = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biHeight = height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0);</span><br><span class="line">InfoHeader-&gt;biWidth = width + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(x0);</span><br><span class="line">InfoHeader-&gt;biPlanes = <span class="number">1</span>;</span><br><span class="line">InfoHeader-&gt;biSize = <span class="number">40</span>;</span><br><span class="line">InfoHeader-&gt;biSizeImage = lineBytesTranslated * (height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0));</span><br><span class="line">InfoHeader-&gt;biXPelsPerMeter = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biYPelsPerMeter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>向右上平移100像素的效果如图</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/translation.bmp" class="" title="This is the translated image">
<h3 id="图像旋转"><a href="#图像旋转" class="headerlink" title="图像旋转"></a>图像旋转</h3><p>通过数学推导，我们可以发现，旋转的矩阵$M$如下</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} \cos(\theta) & -\sin(\theta) & 0 \\ \sin(\theta) & \cos(\theta) & 0 \\ 0 & 0 & 1\end{bmatrix}</script><p>这里的$\theta$就是旋转的角度，但是很明显这里是以$(0, 0)$为基础进行的旋转，因此我们需要将我们想要的中心点平移至$(0,0)$再平移回来，即</p>
<script type="math/tex; mode=display">
\begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} = M_{translation}^{-1}(M_{rotation}(M_{translation} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}))</script><p>其中</p>
<script type="math/tex; mode=display">
M_{translation}=\begin{bmatrix} 1 & 0 & -c_x \\ 0 & 1 & -c_y \\ 0 & 0 & 1\end{bmatrix} \\
M_{rotation}=\begin{bmatrix} \cos(\theta) & -\sin(\theta) & 0 \\ \sin(\theta) & \cos(\theta) & 0 \\ 0 & 0 & 1\end{bmatrix}</script><p>因此，我们可以推导出$M$有</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} \cos(\theta) & -\sin(\theta) & (1-\cos(\theta))*c_x+\sin(\theta)*c_y \\ \sin(\theta) & \cos(\theta) & -\sin(\theta)*c_x+(1-\cos(\theta))*c_y \\ 0 & 0 & 1\end{bmatrix}</script><p>在代码实现部分，我们需要先确定四个角上的像素坐标，然后再将其规化全为正</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> radian = theta * PI / <span class="number">180.0</span>;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">4</span>], y[<span class="number">4</span>], cx = *width / <span class="number">2</span>, cy = *height / <span class="number">2</span>, xMax = <span class="number">0</span>, xMin = <span class="number">0</span>, yMax = <span class="number">0</span>, yMin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; *height + <span class="number">1</span>; i += *height) &#123;                           <span class="comment">//计算四个顶点的xy值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; *width + <span class="number">1</span>; j += *width) &#123;</span><br><span class="line">        x[i / *width + j / *height] = j * <span class="built_in">cos</span>(radian) - i * <span class="built_in">sin</span>(radian) + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cx + <span class="built_in">sin</span>(radian) * cy;</span><br><span class="line">        xMax = xMax &gt; x[i / *width + j / *height] ? xMax : x[i / *width + j / *height];</span><br><span class="line">        xMin = xMin &gt; x[i / *width + j / *height] ? x[i / *width + j / *height] : xMin;</span><br><span class="line">        y[i / *width + j / *height] = j * <span class="built_in">sin</span>(radian) + i * <span class="built_in">cos</span>(radian) - <span class="built_in">sin</span>(radian) * cx + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cy;</span><br><span class="line">        yMax = yMax &gt; y[i / *width + j / *height] ? yMax : y[i / *width + j / *height];</span><br><span class="line">        yMin = yMin &gt; y[i / *width + j / *height] ? y[i / *width + j / *height] : yMin;        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以以此来创建新的宽高的图像，然后根据矩阵一一对应</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newHeight = yMax - yMin, newWidth = xMax - xMin;                      <span class="comment">//得到新尺寸</span></span><br><span class="line"><span class="keyword">int</span> lineBytesRotated = (bitCount * newWidth / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> lineBytesOriginal = (bitCount * *width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">uint8_t</span>* rotaData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesRotated * newHeight]&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; *height; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; *width * <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">        <span class="keyword">int</span> x = j / <span class="number">3</span> * <span class="built_in">cos</span>(radian) - i * <span class="built_in">sin</span>(radian) + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cx + <span class="built_in">sin</span>(radian) * cy - xMin;</span><br><span class="line">        <span class="keyword">int</span> y = j / <span class="number">3</span> * <span class="built_in">sin</span>(radian) + i * <span class="built_in">cos</span>(radian) - <span class="built_in">sin</span>(radian) * cx + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cy - yMin;</span><br><span class="line">        *(rotaData + y * lineBytesRotated + x * <span class="number">3</span>) = r;</span><br><span class="line">        *(rotaData + y * lineBytesRotated + x * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">        *(rotaData + y * lineBytesRotated + x * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*height = newHeight;</span><br><span class="line">*width = newWidth;</span><br><span class="line"><span class="keyword">return</span> rotaData;</span><br></pre></td></tr></table></figure>
<p>逆时针旋转45度后效果如图</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/rotation.bmp" class="" title="This is the rotated image">
<p>可以看到图片上有很多黑点，这是因为像素旋转过程中我们舍弃了部分精度导致的，因此我们需要进一步进行插值算法，而插值的方法有很多，我们在这里选择双线性插值</p>
<h3 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h3><p>双线性插值利用旋转后图像中的点在原图所对应点周围四个点的数值，在两个方向分别进行线性插值来得到</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/bilinear.png" class="">
<p>记这四个点分别为$Q_{ij}(i,j=1,2)$，先对x轴方向做两次线性插值得到函数在$R_1$和$R_2$上的值，再对$R_1$和$R_2$做$y$轴方向的线性插值得到函数在所求点的值</p>
<script type="math/tex; mode=display">
f(P)=\frac{(y_2-y)(x_2-x)}{(y_2-y_1)(x_2-x_1)}f(Q_{11})+\frac{(y_2-y)(x-x_1)}{(y_2-y_1)(x_2-x_1)}f(Q_{21})+\frac{(y-y_1)(x_2-x)}{(y_2-y_1)(x_2-x_1)}f(Q_{12})+\frac{(y-y_1)(x-x_1)}{(y_2-y_1)(x_2-x_1)}f(Q_{22})</script><p>而对于旋转的图像，我们先对其变换矩阵$M$求逆运算，其实旋转矩阵的逆即是旋转矩阵的转置，因此</p>
<script type="math/tex; mode=display">
M^{-1}=\begin{bmatrix}\cos(\theta) & \sin(\theta) & (1-\cos(\theta))*c_x-\sin(\theta)*c_y \\ -\sin(\theta) & \cos(\theta) & \sin(\theta)*c_x+(1-\cos(\theta))*c_y \\ 0 & 0 & 1\end{bmatrix}</script><p>由此我们可以开始插值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newHeight; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newWidth; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(rotaData + i * lineBytesRotated + j * <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = j + xMin, y = i + yMin;</span><br><span class="line">            <span class="keyword">double</span> ox = x * <span class="built_in">cos</span>(radian) + y * <span class="built_in">sin</span>(radian) + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cx - <span class="built_in">sin</span>(radian) * cy;</span><br><span class="line">            <span class="keyword">double</span> oy = x * -<span class="built_in">sin</span>(radian) + y * <span class="built_in">cos</span>(radian) + <span class="built_in">sin</span>(radian) * cx + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cy;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">floor</span>(ox) &gt;=<span class="number">0.0</span> &amp;&amp; <span class="built_in">floor</span>(oy) &gt;=<span class="number">0.0</span> &amp;&amp; <span class="built_in">ceil</span>(ox) &lt; *width &amp;&amp; <span class="built_in">ceil</span>(oy) &lt; *height) &#123;</span><br><span class="line">                <span class="keyword">int</span> x[<span class="number">2</span>], y[<span class="number">2</span>];</span><br><span class="line">                x[<span class="number">0</span>] = <span class="built_in">floor</span>(ox); x[<span class="number">1</span>] = <span class="built_in">ceil</span>(ox);</span><br><span class="line">                y[<span class="number">0</span>] = <span class="built_in">floor</span>(oy); y[<span class="number">1</span>] = <span class="built_in">ceil</span>(oy);</span><br><span class="line">                <span class="keyword">uint8_t</span> r = (y[<span class="number">1</span>] - oy) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal) + </span><br><span class="line">                            (y[<span class="number">1</span>] - oy) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal);</span><br><span class="line">                <span class="keyword">uint8_t</span> g = (y[<span class="number">1</span>] - oy) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">1</span>) + </span><br><span class="line">                            (y[<span class="number">1</span>] - oy) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">uint8_t</span> b = (y[<span class="number">1</span>] - oy) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">2</span>) + </span><br><span class="line">                            (y[<span class="number">1</span>] - oy) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                *(rotaData + i * lineBytesRotated + j * <span class="number">3</span>) = r;</span><br><span class="line">                *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">                *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终效果如图</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/rotation1.bmp" class="" title="This is the rotated image">
<h3 id="图像放缩"><a href="#图像放缩" class="headerlink" title="图像放缩"></a>图像放缩</h3><p>很明显，这里需要用到上文提到的双线性插值算法，我们在这里换一种写法，相信聪明的你一眼就看出来这两种写法是一样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgScale</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">double</span> ratioA, <span class="keyword">double</span> ratioB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newHeight = <span class="built_in">floor</span>(height * ratioA);</span><br><span class="line">    <span class="keyword">int</span> newWidth = <span class="built_in">floor</span>(width * ratioB);</span><br><span class="line">    <span class="keyword">int</span> lineBytesScaled = (bitCount * newWidth / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> lineBytesOriginal = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* scaleData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesScaled * newHeight];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newHeight; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newWidth; j++) &#123;</span><br><span class="line">            <span class="keyword">double</span> y = i / ratioA;</span><br><span class="line">            <span class="keyword">double</span> x = j / ratioB;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; height - <span class="number">1</span>) y = height - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; width - <span class="number">1</span>) x = width - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> x1 = <span class="built_in">ceil</span>(x), y1 = <span class="built_in">ceil</span>(y), x2 = <span class="built_in">ceil</span>(x) + <span class="number">1</span>, y2 = <span class="built_in">ceil</span>(y) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt; width - <span class="number">1</span>)</span><br><span class="line">                x2 -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (y2 &gt; height - <span class="number">1</span>)</span><br><span class="line">                y2 -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">double</span> u = x + <span class="number">1</span> - x1;</span><br><span class="line">            <span class="keyword">double</span> v = y + <span class="number">1</span> - y1;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = (<span class="number">1</span> - u) * (<span class="number">1</span> - v) * *(imgData + x1 * <span class="number">3</span> + y1 * lineBytesOriginal) +</span><br><span class="line">                        (<span class="number">1</span> - u) * v * *(imgData + x1 * <span class="number">3</span> + y2 * lineBytesOriginal) +</span><br><span class="line">                        u * (<span class="number">1</span> - v) * *(imgData + x2 * <span class="number">3</span> + y1 * lineBytesOriginal) + </span><br><span class="line">                        u * v * *(imgData + x2 * <span class="number">3</span> + y2 * lineBytesOriginal);</span><br><span class="line">            <span class="keyword">uint8_t</span> g = (<span class="number">1</span> - u) * (<span class="number">1</span> - v) * *(imgData + x1 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                        (<span class="number">1</span> - u) * v * *(imgData + x1 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                        u * (<span class="number">1</span> - v) * *(imgData + x2 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">1</span>) + </span><br><span class="line">                        u * v * *(imgData + x2 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> b = (<span class="number">1</span> - u) * (<span class="number">1</span> - v) * *(imgData + x1 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                        (<span class="number">1</span> - u) * v * *(imgData + x1 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                        u * (<span class="number">1</span> - v) * *(imgData + x2 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">2</span>) + </span><br><span class="line">                        u * v * *(imgData + x2 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">2</span>);</span><br><span class="line">            *(scaleData + i * lineBytesScaled + j * <span class="number">3</span>) = r;</span><br><span class="line">            *(scaleData + i * lineBytesScaled + j * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">            *(scaleData + i * lineBytesScaled + j * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scaleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终横向拉伸一倍效果如下</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/scale.bmp" class="" title="This is the scaled image">
<h3 id="图像错切"><a href="#图像错切" class="headerlink" title="图像错切"></a>图像错切</h3><p>错切的本质是一种线性变换，可以算是学线性代数的时候的矩阵乘法启蒙变换了吧</p>
<p>对于水平错切，我们有矩阵$M$</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} 1 & m \\ 0 & 1 \end{bmatrix}</script><p>其中$m=\tan(\phi)$，也就是说我们将平面上的直线$y=b$错切成了$y=\frac{1}{m}x+b$</p>
<p>很明显，既然有水平错切那就自然有垂直错切，两者在代码上有众多相似之处，因此我们就在这里只实现水平错切</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgShear</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">double</span> ratio)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newWidth = <span class="built_in">floor</span>(height * <span class="built_in">fabs</span>(ratio)) + width;</span><br><span class="line">    <span class="keyword">int</span> lineBytesSheared = (bitCount * newWidth / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> lineBytesOriginal = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* shearData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesSheared * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ratio &lt; <span class="number">0</span>) offset = ratio * height;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = i;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">floor</span>(y * ratio) + j - offset;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytesOriginal + j * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytesOriginal + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytesOriginal + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            *(shearData + y * lineBytesSheared + x * <span class="number">3</span>) = r;</span><br><span class="line">            *(shearData + y * lineBytesSheared + x * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">            *(shearData + y * lineBytesSheared + x * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shearData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果比率小于零，那么我们就需要定义一个偏移量<code>offset</code>进行原点偏移，最终结果如下</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/shear.bmp" class="" title="This is the sheared image">
<h3 id="图像镜像"><a href="#图像镜像" class="headerlink" title="图像镜像"></a>图像镜像</h3><p>蛮简单的，没啥好说的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgMirror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* mirrorData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytes * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y,x;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                y = i;</span><br><span class="line">                x = width - j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                y = height - i - <span class="number">1</span>;</span><br><span class="line">                x = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            *(mirrorData + y * lineBytes + x * <span class="number">3</span>) = r;</span><br><span class="line">            *(mirrorData + y * lineBytes + x * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">            *(mirrorData + y * lineBytes + x * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mirrorData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/mirror.bmp" class="" title="This is the mirrored image">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然看上去这次作业也不算特别难，但是在编写代码的过程中我还是遇到了许多奇妙的问题，比如一些公式的笔误导致最终输出的图像根本不能看</p>
<p>而且有的时候图像的分辨率如果恰好是一个奇妙的数值，那么最后输出的图像就有可能会损坏，因此请随意使用本博客里的图像，它的鲁棒性十分的好</p>
<p>总之就是需要胆大心细地按部就班地编写程序，最终就一定会出现自己预想中的图像</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理作业Assignment3</title>
    <url>/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/</url>
    <content><![CDATA[<p>第三次图像信息处理作业解析，这次要对直方图动手了。</p>
<span id="more"></span>
<h2 id="Assignment-3作业要求"><a href="#Assignment-3作业要求" class="headerlink" title="Assignment-3作业要求"></a>Assignment-3作业要求</h2><ul>
<li>Image logarithmic operation for visibility enhancement</li>
<li>Histogram equalization<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="图像对数强化"><a href="#图像对数强化" class="headerlink" title="图像对数强化"></a>图像对数强化</h3></li>
</ul>
<p>这玩意儿老师上课貌似没讲，检索了一下大概就是通过如下的公式进行操作</p>
<script type="math/tex; mode=display">
S=c\times\log(1+r) \\
where,\qquad\qquad\qquad\\ S=\text{output pixel value} \\
C=\text{scaling constant} \\
R=\text{input pixel value}\\</script><p>在这里，我们定义如下的常数$C$</p>
<script type="math/tex; mode=display">
C=\frac{255}{\log(1+\text{max input pixel value})}</script><p>通过加一我们可以保证所有的$C$和$S$是非负数</p>
<p>首先先求出$C$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* max;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> data = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j);</span><br><span class="line">        max = max &gt; data ? max : data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> c = <span class="number">255.0</span> / (<span class="built_in">log</span>(<span class="number">1</span> + max));</span><br></pre></td></tr></table></figure>
<p>然后代入公式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* logData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height / <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> r = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j)</span><br><span class="line">        *(logData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = c * <span class="built_in">log</span>(<span class="number">1</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就获得了log后的图像</p>
<img src="/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/gray.bmp" class="" title="This is the gray image">
<img src="/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/log.bmp" class="" title="This is the log image">
<h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>考虑一个离散的灰度图像$x$，让$n_i$ 表示灰度$i$出现的次数，这样图像中灰度为$i$的像素的出现概率是</p>
<script type="math/tex; mode=display">
\ p_x(i) = p(x=i) = \frac{n_i}{n},\quad 0 \le i < L</script><p>$L$ 是图像中所有的灰度数（通常为256），$n$ 是图像中所有的像素数，$p_x(i)$实际上是像素值为$i$的图像的直方图，归一化到 [0,1]。</p>
<p>把对应于$p_x$的累积分布函数，定义为：</p>
<script type="math/tex; mode=display">
\ cdf_x(i) = \sum_{j=0}^i p_x(j),</script><p>是图像的累计归一化直方图。</p>
<p>我们创建一个形式为$ y= T(x)$ 的变换，对于原始图像中的每个值它就产生一个$y$，这样 $y$的累计概率函数就可以在所有值范围内进行线性化，转换公式定义为：</p>
<script type="math/tex; mode=display">
\ cdf_y(i) = iK</script><p>对于常数$K$。CDF的性质允许我们做这样的变换（参见逆分布函数）；定义为</p>
<script type="math/tex; mode=display">
\ cdf_y(y^\prime) = cdf_y(T(k)) = cdf_x(k)</script><p>其中$k$属于区间 [0,L)。注意 T 将不同的等级映射到${0..1}$​域，为了将这些值映射回它们最初的域，需要在结果上应用下面的简单变换：</p>
<script type="math/tex; mode=display">
\ y^\prime = y \cdot(\max\{x\} - \min\{x\}) + \min\{x\}</script><p>上面描述了灰度图像上使用直方图均衡化的方法，但是通过将这种方法分别用于图像RGB颜色值的红色、绿色和蓝色分量，从而也可以对彩色图像进行处理。</p>
<p>首先，我们需要先得到直方图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* histData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height / <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> hist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, eqHist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = height * width;</span><br><span class="line"><span class="keyword">double</span> fpHist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, eqHistTemp[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123; <span class="comment">//计算直方图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> GrayIndex = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j);</span><br><span class="line">        hist[GrayIndex]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们计算灰度分布和累计直方图分布</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123; <span class="comment">//计算灰度分布密度</span></span><br><span class="line">    fpHist[i] = (<span class="keyword">double</span>)hist[i] / (<span class="keyword">double</span>)size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123; <span class="comment">//计算累计直方图分布</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        eqHistTemp[i] = fpHist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        eqHistTemp[i] = eqHistTemp[i - <span class="number">1</span>] + fpHist[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以直接得出映射关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//累计分布取整，保存计算出来的灰度映射关系</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    eqHist[i] = (<span class="keyword">int</span>)(<span class="number">255.0</span> * eqHistTemp[i] + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123; <span class="comment">//进行灰度映射均衡化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> GrayIndex = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j);</span><br><span class="line">        *(histData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = eqHist[GrayIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如图</p>
<img src="/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/hist.bmp" class="" title="This is the log image">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说这次作业依然是十分的宁静祥和、简单质朴，不过在直方图均衡化的部分由于不太了解细节，因此借鉴了部分代码，写作风格也十分的奇妙，希望多多包含。</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理Assignment2</title>
    <url>/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<p>浙大的图像信息处理，一门奇妙的课程，老师上课吹水摸鱼，网上的资源也十分不集中。故在此开设专题作为图像信息处理作业的一个分享，请善用博客搜索功能。</p>
<span id="more"></span>
<h2 id="Assignment-2作业要求"><a href="#Assignment-2作业要求" class="headerlink" title="Assignment-2作业要求"></a>Assignment-2作业要求</h2><ul>
<li>Image binarization</li>
<li>Binary image erosion</li>
<li>Binary image dilation</li>
<li>Binary image opening</li>
<li>Binary image closing</li>
</ul>
<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="图像二值化"><a href="#图像二值化" class="headerlink" title="图像二值化"></a>图像二值化</h3><p>读取一张<code>.bmp</code>图像将其转换位二值图像，首先我们需要在C语言中定义图像信息结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> bfType;        <span class="comment">// 19778，必须是BM字符串，对应的十六进制为0x4d42,十进制为19778，否则不是bmp格式文件</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   bfSize;        <span class="comment">// 文件大小 以字节为单位(2-5字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> bfReserved1;   <span class="comment">// 保留，必须设置为0 (6-7字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> bfReserved2;   <span class="comment">// 保留，必须设置为0 (8-9字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   bfOffBits;     <span class="comment">// 从文件头到像素数据的偏移  (10-13字节)</span></span><br><span class="line">&#125; BITMAPHEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biSize;          <span class="comment">// 此结构体的大小 (14-17字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biWidth;         <span class="comment">// 图像的宽  (18-21字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biHeight;        <span class="comment">// 图像的高  (22-25字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  biPlanes;        <span class="comment">// 表示bmp图片的平面属，显然显示器只有一个平面，所以恒等于1 (26-27字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  biBitCount;      <span class="comment">// 一像素所占的位数，一般为24   (28-29字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biCompression;   <span class="comment">// 说明图象数据压缩的类型，0为不压缩。 (30-33字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biSizeImage;     <span class="comment">// 像素数据所占大小, 这个值应该等于上面文件头结构中bfSize-bfOffBits (34-37字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biXPelsPerMeter; <span class="comment">// 说明水平分辨率，用象素/米表示。一般为0 (38-41字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biYPelsPerMeter; <span class="comment">// 说明垂直分辨率，用象素/米表示。一般为0 (42-45字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biClrUsed;       <span class="comment">// 说明位图实际使用的彩色表中的颜色索引数（设为0的话，则说明使用所有调色板项）。 (46-49字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biClrImportant;  <span class="comment">// 说明对图象显示有重要影响的颜色索引的数目，如果是0，表示都重要。(50-53字节)</span></span><br><span class="line">&#125; BITMAPINFOHEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbBlue;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbGreen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbRed;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbReserved;</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure>
<p>然后进行图像头结构的读取与判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* bmpfile = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">BITMAPHEADER* header = <span class="keyword">new</span> BITMAPHEADER;</span><br><span class="line">BITMAPINFOHEADER* info = <span class="keyword">new</span> BITMAPINFOHEADER;</span><br><span class="line"><span class="keyword">if</span> (!bmpfile) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fread</span>(header, <span class="number">14</span>, <span class="number">1</span>, bmpfile);</span><br><span class="line"><span class="keyword">if</span> (header-&gt;bfType != <span class="number">0x4D42</span>) &#123; <span class="comment">//判断是否为bmp图像</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not a bitmap file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fread</span>(info, <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER), <span class="number">1</span>, bmpfile);</span><br></pre></td></tr></table></figure>
<p>赋值计算单行像素数量<code>lineBytes</code>并读取像素信息，注意由于<code>.bmp</code>文件单行像素一定是4的整倍数，因此需要补齐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> imSize = info-&gt;biSize;</span><br><span class="line"><span class="keyword">int</span> width = info-&gt;biWidth;</span><br><span class="line"><span class="keyword">int</span> height = info-&gt;biHeight;</span><br><span class="line"><span class="keyword">int</span> bitCount = info-&gt;biBitCount;</span><br><span class="line"><span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;  <span class="comment">//一行的byte数，四位补齐</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* imgData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line"><span class="built_in">fread</span>(imgData, lineBytes * height, <span class="number">1</span>, bmpfile);</span><br><span class="line"><span class="built_in">fclose</span>(bmpfile);</span><br></pre></td></tr></table></figure>
<p>在读取图像之后计算其灰度值，此时我们用$YUV$格式转换中的$Y$值表示灰度，转换公式如下</p>
<script type="math/tex; mode=display">
Y=0.299*R+0.587*G+0.114*B</script><p>由于$RGB$格式的大小是灰度图像的三倍，因此在创建灰度数据时要除以三再赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* biData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height / <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++)&#123; <span class="comment">//对于每一行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width * <span class="number">3</span>; j++)&#123; <span class="comment">//对于每一列</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> r = *(imgData + lineBytes * (height - <span class="number">1</span> - i) + j); <span class="comment">//从最后一行往上读</span></span><br><span class="line">		j++;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> g = *(imgData + lineBytes * (height - <span class="number">1</span> - i) + j);</span><br><span class="line">		j++;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> b = *(imgData + lineBytes * (height - <span class="number">1</span> - i) + j);</span><br><span class="line">		*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j / <span class="number">3</span>) = <span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">//完成灰度转换</span></span><br></pre></td></tr></table></figure>
<p>然后是二值化图像阈值的确定，根据课上内容我们可以知道，我们需要确定前景和背景然后让其组内方差最小且组间方差最大，这就是所谓<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%B4%A5%E7%AE%97%E6%B3%95"><strong>大津算法</strong></a>，链接中有通过直方图的C语言实现，可以作为补充阅读，我们这里使用与<a href="http://www.opencv.org/">OpenCV</a>相类似的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">otsuThreshold</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* biData, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> lineBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> GrayScale = <span class="number">256</span>; <span class="comment">//256级灰度</span></span><br><span class="line">    <span class="keyword">int</span> pixelCount[GrayScale] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> pixelPro[GrayScale] = &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> threshold = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;  <span class="comment">//统计每个灰度在像素中的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            ++pixelCount[(<span class="keyword">int</span>)*(biData + lineBytes * i + j)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; GrayScale; i++) &#123;  <span class="comment">//计算每个像素所占比例</span></span><br><span class="line">        pixelPro[i] = (<span class="keyword">double</span>)pixelCount[i] / (width * height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> w0, w1, u0tmp, u1tmp, u0, u1, u, deltaTmp, deltaMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; GrayScale; i++) &#123;</span><br><span class="line">        w0 = w1 = u0tmp = u1tmp = u0 = u1 = u = deltaTmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; GrayScale; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= i) &#123;  <span class="comment">//背景</span></span><br><span class="line">                w0 += pixelPro[j];</span><br><span class="line">                u0tmp += j * pixelPro[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">//前景</span></span><br><span class="line">                w1 += pixelPro[j];</span><br><span class="line">                u1tmp += j * pixelPro[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">//计算组间方差</span></span><br><span class="line">        u0 = u0tmp / w0;</span><br><span class="line">        u1 = u1tmp / w1;</span><br><span class="line">        u = u0tmp + u1tmp;</span><br><span class="line">        deltaTmp = w0 * <span class="built_in">pow</span>((u0 - u), <span class="number">2</span>) + w1 * <span class="built_in">pow</span>((u1 - u), <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (deltaTmp &gt; deltaMax) &#123;</span><br><span class="line">            deltaMax = deltaTmp;</span><br><span class="line">            threshold = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确定了阈值后就可以进行二值化了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> threshold = <span class="built_in">otsuThreshold</span>(biData, width, height, lineBytes / <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++)&#123; <span class="comment">//对于每一行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++)&#123; <span class="comment">//对于每一列</span></span><br><span class="line">		<span class="keyword">if</span> (*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) &gt;= threshold)</span><br><span class="line">			*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = <span class="number">255</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  <span class="comment">//完成二值化转换</span></span><br></pre></td></tr></table></figure>
<p>处理完数据后就可以写入二值文件了，首先是定义头文件和颜色表，然后写入数据即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* biBMP = <span class="built_in">fopen</span>(<span class="string">&quot;bi.bmp&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> lineBytesBi = (width * <span class="number">8</span> / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (!biBMP) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">BITMAPHEADER* biHeader = <span class="keyword">new</span> BITMAPHEADER;</span><br><span class="line">biHeader-&gt;bfType = <span class="number">0x4D42</span>;</span><br><span class="line">biHeader-&gt;bfSize = <span class="number">14</span> + <span class="number">40</span> + <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD) * <span class="number">256</span> + lineBytesBi * height;</span><br><span class="line">biHeader-&gt;bfReserved1 = <span class="number">0</span>;</span><br><span class="line">biHeader-&gt;bfReserved2 = <span class="number">0</span>;</span><br><span class="line">biHeader-&gt;bfOffBits = <span class="number">14</span> + <span class="number">40</span> + <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD) * <span class="number">256</span>;</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfType, <span class="number">2</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfSize, <span class="number">4</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved1, <span class="number">2</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved2, <span class="number">2</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfOffBits, <span class="number">4</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"></span><br><span class="line">BITMAPINFOHEADER* biInfoHeader = <span class="keyword">new</span> BITMAPINFOHEADER;</span><br><span class="line">biInfoHeader-&gt;biBitCount = <span class="number">8</span>;</span><br><span class="line">biInfoHeader-&gt;biClrImportant = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biClrUsed = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biCompression = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biHeight = height;</span><br><span class="line">biInfoHeader-&gt;biWidth = width;</span><br><span class="line">biInfoHeader-&gt;biPlanes = <span class="number">1</span>;</span><br><span class="line">biInfoHeader-&gt;biSize = <span class="number">40</span>;</span><br><span class="line">biInfoHeader-&gt;biSizeImage = lineBytesBi * height;</span><br><span class="line">biInfoHeader-&gt;biXPelsPerMeter = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biYPelsPerMeter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">fwrite</span>(biInfoHeader, <span class="number">40</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"></span><br><span class="line">RGBQUAD* pColorTable = <span class="keyword">new</span> RGBQUAD[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    pColorTable[i].rgbRed = i;</span><br><span class="line">    pColorTable[i].rgbGreen = i;</span><br><span class="line">    pColorTable[i].rgbBlue = i; <span class="comment">//是颜色表里的B、G、R分量都相等，且等于索引值</span></span><br><span class="line">    pColorTable[i].rgbReserved = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fwrite</span>(pColorTable, <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD), <span class="number">256</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(biData, lineBytesBi * height, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fclose</span>(biBMP);</span><br></pre></td></tr></table></figure>
<p>最终效果<br><img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/gouldian_finch.bmp" class="" title="This is the original image"><br><img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/bi.bmp" class="" title="This is the binary image"></p>
<h3 id="二值化图像腐蚀"><a href="#二值化图像腐蚀" class="headerlink" title="二值化图像腐蚀"></a>二值化图像腐蚀</h3><p>图像腐蚀，常用于使目标缩小，去除图像边界或者去除不想要的小物体（例如减噪等操作），计算方法为</p>
<script type="math/tex; mode=display">
A\ominus B=\{(x,y)\vert(B)_{xy}\subseteq A\}</script><p>其中$A$是二值化图像，$B$是腐蚀领域</p>
<p>具体操作就是用一个结构元素$B$(一般是3×3的大小)扫描图像$A$中的每一个像素，用结构元素中的每一个像素与其覆盖的像素做“与”操作，如果都为1，则该像素为1，否则为0</p>
<p>我们采用遍历与运算进行实现，此时</p>
<script type="math/tex; mode=display">
B=
\begin{bmatrix}0 & 1 & 0\\ 1 & 1 & 1 \\ 0 & 1 & 0\end{bmatrix}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="title">imgErosion</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* biData, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> lineBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* tempData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* eroData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="built_in">memcpy</span>(tempData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(eroData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(tempData + i * lineBytes + j) == <span class="number">0</span> || *(tempData + (i<span class="number">-1</span>) * lineBytes + j) == <span class="number">0</span> ||</span><br><span class="line">                *(tempData + (i+<span class="number">1</span>) * lineBytes + j) == <span class="number">0</span> || *(tempData + i * lineBytes + j+<span class="number">1</span>) == <span class="number">0</span> ||</span><br><span class="line">                *(tempData + i * lineBytes + j<span class="number">-1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                *(eroData + i * lineBytes + j) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                *(eroData + i * lineBytes + j) = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">delete</span></span>(tempData);</span><br><span class="line">    <span class="keyword">return</span> eroData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/ero.bmp" class="" title="This is the erosion image">
<h3 id="二值化图像膨胀"><a href="#二值化图像膨胀" class="headerlink" title="二值化图像膨胀"></a>二值化图像膨胀</h3><p>图像膨胀，常用于使目标增大，增粗字体，填补空洞，计算方法为</p>
<script type="math/tex; mode=display">
A\oplus B=\{z\vert(B)_z\cap A\neq\emptyset\}</script><p>其中$A$是二值化图像，$B$是膨胀领域</p>
<p>具体操作就是用一个结构元素(一般是3×3的大小)扫描图像中的每一个像素，用结构元素中的每一个像素与其覆盖的像素做“与”操作，如果都为0，则该像素为0，否则为1</p>
<p>由此可见膨胀和腐蚀其实是对称的运算，因此我们可以将两个运算合并在一起，此时</p>
<script type="math/tex; mode=display">
B=
\begin{bmatrix}0 & 1 & 0\\ 1 & 1 & 1 \\ 0 & 1 & 0\end{bmatrix}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="title">imgEroDila</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* biData, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> lineBytes, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* tempData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* rtnData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="keyword">int</span> p = (flag == <span class="number">1</span>) ? <span class="number">255</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(tempData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(rtnData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(tempData + i * lineBytes + j) == p || *(tempData + (i<span class="number">-1</span>) * lineBytes + j) == p ||</span><br><span class="line">                *(tempData + (i+<span class="number">1</span>) * lineBytes + j) == p || *(tempData + i * lineBytes + j+<span class="number">1</span>) == p ||</span><br><span class="line">                *(tempData + i * lineBytes + j<span class="number">-1</span>) == p) &#123;</span><br><span class="line">                *(rtnData + i * lineBytes + j) = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                *(rtnData + i * lineBytes + j) = <span class="number">255</span> - p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">delete</span></span>(tempData);</span><br><span class="line">    <span class="keyword">return</span> rtnData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/dila.bmp" class="" title="This is the dilation image">
<h3 id="二值化图像开运算"><a href="#二值化图像开运算" class="headerlink" title="二值化图像开运算"></a>二值化图像开运算</h3><p>开运算是先腐蚀后膨胀的过程，它可以消除图像上的细小噪声并平滑边界</p>
<p>有了上述的铺垫，我们可以很快的完成开运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* openBMP = <span class="built_in">fopen</span>(<span class="string">&quot;open.bmp&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfType, <span class="number">2</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfSize, <span class="number">4</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved1, <span class="number">2</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved2, <span class="number">2</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfOffBits, <span class="number">4</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(biInfoHeader, <span class="number">40</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(pColorTable, <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD), <span class="number">256</span>, openBMP);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* openData = <span class="built_in">imgEroDila</span>(biData, width, height, lineBytesBi, <span class="number">0</span>);</span><br><span class="line">openData = <span class="built_in">imgEroDila</span>(openData, width, height, lineBytesBi, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(openData, lineBytesBi * height, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fclose</span>(openBMP);</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/open.bmp" class="" title="This is the open image">
<h3 id="二值化图像闭运算"><a href="#二值化图像闭运算" class="headerlink" title="二值化图像闭运算"></a>二值化图像闭运算</h3><p>闭运算是先膨胀后腐蚀，它可以填充细小空洞并平滑边界</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* closeBMP = <span class="built_in">fopen</span>(<span class="string">&quot;close.bmp&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfType, <span class="number">2</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfSize, <span class="number">4</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved1, <span class="number">2</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved2, <span class="number">2</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfOffBits, <span class="number">4</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(biInfoHeader, <span class="number">40</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(pColorTable, <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD), <span class="number">256</span>, closeBMP);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* closeData = <span class="built_in">imgEroDila</span>(biData, width, height, lineBytesBi, <span class="number">1</span>);</span><br><span class="line">closeData = <span class="built_in">imgEroDila</span>(closeData, width, height, lineBytesBi, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(closeData, lineBytesBi * height, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fclose</span>(closeBMP);</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/close.bmp" class="" title="This is the close image">
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是图像信息处理的第二次作业，总的来说还是比较简单方便的，按照ppt上的说法一步一步来就能得出结果</p>
<p>希望这篇博文能够帮到你完成这次作业</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>Condition Number for Hilbert Matrix</title>
    <url>/2021/10/29/hilbert/</url>
    <content><![CDATA[<p>最近数值分析课遇到一个计算希尔伯特矩阵条件数随维数变化关系情况的问题，在此对其迭代解法的程序实现做一些小小的讨论</p>
<span id="more"></span>
<h2 id="希尔伯特矩阵"><a href="#希尔伯特矩阵" class="headerlink" title="希尔伯特矩阵"></a>希尔伯特矩阵</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%9F%A9%E9%98%B5">希尔伯特矩阵</a>是一种系数都是单位分数的方块矩阵，具体来说希尔伯特矩阵的第$i$行$j$列元素为：</p>
<script type="math/tex; mode=display">
H_{ij}=\frac{1}{i+j-1}</script><p>因此代码中可以通过双重循环构造矩阵（Golang实现）<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genHilbertMatrix</span><span class="params">(n <span class="keyword">int</span>)</span> [][]<span class="title">float64</span></span> &#123;</span><br><span class="line">	H := <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> H &#123; <span class="comment">//初始化矩阵</span></span><br><span class="line">		H[i] = <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">			x := <span class="keyword">float64</span>(i + j + <span class="number">1</span>)</span><br><span class="line">			H[i][j] = <span class="number">1.0</span> / x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> H</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="求取最大和最小特征值"><a href="#求取最大和最小特征值" class="headerlink" title="求取最大和最小特征值"></a>求取最大和最小特征值</h2><p>条件数K的定义为，对于任意范式$||·||$和非奇异矩阵$A$，有</p>
<script type="math/tex; mode=display">
K(A)=\left\|A\right\|\cdot\left\|A^{-1}\right\|</script><p>而对于<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5">正定矩阵</a>，可以证明条件数为</p>
<script type="math/tex; mode=display">
K(A)=\left|\frac{\lambda_{max}(A)}{\lambda_{min}(A)}\right|</script><p>很明显，希尔伯特矩阵是一个正定矩阵，因此只要求出其最大和最小特征值即可计算出条件数</p>
<h3 id="最大特征值计算"><a href="#最大特征值计算" class="headerlink" title="最大特征值计算"></a>最大特征值计算</h3><p>这里我们使用幂法进行计算，注意此时的前提条件为</p>
<script type="math/tex; mode=display">
\left|\lambda_1\right| > \left|\lambda_2\right| \geq \left|\lambda_3\right|\geq \cdots \geq \left|\lambda_n\right|</script><p>我们构造一系列向量序列，有</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{**lr**}
\vec{v_0}\in R^n\quad And\quad\vec{v_0}\neq\vec{0} \\
\vec{v_1}=A\vec{v_0} \\
\vec{v_{k+1}}=A\vec{v_k}\ (k=0,1,\cdots,n)
\end{array}
\right.</script><p>可以证明，</p>
<script type="math/tex; mode=display">
\lim_{k\to\infty}\frac{\left\|\vec{v_{k+1}}\right\|_i}{\left\|\vec{v_{k}}\right\|_i}=\lambda_1</script><p>同时在计算机计算过程中，为了防止数据过大导致的越界， 我们可以对$\vec{v_k}$进行规范化，即令</p>
<script type="math/tex; mode=display">
\vec{u_k}=\frac{\vec{v_k}}{\left\|\vec{v_k}\right\|_\infty}</script><p>然后对$\vec{u_k}$进行迭代与规范化操作</p>
<p>同时，我们可以证明</p>
<script type="math/tex; mode=display">
\lim_{k\to\infty}\left\|\vec{v_k}\right\|_\infty=\lambda_1</script><p>因此我们可以得出以下代码来计算最大特征值<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxLambda</span><span class="params">(mat [][]<span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> MaxIteration = <span class="number">10000</span></span><br><span class="line">	<span class="keyword">const</span> MaxError = <span class="number">0.00001</span></span><br><span class="line">	v0 := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n) <span class="comment">//生成迭代初始向量</span></span><br><span class="line">	v0[<span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">	lambda := <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> lambda0, counter := <span class="number">1.0</span>, <span class="number">1</span>; math.Abs(lambda-lambda0) &gt; MaxError &amp;&amp; counter &lt; MaxIteration; counter++ &#123; <span class="comment">//迭代边界，次数限制与误差限制</span></span><br><span class="line">		lambda0 = lambda</span><br><span class="line">		u := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)  <span class="comment">//生成迭代后向量</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//计算u=Av</span></span><br><span class="line">			u[i] = <span class="number">0.0</span></span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">				u[i] += mat[i][j] * v0[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		lambda = <span class="number">0.0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//找到最大值</span></span><br><span class="line">			<span class="keyword">if</span> lambda &lt; math.Abs(u[i]) &#123;</span><br><span class="line">				lambda = math.Abs(u[i])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//进行规范化</span></span><br><span class="line">			v0[i] = u[i] / lambda</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lambda</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="计算最小特征值"><a href="#计算最小特征值" class="headerlink" title="计算最小特征值"></a>计算最小特征值</h3><p>幂法十分完美地解决了最大特征值的问题，而对于最小特征值，我们可以很自然的想到只要求取$A^{-1}$的最大特征值，其倒数就是原矩阵的最小特征值<br>但这依然有些麻烦，因此我们可以使用$LU$分解绕过对$A$求逆的过程进行迭代，即通过解方程组：</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{**lr**}
L\vec{w}=\vec{v} \\
U\vec{u}=\vec{w} \\
\end{array}
\right.</script><p>即可通过$\vec{v}$得出$\vec{u}$的值</p>
<h3 id="LU-分解"><a href="#LU-分解" class="headerlink" title="$LU$分解"></a>$LU$分解</h3><p>事实上，将$A$进行初等行变换之后变成一个上三角矩阵，其变换矩阵就是一个下三角矩阵，这就是所谓$LU$分解</p>
<p>我们可以通过所谓杜尔利特算法进行分解，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LUDecomposition</span><span class="params">(mat [][]<span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="params">([][]<span class="keyword">float64</span>, [][]<span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	L, U := <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n), <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> mat &#123;</span><br><span class="line">		L[i], U[i] = <span class="built_in">make</span>([]<span class="keyword">float64</span>, n), <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		L[i][i] = <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			U[<span class="number">0</span>][<span class="number">0</span>] = mat[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">				U[<span class="number">0</span>][j] = mat[<span class="number">0</span>][j]</span><br><span class="line">				L[j][<span class="number">0</span>] = mat[<span class="number">0</span>][j] / U[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">//生成U</span></span><br><span class="line">				temp := <span class="number">0.0</span></span><br><span class="line">				<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; i; k++ &#123;</span><br><span class="line">					temp += L[i][k] * U[k][j]</span><br><span class="line">				&#125;</span><br><span class="line">				U[i][j] = mat[i][j] - temp</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123; <span class="comment">//生成L</span></span><br><span class="line">				temp := <span class="number">0.0</span></span><br><span class="line">				<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; i; k++ &#123;</span><br><span class="line">					temp += L[j][k] * U[k][i]</span><br><span class="line">				&#125;</span><br><span class="line">				L[j][i] = (mat[j][i] - temp) / U[i][i]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L, U</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回到最小特征值计算"><a href="#回到最小特征值计算" class="headerlink" title="回到最小特征值计算"></a>回到最小特征值计算</h3><p>得到了$LU$矩阵，我们只需要反解出$\vec{u}$的值即可迭代到我们需要的精度，代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinLambda</span><span class="params">(mat [][]<span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> MaxIteration = <span class="number">10000</span></span><br><span class="line">	<span class="keyword">const</span> MaxError = <span class="number">0.00001</span></span><br><span class="line">	L, U := LUDecomposition(mat, n)</span><br><span class="line">	v0 := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n) <span class="comment">//生成迭代初始向量</span></span><br><span class="line">	v0[<span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">	lambda := <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> lambda0, counter := <span class="number">1.0</span>, <span class="number">1</span>; math.Abs(lambda-lambda0) &gt; MaxError &amp;&amp; counter &lt; MaxIteration; counter++ &#123; <span class="comment">//迭代边界，次数限制与误差限制</span></span><br><span class="line">		lambda0 = lambda</span><br><span class="line">		w := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">		u := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//解出Lw=v</span></span><br><span class="line">			temp := <span class="number">0.0</span></span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">				temp += L[i][j] * w[j]</span><br><span class="line">			&#125;</span><br><span class="line">			w[i] = v0[i] - temp</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i-- &#123; <span class="comment">//解出Uu=w</span></span><br><span class="line">			temp := <span class="number">0.0</span></span><br><span class="line">			<span class="keyword">for</span> j := i; j &lt; n; j++ &#123;</span><br><span class="line">				temp += U[i][j] * u[j]</span><br><span class="line">			&#125;</span><br><span class="line">			u[i] = (w[i] - temp) / U[i][i]</span><br><span class="line">		&#125;</span><br><span class="line">		lambda = <span class="number">0.0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//找到最大值</span></span><br><span class="line">			<span class="keyword">if</span> lambda &lt; math.Abs(u[i]) &#123;</span><br><span class="line">				lambda = math.Abs(u[i])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//进行规范化</span></span><br><span class="line">			v0[i] = u[i] / lambda</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lambda</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算条件数"><a href="#计算条件数" class="headerlink" title="计算条件数"></a>计算条件数</h2><p>有了上面的前置工作，最后一步计算条件数就显得十分简单，不过我们在$getMinLambda()$中返回的是最小特征值的倒数，因此在最后直接两者相乘即可，最后代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">condNum</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	mat := genHilbertMatrix(n)</span><br><span class="line">	lambda1 := getMaxLambda(mat, n)</span><br><span class="line">	lambda2 := getMinLambda(mat, n)</span><br><span class="line">	cond := lambda1 * lambda2</span><br><span class="line">	<span class="keyword">return</span> cond</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><img src="/2021/10/29/hilbert/NAimg.png" class="" title="Data generated by Golang">
<p>通过与matlab输出进行对比，发现数据精度能达到四到五位</p>
<img src="/2021/10/29/hilbert/MLimg.png" class="" title="Data generated by Matlab">
<h2 id="无穷范数情况下的条件数"><a href="#无穷范数情况下的条件数" class="headerlink" title="无穷范数情况下的条件数"></a>无穷范数情况下的条件数</h2><p>之前通过特征值对于条件数的计算都是建立在2范数的情况下的，而本题讨论的其实是在无穷范数情况下的条件数变化（审题不清orz）</p>
<p>所幸，我们发现希尔伯特矩阵的逆矩阵可以通过特定公式来求解，即</p>
<script type="math/tex; mode=display">(H^{-1})_{ij}= (-1)^{i+j} (i + j - 1) \left( \begin{array}{cc} n + i - 1 \\ n - j \end{array} \right) \left( \begin{array}{cc} n + j - 1 \\ n - i \end{array} \right) \left( \begin{array}{cc} i + j - 2 \\ i - 1 \end{array} \right)\left( \begin{array}{cc} i + j - 2 \\ j - 1 \end{array} \right)</script><p>很明显，他是对称的，所以我们可以省下一半时间计算他们</p>
<p>但是显然，倘若通过阶乘式来求组合数十分容易溢出，故我们可以使用<a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95">辗转相除法</a>来不断约化防止溢出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">//求最大公因数</span></span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//约化a和b</span></span><br><span class="line">	gcd := gcd(a, b)</span><br><span class="line">	a /= gcd</span><br><span class="line">	b /= gcd</span><br><span class="line">	<span class="keyword">return</span> a, b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们就可以开始计算组合数了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combination</span><span class="params">(n, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	i := k + <span class="number">1</span></span><br><span class="line">	r := n - k</span><br><span class="line">	<span class="keyword">if</span> r &gt; k &#123; <span class="comment">//选择更少计算量的那一边</span></span><br><span class="line">		i = r + <span class="number">1</span></span><br><span class="line">		r = k</span><br><span class="line">	&#125;</span><br><span class="line">	f1, f2 := <span class="number">1</span>, <span class="number">1</span> <span class="comment">//分数的上下项</span></span><br><span class="line">	j := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt;= n; i++ &#123;</span><br><span class="line">		f1 *= i</span><br><span class="line">		<span class="keyword">for</span> ; j &lt;= r; j++ &#123;</span><br><span class="line">			f2 *= j</span><br><span class="line">			<span class="keyword">if</span> f2 &gt; f1 &#123; <span class="comment">//分母要小于分子啦~</span></span><br><span class="line">				j++</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> gcd := gcd(f1, f2); gcd &gt; <span class="number">1</span> &#123; <span class="comment">//计算中约化</span></span><br><span class="line">				f1, f2 = div(f1, f2)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f1 / f2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上文提到的公式，我们可以通过编程求出逆希尔伯特矩阵</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genInvHilbertMatrix</span><span class="params">(n <span class="keyword">int</span>)</span> [][]<span class="title">float64</span></span> &#123;</span><br><span class="line">	invH := <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> invH &#123; <span class="comment">//初始化矩阵</span></span><br><span class="line">		invH[i] = <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++ &#123; <span class="comment">//根据对称性减少一半计算量</span></span><br><span class="line">			x := (i + j + <span class="number">1</span>) * combination(n+i, n-j<span class="number">-1</span>) * combination(n+j, n-i<span class="number">-1</span>) * combination(i+j, i) * combination(i+j, j)</span><br><span class="line">			<span class="keyword">if</span> (i+j)%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">				invH[i][j], invH[j][i] = <span class="keyword">float64</span>(x), <span class="keyword">float64</span>(x)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				invH[i][j], invH[j][i] = <span class="keyword">float64</span>(-x), <span class="keyword">float64</span>(-x)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> invH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求无穷范数"><a href="#求无穷范数" class="headerlink" title="求无穷范数"></a>求无穷范数</h3><p>无穷范数，就是矩阵中绝对值和最大的一行，这个重复性操作可以很简单地用循环实现，代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">condNumInf</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	mat := genHilbertMatrix(n)</span><br><span class="line">	invMat := genInvHilbertMatrix(n)</span><br><span class="line">	normInf1, normInf2 := <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		sum1, sum2 := <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">			sum1 += math.Abs(mat[i][j])</span><br><span class="line">			sum2 += math.Abs(invMat[i][j])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sum1 &gt; normInf1 &#123;</span><br><span class="line">			normInf1 = sum1</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sum2 &gt; normInf2 &#123;</span><br><span class="line">			normInf2 = sum2</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> normInf1 * normInf2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2><img src="/2021/10/29/hilbert/NAInfimg.png" class="" title="Data generated by Golang">
<p>通过与matlab输出进行对比，发现数据精度能达到四到五位</p>
<img src="/2021/10/29/hilbert/MLInfimg.png" class="" title="Data generated by Matlab">
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
</search>
