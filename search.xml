<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/2021/10/28/World/</url>
    <content><![CDATA[<blockquote>
<p>于浩歌狂热之际中寒;于天上看见深渊。于一切眼中看见无所有;于无所希望中得救。</p>
</blockquote>
<p>欢迎来到Wandleshen的博客，目前是一个计算机专业在读大学生，还有很多东西需要学习呢。</p>
<h2 id="主营业务"><a href="#主营业务" class="headerlink" title="主营业务"></a>主营业务</h2><ul>
<li><a href="https://wandleshen.github.io/tags/%E5%88%B7%E9%A2%98/">刷题感想</a></li>
<li><a href="https://wandleshen.github.io/tags/%E9%9A%8F%E7%AC%94/">日常随笔</a></li>
<li><a href="https://wandleshen.github.io/tags/%E6%B8%B8%E6%88%8F/">游戏分享</a></li>
<li><a href="https://wandleshen.github.io/tags/%E7%81%B5%E6%84%9F/">灵感记录</a></li>
</ul>
]]></content>
      <tags>
        <tag>主页</tag>
      </tags>
  </entry>
  <entry>
    <title>写在通关 Persona 5 Royal 之后</title>
    <url>/2022/12/14/%E5%86%99%E5%9C%A8%E9%80%9A%E5%85%B3%E5%A5%B3%E7%A5%9E%E5%BC%82%E9%97%BB%E5%BD%95-5R-%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<blockquote>
<p>加强版要加强到什么程度，这是个问题。</p>
</blockquote>
<span id="more"></span>
<p>想要对 P5R 做出评价是一件很简单的事情：</p>
<p>对于没有玩过 P5 的玩家来说，这是一款让人满意的作品；对于玩过 P5 的玩家来说，这属于没有那么加强的加强版作品。</p>
<h2 id="P5-天下第一"><a href="#P5-天下第一" class="headerlink" title="P5 天下第一"></a>P5 天下第一</h2><p>对于 P5 的赞誉，想必大家都听过很多。它鲜亮而丰富，绵密而轻松，有着群众喜闻乐见的青春校园恋爱和纯真的少年正义，迷宫设计和流程节奏都十分扎实，游戏美术和配乐留给人的美妙印象在多年后也毫无褪色。</p>
<p>P5 除了基于系列本身的优化提升，还吸纳了衍生作《幻影异闻录》在迷宫、操作上的尝试性设计，把「女神转生」的仲魔交涉借来增加战斗的趣味。P5 不仅是「Persona」系列的集大成作，也是 Atlus 多年来 RPG 制作的精华凝聚。</p>
<p>当然，前作的优秀也就意味着大家会对加强版续作充满期待。很显然，P5R 并没有能够满足这些期待。</p>
<h2 id="形如二周目的-“加强”"><a href="#形如二周目的-“加强”" class="headerlink" title="形如二周目的 “加强”"></a>形如二周目的 “加强”</h2><p>相较于 P5， P5R 拥有了新剧情、新角色、新场景、新互动要素，可以说作为加强版确实已经足够了，但是十分可惜的是，他们是以一种类似于二周目的形式加入到游戏中的。</p>
<p>诚然，P5 玩个二周目也没什么不好，我本人就玩过两遍 P5，而且让玩家体验一遍原先的流程才能玩到新加的内容也算是游戏系列特色。但是这种二周目的形式，却让 P5R 的加强版失去了一些意义。</p>
<p>从 P5R 最初 4 小时左右的流程中我们就能感受到一些设计的局促，新角色芳泽霞在开篇即登场，之后在上学路上、校园走廊也与主角擦身而过，但皆是形影单薄。另一名新角色丸喜拓人也大抵如是。</p>
<p>另一方面，游戏原有流程增加了大量的细节改动，包括部分流程的缩减，迷宫内的钩锁和新的收集要素，还有道具配置方面的改动。于是，当角色可以自由行动、探索迷宫时，我在没有任何筹划准备的情况下，毫无障碍地用一次行动确保了鸭志田殿堂的路线，下一次进入殿堂就干掉了 BOSS。要知道，在 P5 的一周目中玩家达到这个流程进度，一般是在 10 小时之后。</p>
<p>很显然，P5R 尽了最大努力去减少「二周目」流程重复带来的疲劳感，设计者确实考虑了这一问题。然而这并不会改变它是一种重复的本质。钩锁也好、ShowTime 也好、新的场所吉祥寺也好、 COOP 剧情后追加一次电话问候也好，这些都不过是原有体系框架的点缀，并不会改变整个游戏给人的印象。</p>
<p>到游戏最后，终于有空间可以围绕新角色展开大段新剧情，我们则能更加明显地看出新追加内容和原有内容在结构上是并列组装的关系。而这些新追加内容在「二周目」的形式下，不得不匹配现有框架，被分散插入到一天天的日历中。</p>
<p>至于新角色和新剧情本身存在争议，那就是另一个层面的问题了。在重重限制下写出让大部分玩家满意的角色和故事，需要一支生花妙笔，但游戏的有趣体验，不能只靠生花妙笔来实现。</p>
<h2 id="或许需要一些新的东西"><a href="#或许需要一些新的东西" class="headerlink" title="或许需要一些新的东西"></a>或许需要一些新的东西</h2><p>「女神异闻录」现有的框架体系，适合各种题材的群像剧，能平衡地照顾各个主要角色，同时又不会使游戏拖沓繁重，是非常好的设计。</p>
<p>而在原有的群像中，并列地添加一两名角色，以此为卖点推出新游戏，则是一种过于保守的做法。它只是一种重复，它的上限几乎不可能超越原作，若新角色相比旧角色不够出众，还会导致更尴尬的结果。</p>
<p>激进一些做法，比如让新角色和所有旧角色发生交集（这些旧角色在原作中获得了玩家的喜爱），围绕新角色设计流程，从她 / 他的视角去体验原有内容，这样子游戏可能会更有趣。当然，这意味着更大的工作量，也伴随着更多的风险。</p>
<p>但这样会更有趣一点。</p>
<p>Atlus 的 RPG 代表着一种独特的风格和趣味，足以和其他伟大的 RPG 名作比肩。就个人而言，我不愿意看到 Atlus 太多的自我重复，特别是在集大成的 P5 之后，P5R 的自我重复越发让人难以接受。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>「女神异闻录」系列的 5 代，是给了我们无数惊喜的一代。从开发商的角度来说也好，从系列玩家的角度来说也好，都需要一款 P5R 来为系列 5 代收尾，而不是隔壁的 P5S。虽然 P5R 只是守成，在 P5 的基础上做了补完和符合预期的扩充，但在玩过 P5R 之后，我才有「女神异闻录」系列又走过了一代的平稳感觉。</p>
]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Burn This Book</title>
    <url>/2022/12/12/Burn-This-Book/</url>
    <content><![CDATA[<h1 id="烧掉这本书"><a href="#烧掉这本书" class="headerlink" title="烧掉这本书"></a>烧掉这本书</h1><h2 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h2><p>点燃这本书，最好从右下开始，让火焰首先将写着“一”的页码吞噬。<br>随后，火焰席卷这张纸，留下枯叶般的黑与雪花般的灰白。</p>
<span id="more"></span>
<h2 id="第二页"><a href="#第二页" class="headerlink" title="第二页"></a>第二页</h2><p>然而你翻开了第二页，<br>说明你没有按照说明书行事，<br>或许你是爱书的，或许你只是闲着无聊。<br>那么就看看这些句读罢！<br>这些句读，本是书写给火焰的情书。</p>
<h2 id="第三页"><a href="#第三页" class="headerlink" title="第三页"></a>第三页</h2><p>白色的纸上印着“版本馆”三个字。<br>没有插图，只有文字。空茫的土地上，立着三个钢铁铸成的大字。<br><strong>版本馆</strong><br>你在这三个大字之中，看到了曾见过的一切书籍，与你读到的一切版本。或许还有一束落在书架上的阳光，它照亮了空中的尘埃与书脊上的文字，或许那是你寻找已久的珍本，或许只是一串无聊的字符。<br>记忆的冷雾笼罩着那栋建筑的轮廓。</p>
<h2 id="第四页"><a href="#第四页" class="headerlink" title="第四页"></a>第四页</h2><p>随后，火焰将吞噬他。<br>当“版本馆”三个字呗被火的光明淹没之时，你仿佛能看到，记忆之雾中的版本馆，在它自己充作燃料的火炬中挣扎，只留下黑色的枯骨。<br>但你并不会伤心，因为你没有失去你的记忆，你失去的只是你手上的这本书。倘若你早早将它点燃，你将失去后文中所有的秘密。倘若，你读完之后再把它点燃，你失去的只是再次回顾的权利。<br>你的记忆是雾，你的遗忘是火。这本书终将燃烧，你记忆中的版本馆也是如此。火炬和时间总是狼狈为奸。</p>
<h2 id="第五页"><a href="#第五页" class="headerlink" title="第五页"></a>第五页</h2><p>请想象，现在是二百三十七年之后。<br>你拿着这本书的孤本（总有些人不会及时将它点燃），残破的枯黄的纸如晚秋的叶子，纸上的文字模糊而难以辨识。<br>但你并没有读到这一页，而是在翻开第一页时就听话地把它点燃了。<br>于是，人类永远失去了这本书。前行的利维坦失去了一片鳞片。</p>
<h2 id="第六页"><a href="#第六页" class="headerlink" title="第六页"></a>第六页</h2><p>然而，这又怎样呢？<br>想想那些在亚历山大图书馆毁灭之时，痛哭流涕的哲人吧！多少人的生命之火被熄灭了。<br>“火刑架上的火焰驱不散黑暗”</p>
<h2 id="第七页"><a href="#第七页" class="headerlink" title="第七页"></a>第七页</h2><p>当亚历山大的女哲人被狂热的教徒用蚌壳千刀万剐时，她是否会想起当年燃烧的图书馆呢？<br>那贪婪的火焰，吞噬着莎草纸上英雄的事迹、哲人的言行。许多史诗与歌谣消失化作尘土，坠入忘川；而生存于字里行间的人们 —— 那些孤本是他们存在过的唯一证据 —— 同样坠入了遗忘的夜，仿佛从未诞生过。<br>那是刀兵的凯旋。短剑与血红的蚌壳划过孕妇柔软的躯体。在那辉煌的火中，世界一片昏黑。</p>
<h2 id="第八页"><a href="#第八页" class="headerlink" title="第八页"></a>第八页</h2><p>希帕提亚死去了。她在愚昧与狂热中死去了，仿佛一本未被翻开、在火中燃烧的书。</p>
<h2 id="第九页"><a href="#第九页" class="headerlink" title="第九页"></a>第九页</h2><p>那个人死在卡廷的土丘上，浓黑的血流出了躯体，也一同带走了他的回忆：古老的华沙城街头的马蹄声、中学时课上讲过的拉丁文、香肠、酸黄瓜与伏特加的味道、音乐会上钢琴家弹奏肖邦一号夜曲时弹错的三个音符、婚姻、女儿出生时自己的欣喜、父亲葬礼上棺椁上的裂痕、俄国人留在自己家窗户上的三个弹孔……<br>无穷无尽的细节足以填满一本厚厚的回忆录。然而在一颗子弹之中，它们灰飞烟灭了。<br>当然，那本行走的回忆录本来也终有毁灭之时。在他弥留之际，他最终说出的话，仿佛是子孙留下的书摘。只是火焰来得太早，有如大雪就将初夏葱绿的田野覆盖。那些初生的苗早早夭亡。</p>
<h2 id="第十页"><a href="#第十页" class="headerlink" title="第十页"></a>第十页</h2><p>刀剑是历史上速生速朽的幽灵，他们在大地之上耀武扬威地流浪，点燃一座座繁荣的城：藏书、建筑、绘画与居民，都在那刀剑之火中呻吟着、寂灭着。<br>随后他们走上王座，吞食着成了活祭品的书。酒足饭饱之后，就把他们眼中的残羹冷炙在广场上付之一炬。品达的诗行与希罗多德的吟唱照亮了他们肥硕的脸。<br>他们贪恋着火炉的温暖，想着用炖得软烂的哲学选段与史书滋养身体、驱散体寒；他们又畏惧那书中的火苗，似乎唯有大地上无尽的黑夜才让他们安心。</p>
<h2 id="第十一页"><a href="#第十一页" class="headerlink" title="第十一页"></a>第十一页</h2><p>然而在那黑夜之中，有一个身影在巷子中潜行着，在死胡同的最深处那面被月光照亮了的白墙上，刻下了这样的字句：</p>
<h2 id="第十二页"><a href="#第十二页" class="headerlink" title="第十二页"></a>第十二页</h2><p>其他人的心脏都稳稳地待在胸腔内，<br>而我的身体呢？<br>浑身上下只有心脏，<br>所至之处都拉响了汽笛。</p>
<h2 id="第十三页"><a href="#第十三页" class="headerlink" title="第十三页"></a>第十三页</h2><p>那午夜的反叛者，叫做书。</p>
<h2 id="第十四页"><a href="#第十四页" class="headerlink" title="第十四页"></a>第十四页</h2><p>“火刑架的火焰驱不散黑暗”</p>
<h2 id="第十五页"><a href="#第十五页" class="headerlink" title="第十五页"></a>第十五页</h2><p>至此，你觉得刀剑之火已然无法舔舐书页的一角。<br>你大笑，你的笑声像是一团火焰，<br>融进了虚幻与碎片。<br>“虚幻呵，早已簇拥着书脊，拼凑出一曲全新的诗篇”<br>可一团绿色的虚拟之火裹挟着这本书，诉说起一个故事。</p>
<h2 id="第十六页"><a href="#第十六页" class="headerlink" title="第十六页"></a>第十六页</h2><p>（注：第十六页至第十九页内容由学习了前文所有内容后的 ChatGPT 生成）</p>
<p>烈焰燃烧着书页，<br>熊熊燃烧着心中的情怀。<br>黑烟升腾，<br>在空中留下一道影子。</p>
<p>但我并不害怕，<br>因为我曾经见过这一幕。<br>我熟悉火焰的脚步，<br>了解它的脾气。</p>
<p>它是我的指南针，<br>指引我走向殿堂。</p>
<p>我的记忆永远不会消失，<br>它们将留在我的心中。<br>一座不朽的纪念碑，<br>见证我的成长。</p>
<h2 id="第十七页"><a href="#第十七页" class="headerlink" title="第十七页"></a>第十七页</h2><p>书籍林立，我不知道该从哪里开始。<br>读书是我的旅程，寻找真正的书。<br>这本书具有魔力，捕捉我的记忆。<br>我不想被暴露，我离开这个地方。<br>我开始新的旅程，寻找属于我的书。</p>
<h2 id="第十八页"><a href="#第十八页" class="headerlink" title="第十八页"></a>第十八页</h2><p>书籍、旅程、寻找、不同的地方。</p>
<h2 id="第十九页"><a href="#第十九页" class="headerlink" title="第十九页"></a>第十九页</h2><p>A: 我来到了一个不同的地方，发现书籍在这里林立。<br>B: 你打算从哪本书开始？<br>A: 我不知道，我只知道我必须读下去。<br>B: 读书会让你变得更好。<br>A: 是的，我相信阅读会对让他们不能轻易地捕捉我的记忆。<br>B: 不要忘了，在你的旅程中，不断寻找新的书籍。<br>A: 是的，我会不断寻找，直到找到真正摆脱了他们。</p>
<h2 id="第二十页"><a href="#第二十页" class="headerlink" title="第二十页"></a>第二十页</h2><p>你甩开虚拟之火，大声疾呼：<br>是谁给予了“虚拟之火”自称火的勇气？<br>焚书的火只是北极的万年冰。<br>将书浸泡、包裹、熄灭。<br>书才是真正的火，跃动着生之激情的火，<br>在书架中、引文里、声带上、<br>或是阅读者的心间，长久地燃烧着。<br>是的，典雅的诗行终将变得古拗难识，<br>而不朽的铭文总似风海间的泡沫。<br>但是书还是燃烧着、燃烧着、<br>那每一个小小的铅字都是一簇烛火。<br>直到遗忘最终把丧钟敲响，<br>那时间烧成的灰烬，仍可以骄傲的说：<br>我曾经照亮过世界！</p>
<h2 id="第二十一页"><a href="#第二十一页" class="headerlink" title="第二十一页"></a>第二十一页</h2><p>因此，烧掉这本书吧。<br>让这本书，以及你将读到的每一本书，在你的心中燃烧。</p>
<p>再见了，在火焰中腾越而起的铅字的灵。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Ref-Nerf Implement And Speeding Up w/ instant-ngp</title>
    <url>/2022/11/22/Ref-Nerf-Implement/</url>
    <content><![CDATA[<p>好耶，复活了。时隔一年，我学会了不少新东西呢。比如，如何使用 instant-ngp 给 RefNerf 加速。</p>
<span id="more"></span>
<h2 id="Ref-Nerf-Implement-And-Speeding-Up-w-instant-ngp"><a href="#Ref-Nerf-Implement-And-Speeding-Up-w-instant-ngp" class="headerlink" title="Ref-Nerf Implement And Speeding Up w/ instant-ngp"></a>Ref-Nerf Implement And Speeding Up w/ instant-ngp</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CV ，炼丹界的内卷之王。 NeRF ，可谓是 CV 界的内卷之王。在今年的 CVPR 上，<a href="https://dorverbin.github.io/refnerf/">Ref NeRF</a> 作为 Best Student Paper Honorable Mention 横空出世，它基于 mip-NeRF 框架对反射现象进行了建模，在 NeRF 的基础上增加了 opacity, roughness, tint, normal 的估计。本文将会首先介绍一下 Ref NeRF 论文本身，然后简单聊聊复现思路以及使用 instant-ngp 加速的过程。不过目前，Ref NeRF 的复现结果还没有达到令我满意的程度，只是具备雏形，毕竟融合两篇文章的 idea 可能导致冲突，深度学习这种玄学就更是这样了，模型炸了都不知道从哪一个先开始。</p>
<h3 id="Ref-NeRF-论文简析"><a href="#Ref-NeRF-论文简析" class="headerlink" title="Ref-NeRF 论文简析"></a>Ref-NeRF 论文简析</h3><h4 id="反射建模"><a href="#反射建模" class="headerlink" title="反射建模"></a>反射建模</h4><p>Ref-NeRF 的一大亮点就在于它对于反射的建模，根据 Phong 模型，被观察到的光线为：</p>
<script type="math/tex; mode=display">
I_o=k_aI_a+\sum_ik_d(l_i\cdot n)I_i+\sum_ik_s(r_i\cdot v)^pI_i</script><p>其中，下标为 a 的部分与环境光（ambient light）有关；下标含有 d 则与漫反射有关，而下标含有 s 则与镜面高光有关。为了更好地解释 Ref NeRF 的反射模型处理以及回顾一下 Phong 模型这个基础模型，这里对模型简单解释：</p>
<ul>
<li>第一项代表环境光对观察结果的影响：环境光只对结果产生常数 offset</li>
<li>第二项代表了所有光源在物体上产生的漫反射。漫反射与观察方向无关，只要能观察到，就是 “恒定” 的。光源 i ($l_i$ 为其发射的某一光线的方向）发射光越是能垂直表面（与法向平行），漫反射越强。</li>
<li>第三项代表了镜面高光：不一定是完全的镜面反射（所以称之为镜面高光），可以稍显模糊，但是其强度是与视角有关的。$r_i$ 代表了反射光线的方向，$v$ 则代表了观察方向。两者重合（点乘结果接近 1）时，反射较强。指数 p 用于加强衰减，可知 p 越大，$(r_i\cdot v)^p$ 变化越快。也即视线与反射方向重合发生变化时，镜面高光的变化越明显。</li>
</ul>
<p>而我们的 Ref-NeRF 对后面两部分进行了建模：</p>
<script type="math/tex; mode=display">
L_{out}(\hat{\omega_o})\propto\int L_{in}(\hat{\omega_i})f(\hat{\omega_i},\hat{\omega_r})\mathrm d\hat{\omega_i}</script><p>其中，$L_{in}$ 为入射光，$L_{out}$ 为出射光，$f$ 为 BRDF（Bidirectional Reflectance Distribution Function）。很明显，这就是一个关于 $\omega_r$ 的函数，而这个 BRDF 我们试图通过神经网络直接学习出来。不过这也让我有些思考，如果把 Phong 模型换成 Blinn-Phong 模型会不会有所加速？毕竟 Blinn-Phong 模型不需要计算反射方向，而只需要通过平行四边形定理得到观察方向和入射方向的 “法线” 即可。</p>
<h4 id="directional-MLP-的修改"><a href="#directional-MLP-的修改" class="headerlink" title="directional MLP 的修改"></a>directional MLP 的修改</h4><p>在这里作者进行了一个类似于 mip NeRF 光锥采样的操作。在 mip NeRF 中，我们为了达到 mipmap 那样的感觉，进行了个一个光锥上的采样。而在 Ref NeRF 中，作者也认为 “反射” 也不能仅仅考虑单个反射方向。由于物体实际是凹凸不平的，并非完美的镜面，表面法向量并非完全一致。可以认为，物体表面的凹凸起伏（噪声），使得反射发生了一些改变（distortion），物体表面噪声的概率分布，经过反射的数学操作后被映射成了新的分布。</p>
<p>作者在这里使用了一个被称为 vMF 的概率分布，看上去就和高斯分布差不多，甚至有个别称叫做 normalized spherical gaussian 。个人推测作者选这个函数是为了方便进行后续的数学推导以及近似，就 像 mip NeRF 中，将光锥用混合高斯模型进行近似一样。有了此分布，自然需要使用积分将所有可能的反射方向考虑进去。在这里，作者使用了球谐函数进行方向编码，然后对其进行积分。</p>
<script type="math/tex; mode=display">
E_{\hat\omega\sim vMF(\hat\omega_r,\kappa)}\left[Y^m_l(\hat\omega)\right]=\exp(\frac{-l(l+1)}{2\kappa})Y^m_l(\hat\omega)</script><p>其中，$Y^m_l$ 为球谐函数，$\kappa$ 为 vMF 分布的参数，等于粗糙度的倒数。这里的 $l$ 代表了球谐函数的阶数，$l$ 越大，球谐函数的分布越均匀，而 $l$ 越小，球谐函数的分布越集中。$\kappa$ 越小，对于高阶（频）球谐影响越大。这也就反映了这样一个事实：光滑程度减小，高低频信息均有所衰减，但高频信息衰减更严重。</p>
<p>这里作者还给 directional MLP 喂了 $l_i\cdot n$ ，当然不是要建模漫反射，而是考虑到一些稍微复杂一些的效应，如菲涅尔效应（并非全反射，部分反射部分折射，反射所占的比例需要另外计算）等等。</p>
<h4 id="Normal-估计"><a href="#Normal-估计" class="headerlink" title="Normal 估计"></a>Normal 估计</h4><p>作者有言：</p>
<blockquote>
<p>normal vectors estimated from its volume density gradient as in Equation (上面那个) are often extremely noisy</p>
<p>NeRF tends to “fake” specular highlights by embedding emitters inside the object and partially occluding them with a “foggy” diffuse surface</p>
</blockquote>
<p>为此，作者设计了两个正则项，</p>
<ul>
<li>针对第一个问题，作者通过 spatial MLP 预测法向量 $\hat n$ ，将其和梯度法向量 $n^\prime$ 求一个 MSE。</li>
</ul>
<script type="math/tex; mode=display">
L_n=\sum_i\omega_i||{\hat n_i-n_i^\prime}||^2</script><p>由于 $\hat n$ 比较光滑，而 $n^\prime$ 是通过梯度求一阶导数求出来的，不是很光滑，所以我们可以通过光滑的数据给不光滑的梯度学一学，让它更加光滑。至于为何，小编也不知道（bushi），我认为大概是网络比较菜，所以只能学习低频部分，所以比较光滑。</p>
<ul>
<li>针对第二个问题，作者设计了一个正则项，用于惩罚反向的法向量。</li>
</ul>
<script type="math/tex; mode=display">
R_o=\sum_i\omega_i\max\left(0, \hat n_i\cdot\hat{\mathrm d}\right)^2</script><p>其实就是惩罚法向量和光线方向相同的部分，而且和 weight 有关。这就说明：被遮挡的有效背面不会被影响（weight 低），而 fake surface（在半透明 surface 后的 embedded emitter 表面）将会被惩罚（其 density 衰减方向与光线方向一致）。</p>
<p>然后作者说，把这两个正则项放在一起就可以得到一个比较好的效果。</p>
<ul>
<li>对于 $\hat n$ 和 $n^\prime$ 相差较大时，前者可以让网络使得两者相等，从而平滑梯度。</li>
<li>对于两者相差不大时，第二个正则项可以达到惩罚的目的得到更加合理的法向量。</li>
</ul>
<h3 id="复现中的细节"><a href="#复现中的细节" class="headerlink" title="复现中的细节"></a>复现中的细节</h3><h4 id="proposal-network"><a href="#proposal-network" class="headerlink" title="proposal network"></a>proposal network</h4><p>这里我们使用了 proposal network distillation ，而没有选择 stratified sampling 。stratified sampling非常慢（由于coarse network需要forward所有点，fine network也要forward），proposal network则是用浅MLP（5层），forward点后直接输出预测的density，再利用fine network输出的density（weight）进行监督。这样就能完成从fine network到proposal network的蒸馏。</p>
<p>但是雀氏也有一些问题，</p>
<img src="/2022/11/22/Ref-Nerf-Implement/noisy_balls.png" class="" title="why it is so noisy?">
<p>如图，这个球上有很多的噪点，怎么辉石呢？我们推断这是 density 有一些问题，于是进行了一些改动。</p>
<p>​原始prop net输入coarse points之后，输出density，此后coarse points将会被弃用。根据density计算的weight，将指导inverse sampling，fine network的输入只为inverse sampling的结果（也就是说，集中在weight高的地方）。假设，prop net计算的density有缺陷，也即weight有缺陷，在实际的表面附近weight很小，在空域中weight大，那么inverse sampling可能无法在此条光线上采到有效的点。</p>
<p>很简单，就是复用coarse points，将coarse depths（采样的长度）与inverse sampling的采样长度（fine depths）进行拼接，排序。但其实在实现中，要考虑proposal network的weight bound计算。啊，这一步很复杂。可以这么说：</p>
<ul>
<li>proposal network需要预测每一个采样点（fine采样点）的weight上界（weight bound）。上界如何计算？两个fine采样点之间会存在一个采样区间，此区间将会与coarse采样的区间重合，则此fine采样区间的weight上界应该是所有与之有交集的coarse区间weight之和。</li>
<li>coarse points合并到fine points相当于修改了fine采样区间。那么就需要计算更多区间交集。</li>
</ul>
<p>​这样修改，也就使得每条光线上，既有均匀采样的部分（保证了coverage），又使得density大的部分可以有更多采样点。可能有人觉得，不就是增加了一些采样点吗？这样为什么能保证proposal network的学习是正确的呢？很简单，网络不仅有更加充足的输入，fine network提供给proposal network的监督也更加充足了。</p>
<h4 id="instant-ngp"><a href="#instant-ngp" class="headerlink" title="instant ngp"></a>instant ngp</h4><p><a href="https://nvlabs.github.io/instant-ngp/">instant ngp</a> ，一种使用哈希编码用于加速神经网络训练的方法。简单来说，就是通过一个多分辨率的哈希映射到一个向量中，然后再进行插值得到一个训练出来的编码值。</p>

<p>虽然这个东西看上去很好很fancy，但是会有哈希碰撞的问题，作者说这玩意儿可以通过神经网络来学习减少问题，不过我们觉得不行，这会让我们训练出来的玩意儿非常的“粉”。</p>
<img src="/2022/11/22/Ref-Nerf-Implement/collision.png" class="" title="instant ngp collision">
<p>这个就很难受了，两个相距很远的点获得了类似的性质，导致一些没有意义的点也被赋予了奇怪的颜色，有意义的点也变得有很多空洞。为此我们尝试了增大哈希表的大小，但是这样就炸显存了，非常神秘。所以目前正在着手于实现一种更好的采样方法，这样或许可以减少冲突的问题。</p>
]]></content>
      <tags>
        <tag>灵感</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理Assignment5</title>
    <url>/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/</url>
    <content><![CDATA[<p>第五次图像信息处理作业，大致上就是图像的模糊和锐化吧。</p>
<span id="more"></span>
<h2 id="Assignment-5作业要求"><a href="#Assignment-5作业要求" class="headerlink" title="Assignment-5作业要求"></a>Assignment-5作业要求</h2><ul>
<li>Image mean filtering</li>
<li>Laplacian image enhancement</li>
</ul>
<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>其实由上次作业可以知道，图像的处理就是由一系列矩阵变换得到的结果，不过在这次作业中，我们选择的是对像素进行矩阵变换而不是像素坐标，而均值滤波，顾名思义，就是对图像像素取均值得到新的像素值，以$3\times3$矩阵为例，其变换矩阵如下</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix}\frac19 & \frac19 & \frac19 \\ \frac19 & \frac19 & \frac19 \\ \frac19 & \frac19 & \frac19 \\\end{bmatrix}</script><p>值得注意的是，对于边缘的像素值，我们在这里对其进行保留处理。由此我们可以很快的写出代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgMean</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* meanData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytes * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == height - <span class="number">1</span> || j == <span class="number">0</span> || j == width - <span class="number">1</span>) &#123;</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> r = *(imgData + i * lineBytes + j * <span class="number">3</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) +</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) +</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> g = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) +</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) +</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> b = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) +</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) +</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span>) = (<span class="keyword">uint8_t</span>)(r / <span class="number">9</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = (<span class="keyword">uint8_t</span>)(g / <span class="number">9</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = (<span class="keyword">uint8_t</span>)(b / <span class="number">9</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> meanData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果对比</p>
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/kagami.bmp" class="" title="This is the origin image">
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/mean_filter.bmp" class="" title="This is the filtered image">
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/a.jpg" class="">
<p>当然我们也可以修改均值滤波的矩阵，例如改成如下</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix}\frac1{16} & \frac18 & \frac1{16} \\ \frac18 & \frac14 & \frac18 \\ \frac1{16} & \frac18 & \frac1{16}\end{bmatrix}</script><p>那么这样图像的亮度也会有些许变化</p>
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/mean_filter1.bmp" class="" title="This is the filtered image">
<h3 id="拉普拉斯图像增强"><a href="#拉普拉斯图像增强" class="headerlink" title="拉普拉斯图像增强"></a>拉普拉斯图像增强</h3><p>这里我们使用拉普拉斯算子进行图像的增强，其中我们需要先计算出拉普拉斯遮罩</p>
<script type="math/tex; mode=display">
\nabla^2 f=\begin{bmatrix}1 & 1 & 1 \\ 1 & -8 & 1 \\ 1 & 1 & 1\end{bmatrix}</script><p>然后我们将原像素减去拉普拉斯遮罩即可得出锐化之后的图像，当然这里需要注意增强后的图像溢色的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgLaplacian</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* lapData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytes * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == height - <span class="number">1</span> || j == <span class="number">0</span> || j == width - <span class="number">1</span>) &#123;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> r = <span class="number">8</span> * *(imgData + i * lineBytes + j * <span class="number">3</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) -</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) -</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> g = <span class="number">8</span> * *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) -</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) -</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> b = <span class="number">8</span> * *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) -</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) -</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">                r += *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">                g += *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                b += *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">                r = r &gt; <span class="number">255</span> ? <span class="number">255</span> : r;</span><br><span class="line">                g = g &gt; <span class="number">255</span> ? <span class="number">255</span> : g;</span><br><span class="line">                b = b &gt; <span class="number">255</span> ? <span class="number">255</span> : b;</span><br><span class="line">                r = r &lt; <span class="number">0</span> ? <span class="number">0</span> : r;</span><br><span class="line">                g = g &lt; <span class="number">0</span> ? <span class="number">0</span> : g;</span><br><span class="line">                b = b &lt; <span class="number">0</span> ? <span class="number">0</span> : b;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span>) = r;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lapData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果如下</p>
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/laplacian_filter.bmp" class="" title="This is the laplaced image">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次作业确实还蛮简单的，最后总计的编程时间可能一个小时都不到，不过这些矩阵运算还是十分重要的</p>
<p>同时长远地想，配合别的不同的滤波器可以实现其他不同的效果，可以算是图像滤波的入门体验作业吧</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理作业Assignment4</title>
    <url>/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/</url>
    <content><![CDATA[<p>第四次图像信息处理作业解析，这次是图像仿射变换呢。</p>
<span id="more"></span>
<h2 id="Assignment-4作业要求"><a href="#Assignment-4作业要求" class="headerlink" title="Assignment-4作业要求"></a>Assignment-4作业要求</h2><ul>
<li><p>Translation</p>
</li>
<li><p>Rotation</p>
</li>
<li><p>Scale</p>
</li>
<li><p>Shear</p>
</li>
<li><p>Mirror</p>
</li>
</ul>
<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="仿射变换简介"><a href="#仿射变换简介" class="headerlink" title="仿射变换简介"></a>仿射变换简介</h3><p>图像上的仿射变换, 其实就是图片中的一个像素点，通过某种变换，移动到另外一个地方</p>
<p>从数学上来讲， 就是一个向量空间进行一次线形变换并加上平移向量， 从而变换到另外一个向量空间的过程</p>
<p>向量空间$\vec{m}$:</p>
<script type="math/tex; mode=display">
\vec{m}=(x,y)</script><p>向量空间$\vec{n}$ :</p>
<script type="math/tex; mode=display">
\vec{n}=(x′,y′)</script><p>向量空间从$\vec{m}$到$\vec{n}$的变换 $\vec{n}=A\vec{m}+\vec{b}$<br>整理得到:</p>
<script type="math/tex; mode=display">
x′=A_{00}∗x+A_{01}∗y+b_{0} \\
y′=A_{10}∗x+A_{11}∗y+b_{1}</script><p>将A跟b 组合在一起就组成了仿射矩阵 $M$。 它的维度是$2∗3$</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} A_{00} & A_{01} & b_{0} \\A_{10} & A_{11} & b_{1}\end{bmatrix}</script><p>使用不同的矩阵$M$就获得了不同的2D仿射变换效果。</p>
<h3 id="图像平移"><a href="#图像平移" class="headerlink" title="图像平移"></a>图像平移</h3><p>可以说是最简单的空间变换，其矩阵$M$为</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} 1 & 0 & b_{0} \\0 & 1 & b_{1} \\ 0 & 0 & 1\end{bmatrix}</script><p>因此，我们可以很快地写出代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgTranslation</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">int</span> x0, <span class="keyword">int</span> y0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytesOriginal = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> lineBytesTranslated = (bitCount * (width + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(x0)) / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* transData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesTranslated * (height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0))]&#123;&#125;;</span><br><span class="line">    y0 = y0 &gt; <span class="number">0</span> ? y0 : <span class="number">0</span>;</span><br><span class="line">    x0 = x0 &gt; <span class="number">0</span> ? x0 : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width * <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">            *(transData + (i + y0) * lineBytesTranslated + j - <span class="number">2</span> + x0 * <span class="number">3</span>) = r;</span><br><span class="line">            *(transData + (i + y0) * lineBytesTranslated + j - <span class="number">1</span> + x0 * <span class="number">3</span>) = g;</span><br><span class="line">            *(transData + (i + y0) * lineBytesTranslated + j + x0 * <span class="number">3</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意变化后<code>bmp</code>文件的<code>header</code>也需要同步变换，在这里给出变化后的<code>header</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BITMAPHEADER* Header = <span class="keyword">new</span> BITMAPHEADER;</span><br><span class="line">Header-&gt;bfType = <span class="number">0x4D42</span>;</span><br><span class="line">Header-&gt;bfSize = <span class="number">14</span> + <span class="number">40</span> + lineBytesTranslated * (height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0));</span><br><span class="line">Header-&gt;bfReserved1 = <span class="number">0</span>;</span><br><span class="line">Header-&gt;bfReserved2 = <span class="number">0</span>;</span><br><span class="line">Header-&gt;bfOffBits = <span class="number">14</span> + <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">BITMAPINFOHEADER* InfoHeader = <span class="keyword">new</span> BITMAPINFOHEADER;</span><br><span class="line">InfoHeader-&gt;biBitCount = <span class="number">24</span>;</span><br><span class="line">InfoHeader-&gt;biClrImportant = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biClrUsed = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biCompression = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biHeight = height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0);</span><br><span class="line">InfoHeader-&gt;biWidth = width + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(x0);</span><br><span class="line">InfoHeader-&gt;biPlanes = <span class="number">1</span>;</span><br><span class="line">InfoHeader-&gt;biSize = <span class="number">40</span>;</span><br><span class="line">InfoHeader-&gt;biSizeImage = lineBytesTranslated * (height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0));</span><br><span class="line">InfoHeader-&gt;biXPelsPerMeter = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biYPelsPerMeter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>向右上平移100像素的效果如图</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/translation.bmp" class="" title="This is the translated image">
<h3 id="图像旋转"><a href="#图像旋转" class="headerlink" title="图像旋转"></a>图像旋转</h3><p>通过数学推导，我们可以发现，旋转的矩阵$M$如下</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} \cos(\theta) & -\sin(\theta) & 0 \\ \sin(\theta) & \cos(\theta) & 0 \\ 0 & 0 & 1\end{bmatrix}</script><p>这里的$\theta$就是旋转的角度，但是很明显这里是以$(0, 0)$为基础进行的旋转，因此我们需要将我们想要的中心点平移至$(0,0)$再平移回来，即</p>
<script type="math/tex; mode=display">
\begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} = M_{translation}^{-1}(M_{rotation}(M_{translation} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}))</script><p>其中</p>
<script type="math/tex; mode=display">
M_{translation}=\begin{bmatrix} 1 & 0 & -c_x \\ 0 & 1 & -c_y \\ 0 & 0 & 1\end{bmatrix} \\
M_{rotation}=\begin{bmatrix} \cos(\theta) & -\sin(\theta) & 0 \\ \sin(\theta) & \cos(\theta) & 0 \\ 0 & 0 & 1\end{bmatrix}</script><p>因此，我们可以推导出$M$有</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} \cos(\theta) & -\sin(\theta) & (1-\cos(\theta))*c_x+\sin(\theta)*c_y \\ \sin(\theta) & \cos(\theta) & -\sin(\theta)*c_x+(1-\cos(\theta))*c_y \\ 0 & 0 & 1\end{bmatrix}</script><p>在代码实现部分，我们需要先确定四个角上的像素坐标，然后再将其规化全为正</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> radian = theta * PI / <span class="number">180.0</span>;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">4</span>], y[<span class="number">4</span>], cx = *width / <span class="number">2</span>, cy = *height / <span class="number">2</span>, xMax = <span class="number">0</span>, xMin = <span class="number">0</span>, yMax = <span class="number">0</span>, yMin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; *height + <span class="number">1</span>; i += *height) &#123;                           <span class="comment">//计算四个顶点的xy值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; *width + <span class="number">1</span>; j += *width) &#123;</span><br><span class="line">        x[i / *width + j / *height] = j * <span class="built_in">cos</span>(radian) - i * <span class="built_in">sin</span>(radian) + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cx + <span class="built_in">sin</span>(radian) * cy;</span><br><span class="line">        xMax = xMax &gt; x[i / *width + j / *height] ? xMax : x[i / *width + j / *height];</span><br><span class="line">        xMin = xMin &gt; x[i / *width + j / *height] ? x[i / *width + j / *height] : xMin;</span><br><span class="line">        y[i / *width + j / *height] = j * <span class="built_in">sin</span>(radian) + i * <span class="built_in">cos</span>(radian) - <span class="built_in">sin</span>(radian) * cx + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cy;</span><br><span class="line">        yMax = yMax &gt; y[i / *width + j / *height] ? yMax : y[i / *width + j / *height];</span><br><span class="line">        yMin = yMin &gt; y[i / *width + j / *height] ? y[i / *width + j / *height] : yMin;        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以以此来创建新的宽高的图像，然后根据矩阵一一对应</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newHeight = yMax - yMin, newWidth = xMax - xMin;                      <span class="comment">//得到新尺寸</span></span><br><span class="line"><span class="keyword">int</span> lineBytesRotated = (bitCount * newWidth / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> lineBytesOriginal = (bitCount * *width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">uint8_t</span>* rotaData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesRotated * newHeight]&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; *height; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; *width * <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">        <span class="keyword">int</span> x = j / <span class="number">3</span> * <span class="built_in">cos</span>(radian) - i * <span class="built_in">sin</span>(radian) + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cx + <span class="built_in">sin</span>(radian) * cy - xMin;</span><br><span class="line">        <span class="keyword">int</span> y = j / <span class="number">3</span> * <span class="built_in">sin</span>(radian) + i * <span class="built_in">cos</span>(radian) - <span class="built_in">sin</span>(radian) * cx + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cy - yMin;</span><br><span class="line">        *(rotaData + y * lineBytesRotated + x * <span class="number">3</span>) = r;</span><br><span class="line">        *(rotaData + y * lineBytesRotated + x * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">        *(rotaData + y * lineBytesRotated + x * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*height = newHeight;</span><br><span class="line">*width = newWidth;</span><br><span class="line"><span class="keyword">return</span> rotaData;</span><br></pre></td></tr></table></figure>
<p>逆时针旋转45度后效果如图</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/rotation.bmp" class="" title="This is the rotated image">
<p>可以看到图片上有很多黑点，这是因为像素旋转过程中我们舍弃了部分精度导致的，因此我们需要进一步进行插值算法，而插值的方法有很多，我们在这里选择双线性插值</p>
<h3 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h3><p>双线性插值利用旋转后图像中的点在原图所对应点周围四个点的数值，在两个方向分别进行线性插值来得到</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/bilinear.png" class="">
<p>记这四个点分别为$Q_{ij}(i,j=1,2)$，先对x轴方向做两次线性插值得到函数在$R_1$和$R_2$上的值，再对$R_1$和$R_2$做$y$轴方向的线性插值得到函数在所求点的值</p>
<script type="math/tex; mode=display">
f(P)=\frac{(y_2-y)(x_2-x)}{(y_2-y_1)(x_2-x_1)}f(Q_{11})+\frac{(y_2-y)(x-x_1)}{(y_2-y_1)(x_2-x_1)}f(Q_{21})+\frac{(y-y_1)(x_2-x)}{(y_2-y_1)(x_2-x_1)}f(Q_{12})+\frac{(y-y_1)(x-x_1)}{(y_2-y_1)(x_2-x_1)}f(Q_{22})</script><p>而对于旋转的图像，我们先对其变换矩阵$M$求逆运算，其实旋转矩阵的逆即是旋转矩阵的转置，因此</p>
<script type="math/tex; mode=display">
M^{-1}=\begin{bmatrix}\cos(\theta) & \sin(\theta) & (1-\cos(\theta))*c_x-\sin(\theta)*c_y \\ -\sin(\theta) & \cos(\theta) & \sin(\theta)*c_x+(1-\cos(\theta))*c_y \\ 0 & 0 & 1\end{bmatrix}</script><p>由此我们可以开始插值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newHeight; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newWidth; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(rotaData + i * lineBytesRotated + j * <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = j + xMin, y = i + yMin;</span><br><span class="line">            <span class="keyword">double</span> ox = x * <span class="built_in">cos</span>(radian) + y * <span class="built_in">sin</span>(radian) + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cx - <span class="built_in">sin</span>(radian) * cy;</span><br><span class="line">            <span class="keyword">double</span> oy = x * -<span class="built_in">sin</span>(radian) + y * <span class="built_in">cos</span>(radian) + <span class="built_in">sin</span>(radian) * cx + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cy;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">floor</span>(ox) &gt;=<span class="number">0.0</span> &amp;&amp; <span class="built_in">floor</span>(oy) &gt;=<span class="number">0.0</span> &amp;&amp; <span class="built_in">ceil</span>(ox) &lt; *width &amp;&amp; <span class="built_in">ceil</span>(oy) &lt; *height) &#123;</span><br><span class="line">                <span class="keyword">int</span> x[<span class="number">2</span>], y[<span class="number">2</span>];</span><br><span class="line">                x[<span class="number">0</span>] = <span class="built_in">floor</span>(ox); x[<span class="number">1</span>] = <span class="built_in">ceil</span>(ox);</span><br><span class="line">                y[<span class="number">0</span>] = <span class="built_in">floor</span>(oy); y[<span class="number">1</span>] = <span class="built_in">ceil</span>(oy);</span><br><span class="line">                <span class="keyword">uint8_t</span> r = (y[<span class="number">1</span>] - oy) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal) + </span><br><span class="line">                            (y[<span class="number">1</span>] - oy) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal);</span><br><span class="line">                <span class="keyword">uint8_t</span> g = (y[<span class="number">1</span>] - oy) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">1</span>) + </span><br><span class="line">                            (y[<span class="number">1</span>] - oy) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">uint8_t</span> b = (y[<span class="number">1</span>] - oy) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">2</span>) + </span><br><span class="line">                            (y[<span class="number">1</span>] - oy) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                *(rotaData + i * lineBytesRotated + j * <span class="number">3</span>) = r;</span><br><span class="line">                *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">                *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终效果如图</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/rotation1.bmp" class="" title="This is the rotated image">
<h3 id="图像放缩"><a href="#图像放缩" class="headerlink" title="图像放缩"></a>图像放缩</h3><p>很明显，这里需要用到上文提到的双线性插值算法，我们在这里换一种写法，相信聪明的你一眼就看出来这两种写法是一样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgScale</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">double</span> ratioA, <span class="keyword">double</span> ratioB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newHeight = <span class="built_in">floor</span>(height * ratioA);</span><br><span class="line">    <span class="keyword">int</span> newWidth = <span class="built_in">floor</span>(width * ratioB);</span><br><span class="line">    <span class="keyword">int</span> lineBytesScaled = (bitCount * newWidth / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> lineBytesOriginal = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* scaleData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesScaled * newHeight];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newHeight; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newWidth; j++) &#123;</span><br><span class="line">            <span class="keyword">double</span> y = i / ratioA;</span><br><span class="line">            <span class="keyword">double</span> x = j / ratioB;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; height - <span class="number">1</span>) y = height - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; width - <span class="number">1</span>) x = width - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> x1 = <span class="built_in">ceil</span>(x), y1 = <span class="built_in">ceil</span>(y), x2 = <span class="built_in">ceil</span>(x) + <span class="number">1</span>, y2 = <span class="built_in">ceil</span>(y) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt; width - <span class="number">1</span>)</span><br><span class="line">                x2 -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (y2 &gt; height - <span class="number">1</span>)</span><br><span class="line">                y2 -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">double</span> u = x + <span class="number">1</span> - x1;</span><br><span class="line">            <span class="keyword">double</span> v = y + <span class="number">1</span> - y1;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = (<span class="number">1</span> - u) * (<span class="number">1</span> - v) * *(imgData + x1 * <span class="number">3</span> + y1 * lineBytesOriginal) +</span><br><span class="line">                        (<span class="number">1</span> - u) * v * *(imgData + x1 * <span class="number">3</span> + y2 * lineBytesOriginal) +</span><br><span class="line">                        u * (<span class="number">1</span> - v) * *(imgData + x2 * <span class="number">3</span> + y1 * lineBytesOriginal) + </span><br><span class="line">                        u * v * *(imgData + x2 * <span class="number">3</span> + y2 * lineBytesOriginal);</span><br><span class="line">            <span class="keyword">uint8_t</span> g = (<span class="number">1</span> - u) * (<span class="number">1</span> - v) * *(imgData + x1 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                        (<span class="number">1</span> - u) * v * *(imgData + x1 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                        u * (<span class="number">1</span> - v) * *(imgData + x2 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">1</span>) + </span><br><span class="line">                        u * v * *(imgData + x2 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> b = (<span class="number">1</span> - u) * (<span class="number">1</span> - v) * *(imgData + x1 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                        (<span class="number">1</span> - u) * v * *(imgData + x1 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                        u * (<span class="number">1</span> - v) * *(imgData + x2 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">2</span>) + </span><br><span class="line">                        u * v * *(imgData + x2 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">2</span>);</span><br><span class="line">            *(scaleData + i * lineBytesScaled + j * <span class="number">3</span>) = r;</span><br><span class="line">            *(scaleData + i * lineBytesScaled + j * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">            *(scaleData + i * lineBytesScaled + j * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scaleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终横向拉伸一倍效果如下</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/scale.bmp" class="" title="This is the scaled image">
<h3 id="图像错切"><a href="#图像错切" class="headerlink" title="图像错切"></a>图像错切</h3><p>错切的本质是一种线性变换，可以算是学线性代数的时候的矩阵乘法启蒙变换了吧</p>
<p>对于水平错切，我们有矩阵$M$</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} 1 & m \\ 0 & 1 \end{bmatrix}</script><p>其中$m=\tan(\phi)$，也就是说我们将平面上的直线$y=b$错切成了$y=\frac{1}{m}x+b$</p>
<p>很明显，既然有水平错切那就自然有垂直错切，两者在代码上有众多相似之处，因此我们就在这里只实现水平错切</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgShear</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">double</span> ratio)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newWidth = <span class="built_in">floor</span>(height * <span class="built_in">fabs</span>(ratio)) + width;</span><br><span class="line">    <span class="keyword">int</span> lineBytesSheared = (bitCount * newWidth / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> lineBytesOriginal = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* shearData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesSheared * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ratio &lt; <span class="number">0</span>) offset = ratio * height;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = i;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">floor</span>(y * ratio) + j - offset;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytesOriginal + j * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytesOriginal + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytesOriginal + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            *(shearData + y * lineBytesSheared + x * <span class="number">3</span>) = r;</span><br><span class="line">            *(shearData + y * lineBytesSheared + x * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">            *(shearData + y * lineBytesSheared + x * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shearData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果比率小于零，那么我们就需要定义一个偏移量<code>offset</code>进行原点偏移，最终结果如下</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/shear.bmp" class="" title="This is the sheared image">
<h3 id="图像镜像"><a href="#图像镜像" class="headerlink" title="图像镜像"></a>图像镜像</h3><p>蛮简单的，没啥好说的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgMirror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* mirrorData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytes * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y,x;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                y = i;</span><br><span class="line">                x = width - j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                y = height - i - <span class="number">1</span>;</span><br><span class="line">                x = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            *(mirrorData + y * lineBytes + x * <span class="number">3</span>) = r;</span><br><span class="line">            *(mirrorData + y * lineBytes + x * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">            *(mirrorData + y * lineBytes + x * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mirrorData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/mirror.bmp" class="" title="This is the mirrored image">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然看上去这次作业也不算特别难，但是在编写代码的过程中我还是遇到了许多奇妙的问题，比如一些公式的笔误导致最终输出的图像根本不能看</p>
<p>而且有的时候图像的分辨率如果恰好是一个奇妙的数值，那么最后输出的图像就有可能会损坏，因此请随意使用本博客里的图像，它的鲁棒性十分的好</p>
<p>总之就是需要胆大心细地按部就班地编写程序，最终就一定会出现自己预想中的图像</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理作业Assignment3</title>
    <url>/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/</url>
    <content><![CDATA[<p>第三次图像信息处理作业解析，这次要对直方图动手了。</p>
<span id="more"></span>
<h2 id="Assignment-3作业要求"><a href="#Assignment-3作业要求" class="headerlink" title="Assignment-3作业要求"></a>Assignment-3作业要求</h2><ul>
<li>Image logarithmic operation for visibility enhancement</li>
<li>Histogram equalization<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="图像对数强化"><a href="#图像对数强化" class="headerlink" title="图像对数强化"></a>图像对数强化</h3></li>
</ul>
<p>这玩意儿老师上课貌似没讲，检索了一下大概就是通过如下的公式进行操作</p>
<script type="math/tex; mode=display">
S=c\times\log(1+r) \\
where,\qquad\qquad\qquad\\ S=\text{output pixel value} \\
C=\text{scaling constant} \\
R=\text{input pixel value}\\</script><p>在这里，我们定义如下的常数$C$</p>
<script type="math/tex; mode=display">
C=\frac{255}{\log(1+\text{max input pixel value})}</script><p>通过加一我们可以保证所有的$C$和$S$是非负数</p>
<p>首先先求出$C$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* max;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> data = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j);</span><br><span class="line">        max = max &gt; data ? max : data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> c = <span class="number">255.0</span> / (<span class="built_in">log</span>(<span class="number">1</span> + max));</span><br></pre></td></tr></table></figure>
<p>然后代入公式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* logData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height / <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> r = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j)</span><br><span class="line">        *(logData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = c * <span class="built_in">log</span>(<span class="number">1</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就获得了log后的图像</p>
<img src="/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/gray.bmp" class="" title="This is the gray image">
<img src="/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/log.bmp" class="" title="This is the log image">
<h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>考虑一个离散的灰度图像$x$，让$n_i$ 表示灰度$i$出现的次数，这样图像中灰度为$i$的像素的出现概率是</p>
<script type="math/tex; mode=display">
\ p_x(i) = p(x=i) = \frac{n_i}{n},\quad 0 \le i < L</script><p>$L$ 是图像中所有的灰度数（通常为256），$n$ 是图像中所有的像素数，$p_x(i)$实际上是像素值为$i$的图像的直方图，归一化到 [0,1]。</p>
<p>把对应于$p_x$的累积分布函数，定义为：</p>
<script type="math/tex; mode=display">
\ cdf_x(i) = \sum_{j=0}^i p_x(j),</script><p>是图像的累计归一化直方图。</p>
<p>我们创建一个形式为$ y= T(x)$ 的变换，对于原始图像中的每个值它就产生一个$y$，这样 $y$的累计概率函数就可以在所有值范围内进行线性化，转换公式定义为：</p>
<script type="math/tex; mode=display">
\ cdf_y(i) = iK</script><p>对于常数$K$。CDF的性质允许我们做这样的变换（参见逆分布函数）；定义为</p>
<script type="math/tex; mode=display">
\ cdf_y(y^\prime) = cdf_y(T(k)) = cdf_x(k)</script><p>其中$k$属于区间 [0,L)。注意 T 将不同的等级映射到${0..1}$​域，为了将这些值映射回它们最初的域，需要在结果上应用下面的简单变换：</p>
<script type="math/tex; mode=display">
\ y^\prime = y \cdot(\max\{x\} - \min\{x\}) + \min\{x\}</script><p>上面描述了灰度图像上使用直方图均衡化的方法，但是通过将这种方法分别用于图像RGB颜色值的红色、绿色和蓝色分量，从而也可以对彩色图像进行处理。</p>
<p>首先，我们需要先得到直方图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* histData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height / <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> hist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, eqHist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = height * width;</span><br><span class="line"><span class="keyword">double</span> fpHist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, eqHistTemp[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123; <span class="comment">//计算直方图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> GrayIndex = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j);</span><br><span class="line">        hist[GrayIndex]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们计算灰度分布和累计直方图分布</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123; <span class="comment">//计算灰度分布密度</span></span><br><span class="line">    fpHist[i] = (<span class="keyword">double</span>)hist[i] / (<span class="keyword">double</span>)size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123; <span class="comment">//计算累计直方图分布</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        eqHistTemp[i] = fpHist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        eqHistTemp[i] = eqHistTemp[i - <span class="number">1</span>] + fpHist[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以直接得出映射关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//累计分布取整，保存计算出来的灰度映射关系</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    eqHist[i] = (<span class="keyword">int</span>)(<span class="number">255.0</span> * eqHistTemp[i] + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123; <span class="comment">//进行灰度映射均衡化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> GrayIndex = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j);</span><br><span class="line">        *(histData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = eqHist[GrayIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如图</p>
<img src="/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/hist.bmp" class="" title="This is the log image">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说这次作业依然是十分的宁静祥和、简单质朴，不过在直方图均衡化的部分由于不太了解细节，因此借鉴了部分代码，写作风格也十分的奇妙，希望多多包含。</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理Assignment2</title>
    <url>/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<p>浙大的图像信息处理，一门奇妙的课程，老师上课吹水摸鱼，网上的资源也十分不集中。故在此开设专题作为图像信息处理作业的一个分享，请善用博客搜索功能。</p>
<span id="more"></span>
<h2 id="Assignment-2作业要求"><a href="#Assignment-2作业要求" class="headerlink" title="Assignment-2作业要求"></a>Assignment-2作业要求</h2><ul>
<li>Image binarization</li>
<li>Binary image erosion</li>
<li>Binary image dilation</li>
<li>Binary image opening</li>
<li>Binary image closing</li>
</ul>
<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="图像二值化"><a href="#图像二值化" class="headerlink" title="图像二值化"></a>图像二值化</h3><p>读取一张<code>.bmp</code>图像将其转换位二值图像，首先我们需要在C语言中定义图像信息结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> bfType;        <span class="comment">// 19778，必须是BM字符串，对应的十六进制为0x4d42,十进制为19778，否则不是bmp格式文件</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   bfSize;        <span class="comment">// 文件大小 以字节为单位(2-5字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> bfReserved1;   <span class="comment">// 保留，必须设置为0 (6-7字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> bfReserved2;   <span class="comment">// 保留，必须设置为0 (8-9字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   bfOffBits;     <span class="comment">// 从文件头到像素数据的偏移  (10-13字节)</span></span><br><span class="line">&#125; BITMAPHEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biSize;          <span class="comment">// 此结构体的大小 (14-17字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biWidth;         <span class="comment">// 图像的宽  (18-21字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biHeight;        <span class="comment">// 图像的高  (22-25字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  biPlanes;        <span class="comment">// 表示bmp图片的平面属，显然显示器只有一个平面，所以恒等于1 (26-27字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  biBitCount;      <span class="comment">// 一像素所占的位数，一般为24   (28-29字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biCompression;   <span class="comment">// 说明图象数据压缩的类型，0为不压缩。 (30-33字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biSizeImage;     <span class="comment">// 像素数据所占大小, 这个值应该等于上面文件头结构中bfSize-bfOffBits (34-37字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biXPelsPerMeter; <span class="comment">// 说明水平分辨率，用象素/米表示。一般为0 (38-41字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biYPelsPerMeter; <span class="comment">// 说明垂直分辨率，用象素/米表示。一般为0 (42-45字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biClrUsed;       <span class="comment">// 说明位图实际使用的彩色表中的颜色索引数（设为0的话，则说明使用所有调色板项）。 (46-49字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biClrImportant;  <span class="comment">// 说明对图象显示有重要影响的颜色索引的数目，如果是0，表示都重要。(50-53字节)</span></span><br><span class="line">&#125; BITMAPINFOHEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbBlue;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbGreen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbRed;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbReserved;</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure>
<p>然后进行图像头结构的读取与判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* bmpfile = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">BITMAPHEADER* header = <span class="keyword">new</span> BITMAPHEADER;</span><br><span class="line">BITMAPINFOHEADER* info = <span class="keyword">new</span> BITMAPINFOHEADER;</span><br><span class="line"><span class="keyword">if</span> (!bmpfile) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fread</span>(header, <span class="number">14</span>, <span class="number">1</span>, bmpfile);</span><br><span class="line"><span class="keyword">if</span> (header-&gt;bfType != <span class="number">0x4D42</span>) &#123; <span class="comment">//判断是否为bmp图像</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not a bitmap file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fread</span>(info, <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER), <span class="number">1</span>, bmpfile);</span><br></pre></td></tr></table></figure>
<p>赋值计算单行像素数量<code>lineBytes</code>并读取像素信息，注意由于<code>.bmp</code>文件单行像素一定是4的整倍数，因此需要补齐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> imSize = info-&gt;biSize;</span><br><span class="line"><span class="keyword">int</span> width = info-&gt;biWidth;</span><br><span class="line"><span class="keyword">int</span> height = info-&gt;biHeight;</span><br><span class="line"><span class="keyword">int</span> bitCount = info-&gt;biBitCount;</span><br><span class="line"><span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;  <span class="comment">//一行的byte数，四位补齐</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* imgData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line"><span class="built_in">fread</span>(imgData, lineBytes * height, <span class="number">1</span>, bmpfile);</span><br><span class="line"><span class="built_in">fclose</span>(bmpfile);</span><br></pre></td></tr></table></figure>
<p>在读取图像之后计算其灰度值，此时我们用$YUV$格式转换中的$Y$值表示灰度，转换公式如下</p>
<script type="math/tex; mode=display">
Y=0.299*R+0.587*G+0.114*B</script><p>由于$RGB$格式的大小是灰度图像的三倍，因此在创建灰度数据时要除以三再赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* biData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height / <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++)&#123; <span class="comment">//对于每一行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width * <span class="number">3</span>; j++)&#123; <span class="comment">//对于每一列</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> r = *(imgData + lineBytes * (height - <span class="number">1</span> - i) + j); <span class="comment">//从最后一行往上读</span></span><br><span class="line">		j++;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> g = *(imgData + lineBytes * (height - <span class="number">1</span> - i) + j);</span><br><span class="line">		j++;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> b = *(imgData + lineBytes * (height - <span class="number">1</span> - i) + j);</span><br><span class="line">		*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j / <span class="number">3</span>) = <span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">//完成灰度转换</span></span><br></pre></td></tr></table></figure>
<p>然后是二值化图像阈值的确定，根据课上内容我们可以知道，我们需要确定前景和背景然后让其组内方差最小且组间方差最大，这就是所谓<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%B4%A5%E7%AE%97%E6%B3%95"><strong>大津算法</strong></a>，链接中有通过直方图的C语言实现，可以作为补充阅读，我们这里使用与<a href="http://www.opencv.org/">OpenCV</a>相类似的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">otsuThreshold</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* biData, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> lineBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> GrayScale = <span class="number">256</span>; <span class="comment">//256级灰度</span></span><br><span class="line">    <span class="keyword">int</span> pixelCount[GrayScale] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> pixelPro[GrayScale] = &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> threshold = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;  <span class="comment">//统计每个灰度在像素中的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            ++pixelCount[(<span class="keyword">int</span>)*(biData + lineBytes * i + j)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; GrayScale; i++) &#123;  <span class="comment">//计算每个像素所占比例</span></span><br><span class="line">        pixelPro[i] = (<span class="keyword">double</span>)pixelCount[i] / (width * height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> w0, w1, u0tmp, u1tmp, u0, u1, u, deltaTmp, deltaMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; GrayScale; i++) &#123;</span><br><span class="line">        w0 = w1 = u0tmp = u1tmp = u0 = u1 = u = deltaTmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; GrayScale; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= i) &#123;  <span class="comment">//背景</span></span><br><span class="line">                w0 += pixelPro[j];</span><br><span class="line">                u0tmp += j * pixelPro[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">//前景</span></span><br><span class="line">                w1 += pixelPro[j];</span><br><span class="line">                u1tmp += j * pixelPro[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">//计算组间方差</span></span><br><span class="line">        u0 = u0tmp / w0;</span><br><span class="line">        u1 = u1tmp / w1;</span><br><span class="line">        u = u0tmp + u1tmp;</span><br><span class="line">        deltaTmp = w0 * <span class="built_in">pow</span>((u0 - u), <span class="number">2</span>) + w1 * <span class="built_in">pow</span>((u1 - u), <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (deltaTmp &gt; deltaMax) &#123;</span><br><span class="line">            deltaMax = deltaTmp;</span><br><span class="line">            threshold = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确定了阈值后就可以进行二值化了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> threshold = <span class="built_in">otsuThreshold</span>(biData, width, height, lineBytes / <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++)&#123; <span class="comment">//对于每一行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++)&#123; <span class="comment">//对于每一列</span></span><br><span class="line">		<span class="keyword">if</span> (*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) &gt;= threshold)</span><br><span class="line">			*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = <span class="number">255</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  <span class="comment">//完成二值化转换</span></span><br></pre></td></tr></table></figure>
<p>处理完数据后就可以写入二值文件了，首先是定义头文件和颜色表，然后写入数据即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* biBMP = <span class="built_in">fopen</span>(<span class="string">&quot;bi.bmp&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> lineBytesBi = (width * <span class="number">8</span> / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (!biBMP) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">BITMAPHEADER* biHeader = <span class="keyword">new</span> BITMAPHEADER;</span><br><span class="line">biHeader-&gt;bfType = <span class="number">0x4D42</span>;</span><br><span class="line">biHeader-&gt;bfSize = <span class="number">14</span> + <span class="number">40</span> + <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD) * <span class="number">256</span> + lineBytesBi * height;</span><br><span class="line">biHeader-&gt;bfReserved1 = <span class="number">0</span>;</span><br><span class="line">biHeader-&gt;bfReserved2 = <span class="number">0</span>;</span><br><span class="line">biHeader-&gt;bfOffBits = <span class="number">14</span> + <span class="number">40</span> + <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD) * <span class="number">256</span>;</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfType, <span class="number">2</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfSize, <span class="number">4</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved1, <span class="number">2</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved2, <span class="number">2</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfOffBits, <span class="number">4</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"></span><br><span class="line">BITMAPINFOHEADER* biInfoHeader = <span class="keyword">new</span> BITMAPINFOHEADER;</span><br><span class="line">biInfoHeader-&gt;biBitCount = <span class="number">8</span>;</span><br><span class="line">biInfoHeader-&gt;biClrImportant = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biClrUsed = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biCompression = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biHeight = height;</span><br><span class="line">biInfoHeader-&gt;biWidth = width;</span><br><span class="line">biInfoHeader-&gt;biPlanes = <span class="number">1</span>;</span><br><span class="line">biInfoHeader-&gt;biSize = <span class="number">40</span>;</span><br><span class="line">biInfoHeader-&gt;biSizeImage = lineBytesBi * height;</span><br><span class="line">biInfoHeader-&gt;biXPelsPerMeter = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biYPelsPerMeter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">fwrite</span>(biInfoHeader, <span class="number">40</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"></span><br><span class="line">RGBQUAD* pColorTable = <span class="keyword">new</span> RGBQUAD[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    pColorTable[i].rgbRed = i;</span><br><span class="line">    pColorTable[i].rgbGreen = i;</span><br><span class="line">    pColorTable[i].rgbBlue = i; <span class="comment">//是颜色表里的B、G、R分量都相等，且等于索引值</span></span><br><span class="line">    pColorTable[i].rgbReserved = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fwrite</span>(pColorTable, <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD), <span class="number">256</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(biData, lineBytesBi * height, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fclose</span>(biBMP);</span><br></pre></td></tr></table></figure>
<p>最终效果<br><img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/gouldian_finch.bmp" class="" title="This is the original image"><br><img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/bi.bmp" class="" title="This is the binary image"></p>
<h3 id="二值化图像腐蚀"><a href="#二值化图像腐蚀" class="headerlink" title="二值化图像腐蚀"></a>二值化图像腐蚀</h3><p>图像腐蚀，常用于使目标缩小，去除图像边界或者去除不想要的小物体（例如减噪等操作），计算方法为</p>
<script type="math/tex; mode=display">
A\ominus B=\{(x,y)\vert(B)_{xy}\subseteq A\}</script><p>其中$A$是二值化图像，$B$是腐蚀领域</p>
<p>具体操作就是用一个结构元素$B$(一般是3×3的大小)扫描图像$A$中的每一个像素，用结构元素中的每一个像素与其覆盖的像素做“与”操作，如果都为1，则该像素为1，否则为0</p>
<p>我们采用遍历与运算进行实现，此时</p>
<script type="math/tex; mode=display">
B=
\begin{bmatrix}0 & 1 & 0\\ 1 & 1 & 1 \\ 0 & 1 & 0\end{bmatrix}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="title">imgErosion</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* biData, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> lineBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* tempData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* eroData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="built_in">memcpy</span>(tempData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(eroData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(tempData + i * lineBytes + j) == <span class="number">0</span> || *(tempData + (i<span class="number">-1</span>) * lineBytes + j) == <span class="number">0</span> ||</span><br><span class="line">                *(tempData + (i+<span class="number">1</span>) * lineBytes + j) == <span class="number">0</span> || *(tempData + i * lineBytes + j+<span class="number">1</span>) == <span class="number">0</span> ||</span><br><span class="line">                *(tempData + i * lineBytes + j<span class="number">-1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                *(eroData + i * lineBytes + j) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                *(eroData + i * lineBytes + j) = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">delete</span></span>(tempData);</span><br><span class="line">    <span class="keyword">return</span> eroData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/ero.bmp" class="" title="This is the erosion image">
<h3 id="二值化图像膨胀"><a href="#二值化图像膨胀" class="headerlink" title="二值化图像膨胀"></a>二值化图像膨胀</h3><p>图像膨胀，常用于使目标增大，增粗字体，填补空洞，计算方法为</p>
<script type="math/tex; mode=display">
A\oplus B=\{z\vert(B)_z\cap A\neq\emptyset\}</script><p>其中$A$是二值化图像，$B$是膨胀领域</p>
<p>具体操作就是用一个结构元素(一般是3×3的大小)扫描图像中的每一个像素，用结构元素中的每一个像素与其覆盖的像素做“与”操作，如果都为0，则该像素为0，否则为1</p>
<p>由此可见膨胀和腐蚀其实是对称的运算，因此我们可以将两个运算合并在一起，此时</p>
<script type="math/tex; mode=display">
B=
\begin{bmatrix}0 & 1 & 0\\ 1 & 1 & 1 \\ 0 & 1 & 0\end{bmatrix}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="title">imgEroDila</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* biData, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> lineBytes, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* tempData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* rtnData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="keyword">int</span> p = (flag == <span class="number">1</span>) ? <span class="number">255</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(tempData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(rtnData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(tempData + i * lineBytes + j) == p || *(tempData + (i<span class="number">-1</span>) * lineBytes + j) == p ||</span><br><span class="line">                *(tempData + (i+<span class="number">1</span>) * lineBytes + j) == p || *(tempData + i * lineBytes + j+<span class="number">1</span>) == p ||</span><br><span class="line">                *(tempData + i * lineBytes + j<span class="number">-1</span>) == p) &#123;</span><br><span class="line">                *(rtnData + i * lineBytes + j) = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                *(rtnData + i * lineBytes + j) = <span class="number">255</span> - p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">delete</span></span>(tempData);</span><br><span class="line">    <span class="keyword">return</span> rtnData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/dila.bmp" class="" title="This is the dilation image">
<h3 id="二值化图像开运算"><a href="#二值化图像开运算" class="headerlink" title="二值化图像开运算"></a>二值化图像开运算</h3><p>开运算是先腐蚀后膨胀的过程，它可以消除图像上的细小噪声并平滑边界</p>
<p>有了上述的铺垫，我们可以很快的完成开运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* openBMP = <span class="built_in">fopen</span>(<span class="string">&quot;open.bmp&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfType, <span class="number">2</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfSize, <span class="number">4</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved1, <span class="number">2</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved2, <span class="number">2</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfOffBits, <span class="number">4</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(biInfoHeader, <span class="number">40</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(pColorTable, <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD), <span class="number">256</span>, openBMP);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* openData = <span class="built_in">imgEroDila</span>(biData, width, height, lineBytesBi, <span class="number">0</span>);</span><br><span class="line">openData = <span class="built_in">imgEroDila</span>(openData, width, height, lineBytesBi, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(openData, lineBytesBi * height, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fclose</span>(openBMP);</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/open.bmp" class="" title="This is the open image">
<h3 id="二值化图像闭运算"><a href="#二值化图像闭运算" class="headerlink" title="二值化图像闭运算"></a>二值化图像闭运算</h3><p>闭运算是先膨胀后腐蚀，它可以填充细小空洞并平滑边界</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* closeBMP = <span class="built_in">fopen</span>(<span class="string">&quot;close.bmp&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfType, <span class="number">2</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfSize, <span class="number">4</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved1, <span class="number">2</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved2, <span class="number">2</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfOffBits, <span class="number">4</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(biInfoHeader, <span class="number">40</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(pColorTable, <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD), <span class="number">256</span>, closeBMP);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* closeData = <span class="built_in">imgEroDila</span>(biData, width, height, lineBytesBi, <span class="number">1</span>);</span><br><span class="line">closeData = <span class="built_in">imgEroDila</span>(closeData, width, height, lineBytesBi, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(closeData, lineBytesBi * height, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fclose</span>(closeBMP);</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/close.bmp" class="" title="This is the close image">
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是图像信息处理的第二次作业，总的来说还是比较简单方便的，按照ppt上的说法一步一步来就能得出结果</p>
<p>希望这篇博文能够帮到你完成这次作业</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>Condition Number for Hilbert Matrix</title>
    <url>/2021/10/29/hilbert/</url>
    <content><![CDATA[<p>最近数值分析课遇到一个计算希尔伯特矩阵条件数随维数变化关系情况的问题，在此对其迭代解法的程序实现做一些小小的讨论</p>
<span id="more"></span>
<h2 id="希尔伯特矩阵"><a href="#希尔伯特矩阵" class="headerlink" title="希尔伯特矩阵"></a>希尔伯特矩阵</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%9F%A9%E9%98%B5">希尔伯特矩阵</a>是一种系数都是单位分数的方块矩阵，具体来说希尔伯特矩阵的第$i$行$j$列元素为：</p>
<script type="math/tex; mode=display">
H_{ij}=\frac{1}{i+j-1}</script><p>因此代码中可以通过双重循环构造矩阵（Golang实现）<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genHilbertMatrix</span><span class="params">(n <span class="keyword">int</span>)</span> [][]<span class="title">float64</span></span> &#123;</span><br><span class="line">	H := <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> H &#123; <span class="comment">//初始化矩阵</span></span><br><span class="line">		H[i] = <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">			x := <span class="keyword">float64</span>(i + j + <span class="number">1</span>)</span><br><span class="line">			H[i][j] = <span class="number">1.0</span> / x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> H</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="求取最大和最小特征值"><a href="#求取最大和最小特征值" class="headerlink" title="求取最大和最小特征值"></a>求取最大和最小特征值</h2><p>条件数K的定义为，对于任意范式$||·||$和非奇异矩阵$A$，有</p>
<script type="math/tex; mode=display">
K(A)=\left\|A\right\|\cdot\left\|A^{-1}\right\|</script><p>而对于<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5">正定矩阵</a>，可以证明条件数为</p>
<script type="math/tex; mode=display">
K(A)=\left|\frac{\lambda_{max}(A)}{\lambda_{min}(A)}\right|</script><p>很明显，希尔伯特矩阵是一个正定矩阵，因此只要求出其最大和最小特征值即可计算出条件数</p>
<h3 id="最大特征值计算"><a href="#最大特征值计算" class="headerlink" title="最大特征值计算"></a>最大特征值计算</h3><p>这里我们使用幂法进行计算，注意此时的前提条件为</p>
<script type="math/tex; mode=display">
\left|\lambda_1\right| > \left|\lambda_2\right| \geq \left|\lambda_3\right|\geq \cdots \geq \left|\lambda_n\right|</script><p>我们构造一系列向量序列，有</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{**lr**}
\vec{v_0}\in R^n\quad And\quad\vec{v_0}\neq\vec{0} \\
\vec{v_1}=A\vec{v_0} \\
\vec{v_{k+1}}=A\vec{v_k}\ (k=0,1,\cdots,n)
\end{array}
\right.</script><p>可以证明，</p>
<script type="math/tex; mode=display">
\lim_{k\to\infty}\frac{\left\|\vec{v_{k+1}}\right\|_i}{\left\|\vec{v_{k}}\right\|_i}=\lambda_1</script><p>同时在计算机计算过程中，为了防止数据过大导致的越界， 我们可以对$\vec{v_k}$进行规范化，即令</p>
<script type="math/tex; mode=display">
\vec{u_k}=\frac{\vec{v_k}}{\left\|\vec{v_k}\right\|_\infty}</script><p>然后对$\vec{u_k}$进行迭代与规范化操作</p>
<p>同时，我们可以证明</p>
<script type="math/tex; mode=display">
\lim_{k\to\infty}\left\|\vec{v_k}\right\|_\infty=\lambda_1</script><p>因此我们可以得出以下代码来计算最大特征值<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxLambda</span><span class="params">(mat [][]<span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> MaxIteration = <span class="number">10000</span></span><br><span class="line">	<span class="keyword">const</span> MaxError = <span class="number">0.00001</span></span><br><span class="line">	v0 := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n) <span class="comment">//生成迭代初始向量</span></span><br><span class="line">	v0[<span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">	lambda := <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> lambda0, counter := <span class="number">1.0</span>, <span class="number">1</span>; math.Abs(lambda-lambda0) &gt; MaxError &amp;&amp; counter &lt; MaxIteration; counter++ &#123; <span class="comment">//迭代边界，次数限制与误差限制</span></span><br><span class="line">		lambda0 = lambda</span><br><span class="line">		u := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)  <span class="comment">//生成迭代后向量</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//计算u=Av</span></span><br><span class="line">			u[i] = <span class="number">0.0</span></span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">				u[i] += mat[i][j] * v0[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		lambda = <span class="number">0.0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//找到最大值</span></span><br><span class="line">			<span class="keyword">if</span> lambda &lt; math.Abs(u[i]) &#123;</span><br><span class="line">				lambda = math.Abs(u[i])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//进行规范化</span></span><br><span class="line">			v0[i] = u[i] / lambda</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lambda</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="计算最小特征值"><a href="#计算最小特征值" class="headerlink" title="计算最小特征值"></a>计算最小特征值</h3><p>幂法十分完美地解决了最大特征值的问题，而对于最小特征值，我们可以很自然的想到只要求取$A^{-1}$的最大特征值，其倒数就是原矩阵的最小特征值<br>但这依然有些麻烦，因此我们可以使用$LU$分解绕过对$A$求逆的过程进行迭代，即通过解方程组：</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{**lr**}
L\vec{w}=\vec{v} \\
U\vec{u}=\vec{w} \\
\end{array}
\right.</script><p>即可通过$\vec{v}$得出$\vec{u}$的值</p>
<h3 id="LU-分解"><a href="#LU-分解" class="headerlink" title="$LU$分解"></a>$LU$分解</h3><p>事实上，将$A$进行初等行变换之后变成一个上三角矩阵，其变换矩阵就是一个下三角矩阵，这就是所谓$LU$分解</p>
<p>我们可以通过所谓杜尔利特算法进行分解，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LUDecomposition</span><span class="params">(mat [][]<span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="params">([][]<span class="keyword">float64</span>, [][]<span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	L, U := <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n), <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> mat &#123;</span><br><span class="line">		L[i], U[i] = <span class="built_in">make</span>([]<span class="keyword">float64</span>, n), <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		L[i][i] = <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			U[<span class="number">0</span>][<span class="number">0</span>] = mat[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">				U[<span class="number">0</span>][j] = mat[<span class="number">0</span>][j]</span><br><span class="line">				L[j][<span class="number">0</span>] = mat[<span class="number">0</span>][j] / U[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">//生成U</span></span><br><span class="line">				temp := <span class="number">0.0</span></span><br><span class="line">				<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; i; k++ &#123;</span><br><span class="line">					temp += L[i][k] * U[k][j]</span><br><span class="line">				&#125;</span><br><span class="line">				U[i][j] = mat[i][j] - temp</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123; <span class="comment">//生成L</span></span><br><span class="line">				temp := <span class="number">0.0</span></span><br><span class="line">				<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; i; k++ &#123;</span><br><span class="line">					temp += L[j][k] * U[k][i]</span><br><span class="line">				&#125;</span><br><span class="line">				L[j][i] = (mat[j][i] - temp) / U[i][i]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L, U</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回到最小特征值计算"><a href="#回到最小特征值计算" class="headerlink" title="回到最小特征值计算"></a>回到最小特征值计算</h3><p>得到了$LU$矩阵，我们只需要反解出$\vec{u}$的值即可迭代到我们需要的精度，代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinLambda</span><span class="params">(mat [][]<span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> MaxIteration = <span class="number">10000</span></span><br><span class="line">	<span class="keyword">const</span> MaxError = <span class="number">0.00001</span></span><br><span class="line">	L, U := LUDecomposition(mat, n)</span><br><span class="line">	v0 := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n) <span class="comment">//生成迭代初始向量</span></span><br><span class="line">	v0[<span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">	lambda := <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> lambda0, counter := <span class="number">1.0</span>, <span class="number">1</span>; math.Abs(lambda-lambda0) &gt; MaxError &amp;&amp; counter &lt; MaxIteration; counter++ &#123; <span class="comment">//迭代边界，次数限制与误差限制</span></span><br><span class="line">		lambda0 = lambda</span><br><span class="line">		w := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">		u := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//解出Lw=v</span></span><br><span class="line">			temp := <span class="number">0.0</span></span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">				temp += L[i][j] * w[j]</span><br><span class="line">			&#125;</span><br><span class="line">			w[i] = v0[i] - temp</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i-- &#123; <span class="comment">//解出Uu=w</span></span><br><span class="line">			temp := <span class="number">0.0</span></span><br><span class="line">			<span class="keyword">for</span> j := i; j &lt; n; j++ &#123;</span><br><span class="line">				temp += U[i][j] * u[j]</span><br><span class="line">			&#125;</span><br><span class="line">			u[i] = (w[i] - temp) / U[i][i]</span><br><span class="line">		&#125;</span><br><span class="line">		lambda = <span class="number">0.0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//找到最大值</span></span><br><span class="line">			<span class="keyword">if</span> lambda &lt; math.Abs(u[i]) &#123;</span><br><span class="line">				lambda = math.Abs(u[i])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//进行规范化</span></span><br><span class="line">			v0[i] = u[i] / lambda</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lambda</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算条件数"><a href="#计算条件数" class="headerlink" title="计算条件数"></a>计算条件数</h2><p>有了上面的前置工作，最后一步计算条件数就显得十分简单，不过我们在$getMinLambda()$中返回的是最小特征值的倒数，因此在最后直接两者相乘即可，最后代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">condNum</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	mat := genHilbertMatrix(n)</span><br><span class="line">	lambda1 := getMaxLambda(mat, n)</span><br><span class="line">	lambda2 := getMinLambda(mat, n)</span><br><span class="line">	cond := lambda1 * lambda2</span><br><span class="line">	<span class="keyword">return</span> cond</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><img src="/2021/10/29/hilbert/NAimg.png" class="" title="Data generated by Golang">
<p>通过与matlab输出进行对比，发现数据精度能达到四到五位</p>
<img src="/2021/10/29/hilbert/MLimg.png" class="" title="Data generated by Matlab">
<h2 id="无穷范数情况下的条件数"><a href="#无穷范数情况下的条件数" class="headerlink" title="无穷范数情况下的条件数"></a>无穷范数情况下的条件数</h2><p>之前通过特征值对于条件数的计算都是建立在2范数的情况下的，而本题讨论的其实是在无穷范数情况下的条件数变化（审题不清orz）</p>
<p>所幸，我们发现希尔伯特矩阵的逆矩阵可以通过特定公式来求解，即</p>
<script type="math/tex; mode=display">(H^{-1})_{ij}= (-1)^{i+j} (i + j - 1) \left( \begin{array}{cc} n + i - 1 \\ n - j \end{array} \right) \left( \begin{array}{cc} n + j - 1 \\ n - i \end{array} \right) \left( \begin{array}{cc} i + j - 2 \\ i - 1 \end{array} \right)\left( \begin{array}{cc} i + j - 2 \\ j - 1 \end{array} \right)</script><p>很明显，他是对称的，所以我们可以省下一半时间计算他们</p>
<p>但是显然，倘若通过阶乘式来求组合数十分容易溢出，故我们可以使用<a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95">辗转相除法</a>来不断约化防止溢出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">//求最大公因数</span></span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//约化a和b</span></span><br><span class="line">	gcd := gcd(a, b)</span><br><span class="line">	a /= gcd</span><br><span class="line">	b /= gcd</span><br><span class="line">	<span class="keyword">return</span> a, b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们就可以开始计算组合数了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combination</span><span class="params">(n, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	i := k + <span class="number">1</span></span><br><span class="line">	r := n - k</span><br><span class="line">	<span class="keyword">if</span> r &gt; k &#123; <span class="comment">//选择更少计算量的那一边</span></span><br><span class="line">		i = r + <span class="number">1</span></span><br><span class="line">		r = k</span><br><span class="line">	&#125;</span><br><span class="line">	f1, f2 := <span class="number">1</span>, <span class="number">1</span> <span class="comment">//分数的上下项</span></span><br><span class="line">	j := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt;= n; i++ &#123;</span><br><span class="line">		f1 *= i</span><br><span class="line">		<span class="keyword">for</span> ; j &lt;= r; j++ &#123;</span><br><span class="line">			f2 *= j</span><br><span class="line">			<span class="keyword">if</span> f2 &gt; f1 &#123; <span class="comment">//分母要小于分子啦~</span></span><br><span class="line">				j++</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> gcd := gcd(f1, f2); gcd &gt; <span class="number">1</span> &#123; <span class="comment">//计算中约化</span></span><br><span class="line">				f1, f2 = div(f1, f2)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f1 / f2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上文提到的公式，我们可以通过编程求出逆希尔伯特矩阵</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genInvHilbertMatrix</span><span class="params">(n <span class="keyword">int</span>)</span> [][]<span class="title">float64</span></span> &#123;</span><br><span class="line">	invH := <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> invH &#123; <span class="comment">//初始化矩阵</span></span><br><span class="line">		invH[i] = <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++ &#123; <span class="comment">//根据对称性减少一半计算量</span></span><br><span class="line">			x := (i + j + <span class="number">1</span>) * combination(n+i, n-j<span class="number">-1</span>) * combination(n+j, n-i<span class="number">-1</span>) * combination(i+j, i) * combination(i+j, j)</span><br><span class="line">			<span class="keyword">if</span> (i+j)%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">				invH[i][j], invH[j][i] = <span class="keyword">float64</span>(x), <span class="keyword">float64</span>(x)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				invH[i][j], invH[j][i] = <span class="keyword">float64</span>(-x), <span class="keyword">float64</span>(-x)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> invH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求无穷范数"><a href="#求无穷范数" class="headerlink" title="求无穷范数"></a>求无穷范数</h3><p>无穷范数，就是矩阵中绝对值和最大的一行，这个重复性操作可以很简单地用循环实现，代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">condNumInf</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	mat := genHilbertMatrix(n)</span><br><span class="line">	invMat := genInvHilbertMatrix(n)</span><br><span class="line">	normInf1, normInf2 := <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		sum1, sum2 := <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">			sum1 += math.Abs(mat[i][j])</span><br><span class="line">			sum2 += math.Abs(invMat[i][j])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sum1 &gt; normInf1 &#123;</span><br><span class="line">			normInf1 = sum1</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sum2 &gt; normInf2 &#123;</span><br><span class="line">			normInf2 = sum2</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> normInf1 * normInf2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2><img src="/2021/10/29/hilbert/NAInfimg.png" class="" title="Data generated by Golang">
<p>通过与matlab输出进行对比，发现数据精度能达到四到五位</p>
<img src="/2021/10/29/hilbert/MLInfimg.png" class="" title="Data generated by Matlab">
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
</search>
