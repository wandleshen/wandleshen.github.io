<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/2021/10/28/World/</url>
    <content><![CDATA[<blockquote>
<p>于浩歌狂热之际中寒;于天上看见深渊。于一切眼中看见无所有;于无所希望中得救。</p>
</blockquote>
<p>欢迎来到Wandleshen的博客，目前是一个计算机专业在读大学生，还有很多东西需要学习呢。</p>
<h2 id="主营业务"><a href="#主营业务" class="headerlink" title="主营业务"></a>主营业务</h2><ul>
<li><a href="https://wandleshen.github.io/tags/%E5%88%B7%E9%A2%98/">刷题感想</a></li>
<li><a href="https://wandleshen.github.io/tags/%E9%9A%8F%E7%AC%94/">日常随笔</a></li>
<li><a href="https://wandleshen.github.io/tags/%E6%B8%B8%E6%88%8F/">游戏分享</a></li>
<li><a href="https://wandleshen.github.io/tags/%E7%81%B5%E6%84%9F/">灵感记录</a></li>
</ul>
]]></content>
      <tags>
        <tag>主页</tag>
      </tags>
  </entry>
  <entry>
    <title>Condition Number for Hilbert Matrix</title>
    <url>/2021/10/29/hilbert/</url>
    <content><![CDATA[<p>最近数值分析课遇到一个计算希尔伯特矩阵条件数随维数变化关系情况的问题，在此对其迭代解法的程序实现做一些小小的讨论</p>
<span id="more"></span>
<h2 id="希尔伯特矩阵"><a href="#希尔伯特矩阵" class="headerlink" title="希尔伯特矩阵"></a>希尔伯特矩阵</h2><p><a href="https://zh.wikipedia.org/zh-hans/%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%9F%A9%E9%98%B5">希尔伯特矩阵</a>是一种系数都是单位分数的方块矩阵，具体来说希尔伯特矩阵的第$i$行$j$列元素为：</p>
<script type="math/tex; mode=display">
H_{ij}=\frac{1}{i+j-1}</script><p>因此代码中可以通过双重循环构造矩阵（Golang实现）<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genHilbertMatrix</span><span class="params">(n <span class="keyword">int</span>)</span> [][]<span class="title">float64</span></span> &#123;</span><br><span class="line">	H := <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> H &#123; <span class="comment">//初始化矩阵</span></span><br><span class="line">		H[i] = <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">			x := <span class="keyword">float64</span>(i + j + <span class="number">1</span>)</span><br><span class="line">			H[i][j] = <span class="number">1.0</span> / x</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> H</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="求取最大和最小特征值"><a href="#求取最大和最小特征值" class="headerlink" title="求取最大和最小特征值"></a>求取最大和最小特征值</h2><p>条件数K的定义为，对于任意范式$||·||$和非奇异矩阵$A$，有</p>
<script type="math/tex; mode=display">
K(A)=\left\|A\right\|\cdot\left\|A^{-1}\right\|</script><p>而对于<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5">正定矩阵</a>，可以证明条件数为</p>
<script type="math/tex; mode=display">
K(A)=\left|\frac{\lambda_{max}(A)}{\lambda_{min}(A)}\right|</script><p>很明显，希尔伯特矩阵是一个正定矩阵，因此只要求出其最大和最小特征值即可计算出条件数</p>
<h3 id="最大特征值计算"><a href="#最大特征值计算" class="headerlink" title="最大特征值计算"></a>最大特征值计算</h3><p>这里我们使用幂法进行计算，注意此时的前提条件为</p>
<script type="math/tex; mode=display">
\left|\lambda_1\right| > \left|\lambda_2\right| \geq \left|\lambda_3\right|\geq \cdots \geq \left|\lambda_n\right|</script><p>我们构造一系列向量序列，有</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{**lr**}
\vec{v_0}\in R^n\quad And\quad\vec{v_0}\neq\vec{0} \\
\vec{v_1}=A\vec{v_0} \\
\vec{v_{k+1}}=A\vec{v_k}\ (k=0,1,\cdots,n)
\end{array}
\right.</script><p>可以证明，</p>
<script type="math/tex; mode=display">
\lim_{k\to\infty}\frac{\left\|\vec{v_{k+1}}\right\|_i}{\left\|\vec{v_{k}}\right\|_i}=\lambda_1</script><p>同时在计算机计算过程中，为了防止数据过大导致的越界， 我们可以对$\vec{v_k}$进行规范化，即令</p>
<script type="math/tex; mode=display">
\vec{u_k}=\frac{\vec{v_k}}{\left\|\vec{v_k}\right\|_\infty}</script><p>然后对$\vec{u_k}$进行迭代与规范化操作</p>
<p>同时，我们可以证明</p>
<script type="math/tex; mode=display">
\lim_{k\to\infty}\left\|\vec{v_k}\right\|_\infty=\lambda_1</script><p>因此我们可以得出以下代码来计算最大特征值<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxLambda</span><span class="params">(mat [][]<span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> MaxIteration = <span class="number">10000</span></span><br><span class="line">	<span class="keyword">const</span> MaxError = <span class="number">0.00001</span></span><br><span class="line">	v0 := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n) <span class="comment">//生成迭代初始向量</span></span><br><span class="line">	v0[<span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">	lambda := <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> lambda0, counter := <span class="number">1.0</span>, <span class="number">1</span>; math.Abs(lambda-lambda0) &gt; MaxError &amp;&amp; counter &lt; MaxIteration; counter++ &#123; <span class="comment">//迭代边界，次数限制与误差限制</span></span><br><span class="line">		lambda0 = lambda</span><br><span class="line">		u := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)  <span class="comment">//生成迭代后向量</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//计算u=Av</span></span><br><span class="line">			u[i] = <span class="number">0.0</span></span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">				u[i] += mat[i][j] * v0[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		lambda = <span class="number">0.0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//找到最大值</span></span><br><span class="line">			<span class="keyword">if</span> lambda &lt; math.Abs(u[i]) &#123;</span><br><span class="line">				lambda = math.Abs(u[i])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//进行规范化</span></span><br><span class="line">			v0[i] = u[i] / lambda</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lambda</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="计算最小特征值"><a href="#计算最小特征值" class="headerlink" title="计算最小特征值"></a>计算最小特征值</h3><p>幂法十分完美地解决了最大特征值的问题，而对于最小特征值，我们可以很自然的想到只要求取$A^{-1}$的最大特征值，其倒数就是原矩阵的最小特征值<br>但这依然有些麻烦，因此我们可以使用$LU$分解绕过对$A$求逆的过程进行迭代，即通过解方程组：</p>
<script type="math/tex; mode=display">
\left\{
\begin{array}{**lr**}
L\vec{w}=\vec{v} \\
U\vec{u}=\vec{w} \\
\end{array}
\right.</script><p>即可通过$\vec{v}$得出$\vec{u}$的值</p>
<h3 id="LU-分解"><a href="#LU-分解" class="headerlink" title="$LU$分解"></a>$LU$分解</h3><p>事实上，将$A$进行初等行变换之后变成一个上三角矩阵，其变换矩阵就是一个下三角矩阵，这就是所谓$LU$分解</p>
<p>我们可以通过所谓杜尔利特算法进行分解，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LUDecomposition</span><span class="params">(mat [][]<span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="params">([][]<span class="keyword">float64</span>, [][]<span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	L, U := <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n), <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> mat &#123;</span><br><span class="line">		L[i], U[i] = <span class="built_in">make</span>([]<span class="keyword">float64</span>, n), <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		L[i][i] = <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			U[<span class="number">0</span>][<span class="number">0</span>] = mat[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">				U[<span class="number">0</span>][j] = mat[<span class="number">0</span>][j]</span><br><span class="line">				L[j][<span class="number">0</span>] = mat[<span class="number">0</span>][j] / U[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := i; j &lt; n; j++ &#123; <span class="comment">//生成U</span></span><br><span class="line">				temp := <span class="number">0.0</span></span><br><span class="line">				<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; i; k++ &#123;</span><br><span class="line">					temp += L[i][k] * U[k][j]</span><br><span class="line">				&#125;</span><br><span class="line">				U[i][j] = mat[i][j] - temp</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; n; j++ &#123; <span class="comment">//生成L</span></span><br><span class="line">				temp := <span class="number">0.0</span></span><br><span class="line">				<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; i; k++ &#123;</span><br><span class="line">					temp += L[j][k] * U[k][i]</span><br><span class="line">				&#125;</span><br><span class="line">				L[j][i] = (mat[j][i] - temp) / U[i][i]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> L, U</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回到最小特征值计算"><a href="#回到最小特征值计算" class="headerlink" title="回到最小特征值计算"></a>回到最小特征值计算</h3><p>得到了$LU$矩阵，我们只需要反解出$\vec{u}$的值即可迭代到我们需要的精度，代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMinLambda</span><span class="params">(mat [][]<span class="keyword">float64</span>, n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> MaxIteration = <span class="number">10000</span></span><br><span class="line">	<span class="keyword">const</span> MaxError = <span class="number">0.00001</span></span><br><span class="line">	L, U := LUDecomposition(mat, n)</span><br><span class="line">	v0 := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n) <span class="comment">//生成迭代初始向量</span></span><br><span class="line">	v0[<span class="number">0</span>] = <span class="number">1.0</span></span><br><span class="line">	lambda := <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> lambda0, counter := <span class="number">1.0</span>, <span class="number">1</span>; math.Abs(lambda-lambda0) &gt; MaxError &amp;&amp; counter &lt; MaxIteration; counter++ &#123; <span class="comment">//迭代边界，次数限制与误差限制</span></span><br><span class="line">		lambda0 = lambda</span><br><span class="line">		w := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">		u := <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//解出Lw=v</span></span><br><span class="line">			temp := <span class="number">0.0</span></span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">				temp += L[i][j] * w[j]</span><br><span class="line">			&#125;</span><br><span class="line">			w[i] = v0[i] - temp</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">-1</span>; i-- &#123; <span class="comment">//解出Uu=w</span></span><br><span class="line">			temp := <span class="number">0.0</span></span><br><span class="line">			<span class="keyword">for</span> j := i; j &lt; n; j++ &#123;</span><br><span class="line">				temp += U[i][j] * u[j]</span><br><span class="line">			&#125;</span><br><span class="line">			u[i] = (w[i] - temp) / U[i][i]</span><br><span class="line">		&#125;</span><br><span class="line">		lambda = <span class="number">0.0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//找到最大值</span></span><br><span class="line">			<span class="keyword">if</span> lambda &lt; math.Abs(u[i]) &#123;</span><br><span class="line">				lambda = math.Abs(u[i])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123; <span class="comment">//进行规范化</span></span><br><span class="line">			v0[i] = u[i] / lambda</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lambda</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算条件数"><a href="#计算条件数" class="headerlink" title="计算条件数"></a>计算条件数</h2><p>有了上面的前置工作，最后一步计算条件数就显得十分简单，不过我们在$getMinLambda()$中返回的是最小特征值的倒数，因此在最后直接两者相乘即可，最后代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">condNum</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	mat := genHilbertMatrix(n)</span><br><span class="line">	lambda1 := getMaxLambda(mat, n)</span><br><span class="line">	lambda2 := getMinLambda(mat, n)</span><br><span class="line">	cond := lambda1 * lambda2</span><br><span class="line">	<span class="keyword">return</span> cond</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><img src="/2021/10/29/hilbert/NAimg.png" class="" title="Data generated by Golang">
<p>通过与matlab输出进行对比，发现数据精度能达到四到五位</p>
<img src="/2021/10/29/hilbert/MLimg.png" class="" title="Data generated by Matlab">
<h2 id="无穷范数情况下的条件数"><a href="#无穷范数情况下的条件数" class="headerlink" title="无穷范数情况下的条件数"></a>无穷范数情况下的条件数</h2><p>之前通过特征值对于条件数的计算都是建立在2范数的情况下的，而本题讨论的其实是在无穷范数情况下的条件数变化（审题不清orz）</p>
<p>所幸，我们发现希尔伯特矩阵的逆矩阵可以通过特定公式来求解，即</p>
<script type="math/tex; mode=display">(H^{-1})_{ij}= (-1)^{i+j} (i + j - 1) \left( \begin{array}{cc} n + i - 1 \\ n - j \end{array} \right) \left( \begin{array}{cc} n + j - 1 \\ n - i \end{array} \right) \left( \begin{array}{cc} i + j - 2 \\ i - 1 \end{array} \right)\left( \begin{array}{cc} i + j - 2 \\ j - 1 \end{array} \right)</script><p>很明显，他是对称的，所以我们可以省下一半时间计算他们</p>
<p>但是显然，倘若通过阶乘式来求组合数十分容易溢出，故我们可以使用<a href="https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95">辗转相除法</a>来不断约化防止溢出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">//求最大公因数</span></span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//约化a和b</span></span><br><span class="line">	gcd := gcd(a, b)</span><br><span class="line">	a /= gcd</span><br><span class="line">	b /= gcd</span><br><span class="line">	<span class="keyword">return</span> a, b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们就可以开始计算组合数了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combination</span><span class="params">(n, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	i := k + <span class="number">1</span></span><br><span class="line">	r := n - k</span><br><span class="line">	<span class="keyword">if</span> r &gt; k &#123; <span class="comment">//选择更少计算量的那一边</span></span><br><span class="line">		i = r + <span class="number">1</span></span><br><span class="line">		r = k</span><br><span class="line">	&#125;</span><br><span class="line">	f1, f2 := <span class="number">1</span>, <span class="number">1</span> <span class="comment">//分数的上下项</span></span><br><span class="line">	j := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt;= n; i++ &#123;</span><br><span class="line">		f1 *= i</span><br><span class="line">		<span class="keyword">for</span> ; j &lt;= r; j++ &#123;</span><br><span class="line">			f2 *= j</span><br><span class="line">			<span class="keyword">if</span> f2 &gt; f1 &#123; <span class="comment">//分母要小于分子啦~</span></span><br><span class="line">				j++</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> gcd := gcd(f1, f2); gcd &gt; <span class="number">1</span> &#123; <span class="comment">//计算中约化</span></span><br><span class="line">				f1, f2 = div(f1, f2)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f1 / f2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上文提到的公式，我们可以通过编程求出逆希尔伯特矩阵</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genInvHilbertMatrix</span><span class="params">(n <span class="keyword">int</span>)</span> [][]<span class="title">float64</span></span> &#123;</span><br><span class="line">	invH := <span class="built_in">make</span>([][]<span class="keyword">float64</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> invH &#123; <span class="comment">//初始化矩阵</span></span><br><span class="line">		invH[i] = <span class="built_in">make</span>([]<span class="keyword">float64</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++ &#123; <span class="comment">//根据对称性减少一半计算量</span></span><br><span class="line">			x := (i + j + <span class="number">1</span>) * combination(n+i, n-j<span class="number">-1</span>) * combination(n+j, n-i<span class="number">-1</span>) * combination(i+j, i) * combination(i+j, j)</span><br><span class="line">			<span class="keyword">if</span> (i+j)%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">				invH[i][j], invH[j][i] = <span class="keyword">float64</span>(x), <span class="keyword">float64</span>(x)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				invH[i][j], invH[j][i] = <span class="keyword">float64</span>(-x), <span class="keyword">float64</span>(-x)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> invH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求无穷范数"><a href="#求无穷范数" class="headerlink" title="求无穷范数"></a>求无穷范数</h3><p>无穷范数，就是矩阵中绝对值和最大的一行，这个重复性操作可以很简单地用循环实现，代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">condNumInf</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	mat := genHilbertMatrix(n)</span><br><span class="line">	invMat := genInvHilbertMatrix(n)</span><br><span class="line">	normInf1, normInf2 := <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		sum1, sum2 := <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">			sum1 += math.Abs(mat[i][j])</span><br><span class="line">			sum2 += math.Abs(invMat[i][j])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sum1 &gt; normInf1 &#123;</span><br><span class="line">			normInf1 = sum1</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sum2 &gt; normInf2 &#123;</span><br><span class="line">			normInf2 = sum2</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> normInf1 * normInf2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h2><img src="/2021/10/29/hilbert/NAInfimg.png" class="" title="Data generated by Golang">
<p>通过与matlab输出进行对比，发现数据精度能达到四到五位</p>
<img src="/2021/10/29/hilbert/MLInfimg.png" class="" title="Data generated by Matlab">
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>随记I</title>
    <url>/2021/10/29/loving-story/</url>
    <content><![CDATA[<p>这是一个我在一本日记上看到的故事，它可能代表了过去，也可能预言了未来。</p>
<span id="more"></span>
<h2 id="关于那天看到的女孩是不是我的前女友这件事"><a href="#关于那天看到的女孩是不是我的前女友这件事" class="headerlink" title="关于那天看到的女孩是不是我的前女友这件事"></a>关于那天看到的女孩是不是我的前女友这件事</h2><p>和她分手之后，我经常想如果再次遇见她我会怎么做。很多个夜晚我觉得应该去找她，应该告诉她“我当时不知道怎么爱你，让你不舒服了。但和你在一起的时候我真的很愉快。我们还能做朋友吗？我很想你。”</p>
<p>但校园很大，命运女神没让我再遇见她。</p>
<p>直到在那个课间，半长黑头发、骑着自行车的女孩笑着向我挥手，条件反射地我摆出一个营业微笑打招呼。她骑过去了，我还在回忆那是谁。<br>接着我突然想到，那不会是她吧？</p>
<p>记不住分手三个月的前女友的脸看上去似乎离奇，但毕竟不能用正常人的经验苛求脸盲。<br>身为脸盲，我有丰富的伪装正常人经验。我记不住五官的动态组合，所以把外貌特征提炼成文字是我认识每个人的第一步。</p>
<p>她的身高是一米五。那之前我对一米五没什么实感，认识她之后才发现这算是个罕见特征。刚认识她时我都通过身高辨认她，所以我很喜欢这么高的她——但那个女孩骑着自行车，我看不出她的身高。</p>
<p>她不戴眼镜。真是个遗憾，因为我经常通过镜框标识人脸。衣服隔了一夜就可能换一件，眼镜可是几个月乃至几年都不会变化的特征——可惜，她和那个女孩都不戴眼镜。</p>
<p>她是中短发，有染过棕色的遗迹。而那个女孩是中长的黑色微卷头发。但这更不能说明什么了，虽然从小到大没和多少女孩打过交道，但我也知道一个假期过去女孩的发型可能产生根本性改变。</p>
<p>最后我还是认为那个女孩不是我的前女友。其一，哪怕过了一个假期她大概也不是能笑着向前男友打招呼的那种女孩。其二，那不是她的自行车。我记得她的自行车是粉色的，有一对极小的车轮。她还吐槽过这辆车是她的妈妈千里迢迢送她上大学时挑选的、并不符合她的品味。那辆车的车筐小而浅，根本装不下什么东西。而向我打招呼的那个女孩车筐里不仅装了书包还竖着插了两张卷起来的设计图，根本是那辆粉色自行车无法承受之重。</p>
<p>“那不是她，”我最后向自己确认，“我大概永远不会遇见我的前女友了。”</p>
<p>我在史纲课上认识她。课上别的系的学生占绝对多数而且差不多都互相脸熟，老师下令分小组之后简直是瞬间就组好了队，我和朋友作为外系学生只能在课堂群里发“二缺四求组队”。</p>
<p>她是联系我的人之一。她说“我是20级能化高的，你们还缺人吗？我可能有点内向，不太擅长小组作业。如果不能再加人的话给我发个笑脸就好啦。”</p>
<p>我觉得有点好笑。大家都是内卷大潮中的大学生，如果有选择的话谁愿意和一群陌生人组队呢，有人主动要求当然是求之不得。</p>
<p>话说回来，我还是第一次见到刚发出邀请就已经开始考虑怎么体面地被拒绝的人。</p>
<p>我说：“还缺人，稍等，我拉个群。”</p>
<p>我们就是这么认识的。</p>
<p>“能化高”的全称是“能源、化工、高分子”。她说这个的时候我们小组成员坐在去附近纪念馆的公交车上，准备一篇小组展示的稿子。我看着坐在窗边拄着下巴的她，看上去文静又平凡，窗外的光斑投在她扎头发的黄丝带上。我想：这听上去不像是她的专业。</p>
<p>她说她的父母都阴差阳错学了医，并致力于打消亲朋好友家小孩的医学梦想。但她有一次问她的母亲重来一次要干什么，她的母亲毫不犹豫：“学医。”</p>
<p>“所有人都说做出选择之前要充分了解。”她看着窗外，“但充分了解之后，你也走不开了。”</p>
<p>我看着她。我想到其实我也不爱自己的志愿——不过是在前途和兴趣之间找了个不好不坏的平衡点罢了。我不讨厌我的专业，这已经比大多数人幸运了。</p>
<p>纪念馆没什么好说的。回学校时组长决定打车，一辆车只能坐下四人也就意味着有两人要落单。感谢朋友眼疾手快把三个人推进出租车，关上车门之前向我眉毛一挑。</p>
<p>我看着她有点尴尬。她看着手机上的打车软件，告诉我走过一条街更好打车。</p>
<p>那条街两边种着银杏树，秋天时叶子金黄飘落一地。她走在我前面半步，忽然伸手去抓飘落的银杏叶，但那片叶子刁钻地从她手指缝里逃跑了。她回过头，有点不好意思地笑了。</p>
<p>我看着她的脸。我记不住，我知道，这张脸很快会从我记忆中溜走。但脸盲不意味着我不会辨认美丑。</p>
<p>秋天的阳光透过银杏树荫，她脸上淡淡的雀斑几近透明。黄丝带系在她的头发上，好像金黄色的叶子摇曳舞蹈。她笑起来。</p>
<p>但在那之后我和她将近一个月没什么联系。2021年了，我第一次见到上课时真的一点消息不回的当代大学生。我试着打开话题，她草草带过。我觉得大概没什么之后了。</p>
<p>后来有个晚课下课的日子，我看见路边有卖苹果。过度包装的典范，一个苹果外面裹了一层又一层的红色包装纸。我突然想到那是12月24日，平安夜。</p>
<p>我对过度包装不感兴趣，但我突然很想吃苹果。苹果涨价了，但也说得过去。我买了几个又红又大的苹果，拿在手里掂量。我这个人有点相信生活需要仪式感，但把一袋子仪式感拿在手里之后又觉得独自找仪式感没什么意思。</p>
<p>我突然很想见她。</p>
<p>如果一个不太熟的课友问她“你在寝室吗”，她会回复吗？</p>
<p>她说“在，有什么事吗？”</p>
<p>我问“你方便下楼吗？”</p>
<p>我在她楼下等着，用目光徒劳无益地筛选着走过的女孩，那一袋子苹果在我的手上压出勒痕。女孩们的脸在我脸盲的脑子里滑过去，好像莲叶上的水滴一样毫无痕迹。我开始害怕她已经出现但没被我认出来，或者她也还没记住我的脸。</p>
<p>……但她出现了。我不知道她的身高有反向的鹤立鸡群作用，但同样好认。这几乎让我松了一口气。</p>
<p>我已经从那袋苹果里挑出了最红最大最适合送人的一个，但她走过来时我又觉得从一袋苹果里只拿出一个送她是不是不太好。天哪她走过来了她走近了她裹在红色的牛角扣大衣里脑子啊你快想想办法——</p>
<p>我把整个装着苹果的袋子塞到她手里，语无伦次地说了一些类似于“本来也是买来自己吃的但突然想送人所以觉得你是最合适送的人”之类的话，自己都觉得自己从各个角度来看真是愚蠢得惊人。——不过往好点想，起码她收下了。</p>
<p>她的脸红扑扑的，我能看到她的头顶。我觉得我低下身简直可以把下巴搭在她柔软的发旋上。</p>
<p>她说“谢谢你，我很喜欢。”</p>
<p>我不了解女孩，但我觉得她真的挺开心。</p>
<p>那之后很快《情书》重映。我本来已经做好了自己去看爱情片的准备，但后来想到了她。</p>
<p>我们骑车去了附近的商场。我们先吃了一顿芝士排骨火锅配拌饭。我说我喜欢这里的芝士排骨，第一次来吃是社团破冰，每个人才吃到一根。后来我想再来又约不到人，于是就自己过去告诉服务员“两位，来个芝士排骨”然后自己吃掉。服务员一定觉得我被放了鸽子于是化悲痛为食欲……</p>
<p>她看着我笑。</p>
<p>我们走进电影院。当博子和茂一起踩在雪地上时，我就发现了问题——电影院的空调温度开得实在太低，冷库一般的电影院和银幕上的雪景双重夹击，简直像是4D体感电影。她只穿了T恤，我也没穿外套，我都能感觉到她的冷。</p>
<p>但我也没什么办法。</p>
<p>她的手搭在座椅侧边，我的手也搭在座椅侧边。她可以拉我的手，我也可以拉她的手。但我们谁都没有动。我想：她是那种想要专注看电影的人吧？她不愿意被打扰吧？……</p>
<p>于是我和她相安无事地看完了电影。</p>
<p>回来的路上我们骑着车，漫无边际地聊天。我想到看过的一些故事，此时说不出来的话未来就永远说不出来了。我的心跳得很快，我想要装作不经意地开口但一开口就暴露无余。我说：“其实我刚才一直在想，要不要拉你的手。”</p>
<p>粉色的小车轮嘎吱一响，她停下车。她抬头看了我一眼，别开目光，说：“我也在想一样的事。”</p>
<p>听到那句话时我就知道我和她会在一起。</p>
<p>认识她之前，我觉得世界上的所有人在特定情况下可以和所有人相爱。只要经过一段时间的相处创造出共同的经历，性格爱好过往什么的一切差异都可以被抹平。我的脸盲可能是这种观念的成因之一，在脸盲眼里所有人在和我创造共同回忆之前都是相似的，在相处中这些人才逐渐有了差别。而在共同回忆消失在时间里之后，他们也会逐渐泯灭为芸芸众生之一。</p>
<p>哪怕是认识她、与她相爱，乃至和她分手之后我依然这么想。</p>
<p>我爱她不是因为非她不可，我想。可能因为我从来没谈过恋爱，可能因为我孤独。恋爱没办法脱离情境考虑，恋爱从来不是什么“非你不可”的事情。</p>
<p>直到现在我与她已经分手三个月，脸盲症公平地吞噬所有逐渐生疏的面孔。</p>
<p>凌晨四点太阳还远远地在地平线后面。她穿着墨绿色的长裙，像是油画里的人。她点点头，我说“走吧”。</p>
<p>太阳还没升起来。我前一天突发奇想，想去实验楼顶看日出。</p>
<p>太阳升起来时我和她并肩仰头，她坐在楼梯上，墨绿色的裙摆垂下来。她的鼻子小小的，耳朵在朝阳中是近乎透明的红色。我觉得我爱她。</p>
<p>我的室友说“你要是约妹子看这个，你就是大傻子。”</p>
<p>我说：“但她同意了！”</p>
<p>那是个红色题材的话剧，学校话剧社出品，是每年固定上演的年度节目以至于免费送都没人看。但那场话剧确实很感人，而且她坐在我旁边。</p>
<p>——而且似乎她真的喜欢。</p>
<p>我们聊着那部话剧，聊着历史和现在。我讲了我在小城市里并不富裕但快乐的一家人，她谈起她高三时并不看好她乃至于打压她的变态老师。我们一路走回她的寝室楼下。</p>
<p>我和她自习，礼貌地隔了一张桌子。我觉得与其被她讨厌不如让她觉得我是个不解风情的钢铁直男。<br>自习之后我和她吃饭，她说随便，于是午饭是我选的。番茄黑鱼面，皎洁的鱼片在酸甜的番茄汤里沉浮。</p>
<p>她说：“如果不是和你，我可能永远不会尝试这个。”</p>
<p>我问：“你要不要考虑和我在一起？”</p>
<p>……</p>
<p>她说：“我们在一起试试吧。”</p>
<p>我买了一束玫瑰花，红色的，像平安夜的苹果。我送到她寝室楼下，她又一次下楼了。</p>
<p>我说：“明天考六级吧？——祝你顺利。”</p>
<p>她有点惊讶，但最后说：“好啊。”</p>
<p>我和她交换了课程表，于是我知道她会在哪个教室上哪一节通识课。我在那间教室的角落里坐着，一次又一次扫视整间教室。</p>
<p>她出现了。</p>
<p>“惊不惊喜？”我问。我坐在她旁边，就是旁边，中间没有隔着一个位置。</p>
<p>这就是校园恋爱的感觉吗，我想。我飘飘欲仙。<br>她问我：“你有时间吗？可以下楼吗？”</p>
<p>我兴冲冲地下了楼。</p>
<p>她说：“我们分手吧。”</p>
<p>那之后我消沉了半个月。我一天打8个小时的手机游戏，熄灯了就在黑暗中玩，手机屏幕的光照在我空白一片的脸上。我赶着主线任务的进度，体力没了就氪金，然后继续。今天的奖励刷完了也没关系，就算没有奖励我也会继续玩。</p>
<p>那时候是期末，考试周将近。</p>
<p>但我绝不会责怪她赶在考试周分手。我自己清楚，如果她不是在考试周分手或许我还不会这么消沉。我本来就没太学好，她的分手或许才正是给了我一个逃避的借口。</p>
<p>绝不是非她不可，她不是特殊的。</p>
<p>就像我突然沉迷手机游戏一样，突然有一天我再也没玩过。我疯狂复习，在期末面前开始垂死挣扎。我的好几科悬在挂科边缘摇摇欲坠，但最后奇迹般地稳住了。</p>
<p>不是因为她，因为那之后我和她再也没了联系。</p>
<p>考试周的最后一门课之后，我分手以来第一次打开和她的聊天框。我数了数我和她说过的早安和晚安。我笑出声。</p>
<p>其实我和她在一起，算上第一天的白天和最后一天的夜晚，满打满算不过九天功夫。</p>
<p>……为什么？从哪里出了问题？</p>
<p>去实验楼看日出那次纯属我临时起意，我之前没看过日出也没去过实验楼，以至于不知道最高的实验楼楼顶其实是上锁的。我们转了一大圈终于找到了楼顶的入口，却发现我们没有钥匙。那时候太阳已经快升起来了，晨光照着她的脸。她皱着眉头。</p>
<p>她说：“我们去低一点的楼吧。”</p>
<p>但低一点的楼同样楼顶上锁，学校为了防止大学生跳楼还真是不遗余力。最后我和她坐在通往顶层的楼道里看窗户外的日出，楼道里没有通风，蚊子极多，在她露出的小腿周围转悠。</p>
<p>但她在笑，我也假装为了日出的一切糟心事不存在。</p>
<p>在番茄鱼面前，我说：“你要不要考虑和我在一起？”</p>
<p>那之前我抓着室友喝酒，问他我该不该表白。我说我喜欢和她聊天，我担心分手之后连朋友都做不了。室友烦了，说喜欢你就去追啊，她肯定是喜欢你的。</p>
<p>她肯定是喜欢我的，但她的表情好像最后的审判即将到来。</p>
<p>她说：“对不起。”</p>
<p>我有点慌。我说：“你可以再考虑考虑，我不着急的。”</p>
<p>她说：“对不起。”</p>
<p>她的父母都是医生，虽然谈不上喜欢这个工作却兢兢业业地干了半辈子，哪怕生活一次又一次被随时可能响起的呼叫铃打散打碎。他们相亲相识相爱，在工作的间隙生下女儿，四年之后给女儿又添了一个弟弟。然后他们去工作了，让女儿照顾好自己。</p>
<p>女儿只能照顾好自己，同时照顾好更加无法自理的弟弟。</p>
<p>她尽力把自己照顾得很好，为自己建造起了坚实的壁垒。她自己做饭，自己打理家务，自己给弟弟开家长会。她和弟弟吵架，然后在父母回家之前假装无事发生。她独自面对打压她的变态老师，她知道如果父母介入应该能改变些什么。但她觉得没必要让他们介入。</p>
<p>她听见堡垒外面有人敲门。我说：“我可能没办法一直陪你。但我们为什么不试试呢？我会尽力的……”</p>
<p>她从内部打量着自己的堡垒，看着那些花了十几年搭起来的大梁，承载着厚厚的穹顶。如果有人想进来，她可以把穹顶的力量从大梁上卸一些下来。</p>
<p>但如果那个人又走了呢？</p>
<p>如果那个人走的时候，她还来不及把堡垒恢复原样呢？</p>
<p>我不知道从“对不起”到“我们在一起试试吧”之间的几天发生了什么。</p>
<p>但六级前的那个晚上和查好时间的那次通识课上，她已经走进了自己的堡垒，想要在那里度过一段安静的独处时光。</p>
<p>“我能进来吗？”有人在外面问。</p>
<p>她开了门。那人开心地左顾右盼，但她觉得那人格格不入。</p>
<p>“……如果，”我试着讨价还价，“如果我以后找你之前事先预约……我们还能在一起吗？”</p>
<p>她有点悲伤地看着我。她没戴金黄色的发带。</p>
<p>她说：“算了吧。”</p>
<p>她说了很多个“对不起”之后离开了的那天，我想我们不会这样结束。过几天就算她不来找我，我也要去找她。</p>
<p>她说了一个“算了吧”之后离开了的那天，我想我和她就这样结束了。</p>
<p>八个“早安”，八个“晚安”。我们在一起九天。</p>
<p>我还会想她，但我再也没有见过她。</p>
<p>……直到那天课间，我想不起来向我打招呼的女孩到底是不是她。</p>
<p>大学很大。我想。我和她没理由再见面。</p>
<p>世界很大。我想。我会遇见新的人。</p>
<p>想到向我打招呼的女孩可能是她之后我猛地一个扭头，差点扭到脖子。但那个人已经消失在了人群之中。</p>
<p>有那么一瞬间我完全相信那就是她，就在刚才冲我笑着问好。我几乎要马上掏出手机给她发消息，问她：“你还好吗？我刚才是不是看见了你？”</p>
<p>她会说“是啊，我还打招呼了呢。”</p>
<p>然后我会一发不可收拾。我会告诉她我最近看的电影，把我拍下来的花发给她看，吐槽乱提需求的蠢老师。我会犹豫自己是不是说得太多显得太热情，但那些东西就是像决堤一样喷涌而出。我不在乎她会怎么想，因为我只是孤独。孤独的人有任性的特权。</p>
<p>……不行，我不会那么做。我会道歉，说我第一次学着和人相处，承诺以后不会入侵她的私人领域，只在她想要支持时给她的堡垒搭一把手。我会说对不起让你不舒服了，但我经常想你，那之后我没遇见过和你一样好的人。以后我还可以和你做朋友、和你聊天吗？</p>
<p>然后我的理智回笼。我的脑子逐渐淡忘了向我打招呼的人和她的脸，将功补过地列出了从发梢到眼角的一条又一条证据说明两个人并不是同一个人。最后脑子一锤定音：你还有一节课呢，和她聊天是需要时间的。等有空再联系她吧。</p>
<p>我同意我脑子的观点。</p>
<p>但不甘心地补了一句：有空要去联系她啊。</p>
<p>那之后我去过她的宿舍楼下。正当理由是修车，一个假期之后再回到学校，我的自行车爆了胎，而她的宿舍楼下就有个修车棚。</p>
<p>我推车走进她的宿舍园区时，发现有大群学生在那里准备去开学典礼。我回想自己准备去开学典礼的时间，发现差不多正是一年之前。</p>
<p>我确信她就在乱哄哄挤在一起的学生之中。我们可能只隔了几米，她甚至可能已经注意到了推着车的我。但什么也没有发生。</p>
<p>“……你这车型号比较特别啊，”修车棚老板狡猾地笑了，“车胎贵一些。”</p>
<p>我说：“我知道哪里买。”</p>
<p>“那你去买啊。”老板不为所动。</p>
<p>我推着车走出去，放狠话说我还会回来的。</p>
<p>我在校外找到了另一家修车棚，老板要价便宜十块钱。我开开心心地省下了十块钱，买了一袋苹果，回到她楼下的修车棚，望着闹哄哄的学生们。</p>
<p>我没看到她。</p>
<p>但临走时我以她的宿舍楼为背景拍了一张照片，发了朋友圈：“我的自行车起死回生！”</p>
<p>我用力咀嚼艳红色的果皮，苹果汁在我的口腔里爆开。她上课时不看消息，她的朋友圈一片空白。我知道她不会看，我也知道自己还是会发。</p>
<p>我总会遇见一个合适的人，我想，想过很多遍。或许我不爱她，但她爱我，于是我慢慢地爱她。或许她不爱我，但我爱她，于是她慢慢地爱我。或许我们已经错过彼此足够长时间，但毕竟未来更长。说不定我甚至没记住她的脸，直到那张脸随着时间铭刻在我我的记忆里。或许我们一开始不合适，但最后总会合适。我们相爱，吵架，发现分开还不如在一起。我们结婚，吵架，觉得离婚太麻烦还不如凑合过。我们生孩子，吵架，发现剩下的时间还不如在一起的时间长。</p>
<p>一般初恋很难走到最后，因为初恋就是为了让你们互相伤害的。你知道了怎么被伤害，就不会伤害未来的其他人。</p>
<p>但我爱她的方式是我希望别人爱我的。我不知道我还能怎么爱。</p>
<p>一般人们放不下过去，因为回忆会给自己加上滤镜。过去说不定糟透了，但想起来时还是那么美好。</p>
<p>我还是想见她，但我已经认不出来她了。</p>
<p>第一节课是乒乓球，然后是物理课。运动之后总是容易睡着，我在自动售货机买了瓶柠檬汽水，带着汽水在教室里找了个位置。每次睡意漫上来，我就喝一口。</p>
<p>上个学期我特别喜欢这种汽水。不知道是不是换了配方，汽水这学期味道好像变了。刚开始的几口味道差不多，但越往后味道越奇怪，好像加水稀释过后又不知足地补上了三倍的二氧化碳。喝到最后我总觉得无法忍受，又为了不浪费食物强行喝完。这一罐也一样，喝到最后我猛灌一口，差点自己呛到自己。</p>
<p>下次不喝了，我想。</p>
<p>其实上次我也是这么想的。但今天看到售货机里熟悉的黄色罐子，我又想：说不定这次我就找到了上学期熟悉的感觉呢？</p>
<p>老师还算有良心，提前下了课。我跨上自行车，冲向食堂，胡乱打量着一路上经过的人。</p>
<p>——我突然看见了她。</p>
<p>操他妈的！我没想到我能一眼就认出来她。</p>
<p>我构思过如果哪天我骑着自行车从看见她在我前方的背影，我要怎么办。</p>
<p>我想，我要骑过她，直到她也能认出前面的我，却只能看着我远去。然后我要一歪车把，摔倒在她面前，不管车筐里的东西会不会洒了一地，像是那天金黄色的银杏树叶。我会手忙脚乱地把那些东西捡起来，她会犹豫几秒之后和我一起捡。我们的手指会相互避开。最后我们站起来，我会低头看她，告诉她我很想她。</p>
<p>但我从来没见过她的背影。可能没遇见过，可能遇见了没认出来。</p>
<p>但我一眼就认出了她。一米五，背着沉重的书包步行，抿着嘴唇。她的头发像我记忆中那样扎成马尾，发梢像我记忆中那样有染过棕色的遗迹。她低着头，但那张脸和我记忆中一模一样。</p>
<p>她一点都没变。</p>
<p>我能认出来她。不仅如此，我还能遇见她——这么大的学校，我能再遇见她。</p>
<p>我的自行车遵循着惯性向前。她低着头，她没看见我。</p>
<p>或许这是命运女神给我的机会。</p>
<p>我骑过去，骑过她。</p>
<p>我想：我刚喝了柠檬汽水，现在嘴里还有酸味，不合适。</p>
<p>下次遇见她，我会说的。</p>
<p>2021.10.29</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理Assignment2</title>
    <url>/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<p>浙大的图像信息处理，一门奇妙的课程，老师上课吹水摸鱼，网上的资源也十分不集中。故在此开设专题作为图像信息处理作业的一个分享，请善用博客搜索功能。</p>
<span id="more"></span>
<h2 id="Assignment-2作业要求"><a href="#Assignment-2作业要求" class="headerlink" title="Assignment-2作业要求"></a>Assignment-2作业要求</h2><ul>
<li>Image binarization</li>
<li>Binary image erosion</li>
<li>Binary image dilation</li>
<li>Binary image opening</li>
<li>Binary image closing</li>
</ul>
<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="图像二值化"><a href="#图像二值化" class="headerlink" title="图像二值化"></a>图像二值化</h3><p>读取一张<code>.bmp</code>图像将其转换位二值图像，首先我们需要在C语言中定义图像信息结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> bfType;        <span class="comment">// 19778，必须是BM字符串，对应的十六进制为0x4d42,十进制为19778，否则不是bmp格式文件</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   bfSize;        <span class="comment">// 文件大小 以字节为单位(2-5字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> bfReserved1;   <span class="comment">// 保留，必须设置为0 (6-7字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> bfReserved2;   <span class="comment">// 保留，必须设置为0 (8-9字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   bfOffBits;     <span class="comment">// 从文件头到像素数据的偏移  (10-13字节)</span></span><br><span class="line">&#125; BITMAPHEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biSize;          <span class="comment">// 此结构体的大小 (14-17字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biWidth;         <span class="comment">// 图像的宽  (18-21字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biHeight;        <span class="comment">// 图像的高  (22-25字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  biPlanes;        <span class="comment">// 表示bmp图片的平面属，显然显示器只有一个平面，所以恒等于1 (26-27字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  biBitCount;      <span class="comment">// 一像素所占的位数，一般为24   (28-29字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biCompression;   <span class="comment">// 说明图象数据压缩的类型，0为不压缩。 (30-33字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biSizeImage;     <span class="comment">// 像素数据所占大小, 这个值应该等于上面文件头结构中bfSize-bfOffBits (34-37字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biXPelsPerMeter; <span class="comment">// 说明水平分辨率，用象素/米表示。一般为0 (38-41字节)</span></span><br><span class="line">    <span class="keyword">long</span>            biYPelsPerMeter; <span class="comment">// 说明垂直分辨率，用象素/米表示。一般为0 (42-45字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biClrUsed;       <span class="comment">// 说明位图实际使用的彩色表中的颜色索引数（设为0的话，则说明使用所有调色板项）。 (46-49字节)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    biClrImportant;  <span class="comment">// 说明对图象显示有重要影响的颜色索引的数目，如果是0，表示都重要。(50-53字节)</span></span><br><span class="line">&#125; BITMAPINFOHEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbBlue;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbGreen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbRed;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>    rgbReserved;</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure>
<p>然后进行图像头结构的读取与判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* bmpfile = <span class="built_in">fopen</span>(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">BITMAPHEADER* header = <span class="keyword">new</span> BITMAPHEADER;</span><br><span class="line">BITMAPINFOHEADER* info = <span class="keyword">new</span> BITMAPINFOHEADER;</span><br><span class="line"><span class="keyword">if</span> (!bmpfile) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fread</span>(header, <span class="number">14</span>, <span class="number">1</span>, bmpfile);</span><br><span class="line"><span class="keyword">if</span> (header-&gt;bfType != <span class="number">0x4D42</span>) &#123; <span class="comment">//判断是否为bmp图像</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not a bitmap file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fread</span>(info, <span class="built_in"><span class="keyword">sizeof</span></span>(BITMAPINFOHEADER), <span class="number">1</span>, bmpfile);</span><br></pre></td></tr></table></figure>
<p>赋值计算单行像素数量<code>lineBytes</code>并读取像素信息，注意由于<code>.bmp</code>文件单行像素一定是4的整倍数，因此需要补齐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> imSize = info-&gt;biSize;</span><br><span class="line"><span class="keyword">int</span> width = info-&gt;biWidth;</span><br><span class="line"><span class="keyword">int</span> height = info-&gt;biHeight;</span><br><span class="line"><span class="keyword">int</span> bitCount = info-&gt;biBitCount;</span><br><span class="line"><span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;  <span class="comment">//一行的byte数，四位补齐</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* imgData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line"><span class="built_in">fread</span>(imgData, lineBytes * height, <span class="number">1</span>, bmpfile);</span><br><span class="line"><span class="built_in">fclose</span>(bmpfile);</span><br></pre></td></tr></table></figure>
<p>在读取图像之后计算其灰度值，此时我们用$YUV$格式转换中的$Y$值表示灰度，转换公式如下</p>
<script type="math/tex; mode=display">
Y=0.299*R+0.587*G+0.114*B</script><p>由于$RGB$格式的大小是灰度图像的三倍，因此在创建灰度数据时要除以三再赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* biData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height / <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++)&#123; <span class="comment">//对于每一行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width * <span class="number">3</span>; j++)&#123; <span class="comment">//对于每一列</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> r = *(imgData + lineBytes * (height - <span class="number">1</span> - i) + j); <span class="comment">//从最后一行往上读</span></span><br><span class="line">		j++;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> g = *(imgData + lineBytes * (height - <span class="number">1</span> - i) + j);</span><br><span class="line">		j++;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">char</span> b = *(imgData + lineBytes * (height - <span class="number">1</span> - i) + j);</span><br><span class="line">		*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j / <span class="number">3</span>) = <span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">//完成灰度转换</span></span><br></pre></td></tr></table></figure>
<p>然后是二值化图像阈值的确定，根据课上内容我们可以知道，我们需要确定前景和背景然后让其组内方差最小且组间方差最大，这就是所谓<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%B4%A5%E7%AE%97%E6%B3%95"><strong>大津算法</strong></a>，链接中有通过直方图的C语言实现，可以作为补充阅读，我们这里使用与<a href="http://www.opencv.org/">OpenCV</a>相类似的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">otsuThreshold</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* biData, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> lineBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> GrayScale = <span class="number">256</span>; <span class="comment">//256级灰度</span></span><br><span class="line">    <span class="keyword">int</span> pixelCount[GrayScale] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> pixelPro[GrayScale] = &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> threshold = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;  <span class="comment">//统计每个灰度在像素中的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            ++pixelCount[(<span class="keyword">int</span>)*(biData + lineBytes * i + j)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; GrayScale; i++) &#123;  <span class="comment">//计算每个像素所占比例</span></span><br><span class="line">        pixelPro[i] = (<span class="keyword">double</span>)pixelCount[i] / (width * height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> w0, w1, u0tmp, u1tmp, u0, u1, u, deltaTmp, deltaMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; GrayScale; i++) &#123;</span><br><span class="line">        w0 = w1 = u0tmp = u1tmp = u0 = u1 = u = deltaTmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; GrayScale; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt;= i) &#123;  <span class="comment">//背景</span></span><br><span class="line">                w0 += pixelPro[j];</span><br><span class="line">                u0tmp += j * pixelPro[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">//前景</span></span><br><span class="line">                w1 += pixelPro[j];</span><br><span class="line">                u1tmp += j * pixelPro[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  <span class="comment">//计算组间方差</span></span><br><span class="line">        u0 = u0tmp / w0;</span><br><span class="line">        u1 = u1tmp / w1;</span><br><span class="line">        u = u0tmp + u1tmp;</span><br><span class="line">        deltaTmp = w0 * <span class="built_in">pow</span>((u0 - u), <span class="number">2</span>) + w1 * <span class="built_in">pow</span>((u1 - u), <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (deltaTmp &gt; deltaMax) &#123;</span><br><span class="line">            deltaMax = deltaTmp;</span><br><span class="line">            threshold = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确定了阈值后就可以进行二值化了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> threshold = <span class="built_in">otsuThreshold</span>(biData, width, height, lineBytes / <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++)&#123; <span class="comment">//对于每一行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++)&#123; <span class="comment">//对于每一列</span></span><br><span class="line">		<span class="keyword">if</span> (*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) &gt;= threshold)</span><br><span class="line">			*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = <span class="number">255</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  <span class="comment">//完成二值化转换</span></span><br></pre></td></tr></table></figure>
<p>处理完数据后就可以写入二值文件了，首先是定义头文件和颜色表，然后写入数据即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* biBMP = <span class="built_in">fopen</span>(<span class="string">&quot;bi.bmp&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> lineBytesBi = (width * <span class="number">8</span> / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (!biBMP) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">BITMAPHEADER* biHeader = <span class="keyword">new</span> BITMAPHEADER;</span><br><span class="line">biHeader-&gt;bfType = <span class="number">0x4D42</span>;</span><br><span class="line">biHeader-&gt;bfSize = <span class="number">14</span> + <span class="number">40</span> + <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD) * <span class="number">256</span> + lineBytesBi * height;</span><br><span class="line">biHeader-&gt;bfReserved1 = <span class="number">0</span>;</span><br><span class="line">biHeader-&gt;bfReserved2 = <span class="number">0</span>;</span><br><span class="line">biHeader-&gt;bfOffBits = <span class="number">14</span> + <span class="number">40</span> + <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD) * <span class="number">256</span>;</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfType, <span class="number">2</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfSize, <span class="number">4</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved1, <span class="number">2</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved2, <span class="number">2</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfOffBits, <span class="number">4</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"></span><br><span class="line">BITMAPINFOHEADER* biInfoHeader = <span class="keyword">new</span> BITMAPINFOHEADER;</span><br><span class="line">biInfoHeader-&gt;biBitCount = <span class="number">8</span>;</span><br><span class="line">biInfoHeader-&gt;biClrImportant = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biClrUsed = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biCompression = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biHeight = height;</span><br><span class="line">biInfoHeader-&gt;biWidth = width;</span><br><span class="line">biInfoHeader-&gt;biPlanes = <span class="number">1</span>;</span><br><span class="line">biInfoHeader-&gt;biSize = <span class="number">40</span>;</span><br><span class="line">biInfoHeader-&gt;biSizeImage = lineBytesBi * height;</span><br><span class="line">biInfoHeader-&gt;biXPelsPerMeter = <span class="number">0</span>;</span><br><span class="line">biInfoHeader-&gt;biYPelsPerMeter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">fwrite</span>(biInfoHeader, <span class="number">40</span>, <span class="number">1</span>, biBMP);</span><br><span class="line"></span><br><span class="line">RGBQUAD* pColorTable = <span class="keyword">new</span> RGBQUAD[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    pColorTable[i].rgbRed = i;</span><br><span class="line">    pColorTable[i].rgbGreen = i;</span><br><span class="line">    pColorTable[i].rgbBlue = i; <span class="comment">//是颜色表里的B、G、R分量都相等，且等于索引值</span></span><br><span class="line">    pColorTable[i].rgbReserved = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fwrite</span>(pColorTable, <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD), <span class="number">256</span>, biBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(biData, lineBytesBi * height, <span class="number">1</span>, biBMP);</span><br><span class="line"><span class="built_in">fclose</span>(biBMP);</span><br></pre></td></tr></table></figure>
<p>最终效果<br><img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/gouldian_finch.bmp" class="" title="This is the original image"><br><img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/bi.bmp" class="" title="This is the binary image"></p>
<h3 id="二值化图像腐蚀"><a href="#二值化图像腐蚀" class="headerlink" title="二值化图像腐蚀"></a>二值化图像腐蚀</h3><p>图像腐蚀，常用于使目标缩小，去除图像边界或者去除不想要的小物体（例如减噪等操作），计算方法为</p>
<script type="math/tex; mode=display">
A\ominus B=\{(x,y)\vert(B)_{xy}\subseteq A\}</script><p>其中$A$是二值化图像，$B$是腐蚀领域</p>
<p>具体操作就是用一个结构元素$B$(一般是3×3的大小)扫描图像$A$中的每一个像素，用结构元素中的每一个像素与其覆盖的像素做“与”操作，如果都为1，则该像素为1，否则为0</p>
<p>我们采用遍历与运算进行实现，此时</p>
<script type="math/tex; mode=display">
B=
\begin{bmatrix}0 & 1 & 0\\ 1 & 1 & 1 \\ 0 & 1 & 0\end{bmatrix}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="title">imgErosion</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* biData, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> lineBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* tempData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* eroData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="built_in">memcpy</span>(tempData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(eroData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(tempData + i * lineBytes + j) == <span class="number">0</span> || *(tempData + (i<span class="number">-1</span>) * lineBytes + j) == <span class="number">0</span> ||</span><br><span class="line">                *(tempData + (i+<span class="number">1</span>) * lineBytes + j) == <span class="number">0</span> || *(tempData + i * lineBytes + j+<span class="number">1</span>) == <span class="number">0</span> ||</span><br><span class="line">                *(tempData + i * lineBytes + j<span class="number">-1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                *(eroData + i * lineBytes + j) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                *(eroData + i * lineBytes + j) = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">delete</span></span>(tempData);</span><br><span class="line">    <span class="keyword">return</span> eroData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/ero.bmp" class="" title="This is the erosion image">
<h3 id="二值化图像膨胀"><a href="#二值化图像膨胀" class="headerlink" title="二值化图像膨胀"></a>二值化图像膨胀</h3><p>图像膨胀，常用于使目标增大，增粗字体，填补空洞，计算方法为</p>
<script type="math/tex; mode=display">
A\oplus B=\{z\vert(B)_z\cap A\neq\emptyset\}</script><p>其中$A$是二值化图像，$B$是膨胀领域</p>
<p>具体操作就是用一个结构元素(一般是3×3的大小)扫描图像中的每一个像素，用结构元素中的每一个像素与其覆盖的像素做“与”操作，如果都为0，则该像素为0，否则为1</p>
<p>由此可见膨胀和腐蚀其实是对称的运算，因此我们可以将两个运算合并在一起，此时</p>
<script type="math/tex; mode=display">
B=
\begin{bmatrix}0 & 1 & 0\\ 1 & 1 & 1 \\ 0 & 1 & 0\end{bmatrix}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="title">imgEroDila</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* biData, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> lineBytes, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* tempData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* rtnData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height];</span><br><span class="line">    <span class="keyword">int</span> p = (flag == <span class="number">1</span>) ? <span class="number">255</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(tempData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(rtnData, biData, lineBytes * height * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; width - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(tempData + i * lineBytes + j) == p || *(tempData + (i<span class="number">-1</span>) * lineBytes + j) == p ||</span><br><span class="line">                *(tempData + (i+<span class="number">1</span>) * lineBytes + j) == p || *(tempData + i * lineBytes + j+<span class="number">1</span>) == p ||</span><br><span class="line">                *(tempData + i * lineBytes + j<span class="number">-1</span>) == p) &#123;</span><br><span class="line">                *(rtnData + i * lineBytes + j) = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                *(rtnData + i * lineBytes + j) = <span class="number">255</span> - p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">delete</span></span>(tempData);</span><br><span class="line">    <span class="keyword">return</span> rtnData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/dila.bmp" class="" title="This is the dilation image">
<h3 id="二值化图像开运算"><a href="#二值化图像开运算" class="headerlink" title="二值化图像开运算"></a>二值化图像开运算</h3><p>开运算是先腐蚀后膨胀的过程，它可以消除图像上的细小噪声并平滑边界</p>
<p>有了上述的铺垫，我们可以很快的完成开运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* openBMP = <span class="built_in">fopen</span>(<span class="string">&quot;open.bmp&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfType, <span class="number">2</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfSize, <span class="number">4</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved1, <span class="number">2</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved2, <span class="number">2</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfOffBits, <span class="number">4</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(biInfoHeader, <span class="number">40</span>, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(pColorTable, <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD), <span class="number">256</span>, openBMP);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* openData = <span class="built_in">imgEroDila</span>(biData, width, height, lineBytesBi, <span class="number">0</span>);</span><br><span class="line">openData = <span class="built_in">imgEroDila</span>(openData, width, height, lineBytesBi, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(openData, lineBytesBi * height, <span class="number">1</span>, openBMP);</span><br><span class="line"><span class="built_in">fclose</span>(openBMP);</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/open.bmp" class="" title="This is the open image">
<h3 id="二值化图像闭运算"><a href="#二值化图像闭运算" class="headerlink" title="二值化图像闭运算"></a>二值化图像闭运算</h3><p>闭运算是先膨胀后腐蚀，它可以填充细小空洞并平滑边界</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* closeBMP = <span class="built_in">fopen</span>(<span class="string">&quot;close.bmp&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfType, <span class="number">2</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfSize, <span class="number">4</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved1, <span class="number">2</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfReserved2, <span class="number">2</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(&amp;biHeader-&gt;bfOffBits, <span class="number">4</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(biInfoHeader, <span class="number">40</span>, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fwrite</span>(pColorTable, <span class="built_in"><span class="keyword">sizeof</span></span>(RGBQUAD), <span class="number">256</span>, closeBMP);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* closeData = <span class="built_in">imgEroDila</span>(biData, width, height, lineBytesBi, <span class="number">1</span>);</span><br><span class="line">closeData = <span class="built_in">imgEroDila</span>(closeData, width, height, lineBytesBi, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">fwrite</span>(closeData, lineBytesBi * height, <span class="number">1</span>, closeBMP);</span><br><span class="line"><span class="built_in">fclose</span>(closeBMP);</span><br></pre></td></tr></table></figure>
<p>效果如下</p>
<img src="/2021/10/30/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A/close.bmp" class="" title="This is the close image">
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是图像信息处理的第二次作业，总的来说还是比较简单方便的，按照ppt上的说法一步一步来就能得出结果</p>
<p>希望这篇博文能够帮到你完成这次作业</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理作业Assignment3</title>
    <url>/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/</url>
    <content><![CDATA[<p>第三次图像信息处理作业解析，这次要对直方图动手了。</p>
<span id="more"></span>
<h2 id="Assignment-3作业要求"><a href="#Assignment-3作业要求" class="headerlink" title="Assignment-3作业要求"></a>Assignment-3作业要求</h2><ul>
<li>Image logarithmic operation for visibility enhancement</li>
<li>Histogram equalization<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="图像对数强化"><a href="#图像对数强化" class="headerlink" title="图像对数强化"></a>图像对数强化</h3></li>
</ul>
<p>这玩意儿老师上课貌似没讲，检索了一下大概就是通过如下的公式进行操作</p>
<script type="math/tex; mode=display">
S=c\times\log(1+r) \\
where,\qquad\qquad\qquad\\ S=\text{output pixel value} \\
C=\text{scaling constant} \\
R=\text{input pixel value}\\</script><p>在这里，我们定义如下的常数$C$</p>
<script type="math/tex; mode=display">
C=\frac{255}{\log(1+\text{max input pixel value})}</script><p>通过加一我们可以保证所有的$C$和$S$是非负数</p>
<p>首先先求出$C$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* max;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> data = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j);</span><br><span class="line">        max = max &gt; data ? max : data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> c = <span class="number">255.0</span> / (<span class="built_in">log</span>(<span class="number">1</span> + max));</span><br></pre></td></tr></table></figure>
<p>然后代入公式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* logData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height / <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> r = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j)</span><br><span class="line">        *(logData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = c * <span class="built_in">log</span>(<span class="number">1</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就获得了log后的图像</p>
<img src="/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/gray.bmp" class="" title="This is the gray image">
<img src="/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/log.bmp" class="" title="This is the log image">
<h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>考虑一个离散的灰度图像$x$，让$n_i$ 表示灰度$i$出现的次数，这样图像中灰度为$i$的像素的出现概率是</p>
<script type="math/tex; mode=display">
\ p_x(i) = p(x=i) = \frac{n_i}{n},\quad 0 \le i < L</script><p>$L$ 是图像中所有的灰度数（通常为256），$n$ 是图像中所有的像素数，$p_x(i)$实际上是像素值为$i$的图像的直方图，归一化到 [0,1]。</p>
<p>把对应于$p_x$的累积分布函数，定义为：</p>
<script type="math/tex; mode=display">
\ cdf_x(i) = \sum_{j=0}^i p_x(j),</script><p>是图像的累计归一化直方图。</p>
<p>我们创建一个形式为$ y= T(x)$ 的变换，对于原始图像中的每个值它就产生一个$y$，这样 $y$的累计概率函数就可以在所有值范围内进行线性化，转换公式定义为：</p>
<script type="math/tex; mode=display">
\ cdf_y(i) = iK</script><p>对于常数$K$。CDF的性质允许我们做这样的变换（参见逆分布函数）；定义为</p>
<script type="math/tex; mode=display">
\ cdf_y(y^\prime) = cdf_y(T(k)) = cdf_x(k)</script><p>其中$k$属于区间 [0,L)。注意 T 将不同的等级映射到${0..1}$​域，为了将这些值映射回它们最初的域，需要在结果上应用下面的简单变换：</p>
<script type="math/tex; mode=display">
\ y^\prime = y \cdot(\max\{x\} - \min\{x\}) + \min\{x\}</script><p>上面描述了灰度图像上使用直方图均衡化的方法，但是通过将这种方法分别用于图像RGB颜色值的红色、绿色和蓝色分量，从而也可以对彩色图像进行处理。</p>
<p>首先，我们需要先得到直方图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* histData = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[lineBytes * height / <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> hist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, eqHist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = height * width;</span><br><span class="line"><span class="keyword">double</span> fpHist[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, eqHistTemp[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123; <span class="comment">//计算直方图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> GrayIndex = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j);</span><br><span class="line">        hist[GrayIndex]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们计算灰度分布和累计直方图分布</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123; <span class="comment">//计算灰度分布密度</span></span><br><span class="line">    fpHist[i] = (<span class="keyword">double</span>)hist[i] / (<span class="keyword">double</span>)size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123; <span class="comment">//计算累计直方图分布</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        eqHistTemp[i] = fpHist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        eqHistTemp[i] = eqHistTemp[i - <span class="number">1</span>] + fpHist[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以直接得出映射关系</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//累计分布取整，保存计算出来的灰度映射关系</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    eqHist[i] = (<span class="keyword">int</span>)(<span class="number">255.0</span> * eqHistTemp[i] + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123; <span class="comment">//进行灰度映射均衡化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> GrayIndex = *(biData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j);</span><br><span class="line">        *(histData + lineBytes * (height - <span class="number">1</span> - i) / <span class="number">3</span> + j) = eqHist[GrayIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如图</p>
<img src="/2021/11/13/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A2/hist.bmp" class="" title="This is the log image">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说这次作业依然是十分的宁静祥和、简单质朴，不过在直方图均衡化的部分由于不太了解细节，因此借鉴了部分代码，写作风格也十分的奇妙，希望多多包含。</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理作业Assignment4</title>
    <url>/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/</url>
    <content><![CDATA[<p>第四次图像信息处理作业解析，这次是图像仿射变换呢。</p>
<span id="more"></span>
<h2 id="Assignment-4作业要求"><a href="#Assignment-4作业要求" class="headerlink" title="Assignment-4作业要求"></a>Assignment-4作业要求</h2><ul>
<li><p>Translation</p>
</li>
<li><p>Rotation</p>
</li>
<li><p>Scale</p>
</li>
<li><p>Shear</p>
</li>
<li><p>Mirror</p>
</li>
</ul>
<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="仿射变换简介"><a href="#仿射变换简介" class="headerlink" title="仿射变换简介"></a>仿射变换简介</h3><p>图像上的仿射变换, 其实就是图片中的一个像素点，通过某种变换，移动到另外一个地方</p>
<p>从数学上来讲， 就是一个向量空间进行一次线形变换并加上平移向量， 从而变换到另外一个向量空间的过程</p>
<p>向量空间$\vec{m}$:</p>
<script type="math/tex; mode=display">
\vec{m}=(x,y)</script><p>向量空间$\vec{n}$ :</p>
<script type="math/tex; mode=display">
\vec{n}=(x′,y′)</script><p>向量空间从$\vec{m}$到$\vec{n}$的变换 $\vec{n}=A\vec{m}+\vec{b}$<br>整理得到:</p>
<script type="math/tex; mode=display">
x′=A_{00}∗x+A_{01}∗y+b_{0} \\
y′=A_{10}∗x+A_{11}∗y+b_{1}</script><p>将A跟b 组合在一起就组成了仿射矩阵 $M$。 它的维度是$2∗3$</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} A_{00} & A_{01} & b_{0} \\A_{10} & A_{11} & b_{1}\end{bmatrix}</script><p>使用不同的矩阵$M$就获得了不同的2D仿射变换效果。</p>
<h3 id="图像平移"><a href="#图像平移" class="headerlink" title="图像平移"></a>图像平移</h3><p>可以说是最简单的空间变换，其矩阵$M$为</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} 1 & 0 & b_{0} \\0 & 1 & b_{1} \\ 0 & 0 & 1\end{bmatrix}</script><p>因此，我们可以很快地写出代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgTranslation</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">int</span> x0, <span class="keyword">int</span> y0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytesOriginal = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> lineBytesTranslated = (bitCount * (width + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(x0)) / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* transData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesTranslated * (height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0))]&#123;&#125;;</span><br><span class="line">    y0 = y0 &gt; <span class="number">0</span> ? y0 : <span class="number">0</span>;</span><br><span class="line">    x0 = x0 &gt; <span class="number">0</span> ? x0 : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width * <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">            *(transData + (i + y0) * lineBytesTranslated + j - <span class="number">2</span> + x0 * <span class="number">3</span>) = r;</span><br><span class="line">            *(transData + (i + y0) * lineBytesTranslated + j - <span class="number">1</span> + x0 * <span class="number">3</span>) = g;</span><br><span class="line">            *(transData + (i + y0) * lineBytesTranslated + j + x0 * <span class="number">3</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意变化后<code>bmp</code>文件的<code>header</code>也需要同步变换，在这里给出变化后的<code>header</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BITMAPHEADER* Header = <span class="keyword">new</span> BITMAPHEADER;</span><br><span class="line">Header-&gt;bfType = <span class="number">0x4D42</span>;</span><br><span class="line">Header-&gt;bfSize = <span class="number">14</span> + <span class="number">40</span> + lineBytesTranslated * (height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0));</span><br><span class="line">Header-&gt;bfReserved1 = <span class="number">0</span>;</span><br><span class="line">Header-&gt;bfReserved2 = <span class="number">0</span>;</span><br><span class="line">Header-&gt;bfOffBits = <span class="number">14</span> + <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">BITMAPINFOHEADER* InfoHeader = <span class="keyword">new</span> BITMAPINFOHEADER;</span><br><span class="line">InfoHeader-&gt;biBitCount = <span class="number">24</span>;</span><br><span class="line">InfoHeader-&gt;biClrImportant = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biClrUsed = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biCompression = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biHeight = height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0);</span><br><span class="line">InfoHeader-&gt;biWidth = width + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(x0);</span><br><span class="line">InfoHeader-&gt;biPlanes = <span class="number">1</span>;</span><br><span class="line">InfoHeader-&gt;biSize = <span class="number">40</span>;</span><br><span class="line">InfoHeader-&gt;biSizeImage = lineBytesTranslated * (height + (<span class="keyword">int</span>)<span class="built_in">fabs</span>(y0));</span><br><span class="line">InfoHeader-&gt;biXPelsPerMeter = <span class="number">0</span>;</span><br><span class="line">InfoHeader-&gt;biYPelsPerMeter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>向右上平移100像素的效果如图</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/translation.bmp" class="" title="This is the translated image">
<h3 id="图像旋转"><a href="#图像旋转" class="headerlink" title="图像旋转"></a>图像旋转</h3><p>通过数学推导，我们可以发现，旋转的矩阵$M$如下</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} \cos(\theta) & -\sin(\theta) & 0 \\ \sin(\theta) & \cos(\theta) & 0 \\ 0 & 0 & 1\end{bmatrix}</script><p>这里的$\theta$就是旋转的角度，但是很明显这里是以$(0, 0)$为基础进行的旋转，因此我们需要将我们想要的中心点平移至$(0,0)$再平移回来，即</p>
<script type="math/tex; mode=display">
\begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} = M_{translation}^{-1}(M_{rotation}(M_{translation} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}))</script><p>其中</p>
<script type="math/tex; mode=display">
M_{translation}=\begin{bmatrix} 1 & 0 & -c_x \\ 0 & 1 & -c_y \\ 0 & 0 & 1\end{bmatrix} \\
M_{rotation}=\begin{bmatrix} \cos(\theta) & -\sin(\theta) & 0 \\ \sin(\theta) & \cos(\theta) & 0 \\ 0 & 0 & 1\end{bmatrix}</script><p>因此，我们可以推导出$M$有</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} \cos(\theta) & -\sin(\theta) & (1-\cos(\theta))*c_x+\sin(\theta)*c_y \\ \sin(\theta) & \cos(\theta) & -\sin(\theta)*c_x+(1-\cos(\theta))*c_y \\ 0 & 0 & 1\end{bmatrix}</script><p>在代码实现部分，我们需要先确定四个角上的像素坐标，然后再将其规化全为正</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> radian = theta * PI / <span class="number">180.0</span>;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">4</span>], y[<span class="number">4</span>], cx = *width / <span class="number">2</span>, cy = *height / <span class="number">2</span>, xMax = <span class="number">0</span>, xMin = <span class="number">0</span>, yMax = <span class="number">0</span>, yMin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; *height + <span class="number">1</span>; i += *height) &#123;                           <span class="comment">//计算四个顶点的xy值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; *width + <span class="number">1</span>; j += *width) &#123;</span><br><span class="line">        x[i / *width + j / *height] = j * <span class="built_in">cos</span>(radian) - i * <span class="built_in">sin</span>(radian) + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cx + <span class="built_in">sin</span>(radian) * cy;</span><br><span class="line">        xMax = xMax &gt; x[i / *width + j / *height] ? xMax : x[i / *width + j / *height];</span><br><span class="line">        xMin = xMin &gt; x[i / *width + j / *height] ? x[i / *width + j / *height] : xMin;</span><br><span class="line">        y[i / *width + j / *height] = j * <span class="built_in">sin</span>(radian) + i * <span class="built_in">cos</span>(radian) - <span class="built_in">sin</span>(radian) * cx + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cy;</span><br><span class="line">        yMax = yMax &gt; y[i / *width + j / *height] ? yMax : y[i / *width + j / *height];</span><br><span class="line">        yMin = yMin &gt; y[i / *width + j / *height] ? y[i / *width + j / *height] : yMin;        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以以此来创建新的宽高的图像，然后根据矩阵一一对应</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> newHeight = yMax - yMin, newWidth = xMax - xMin;                      <span class="comment">//得到新尺寸</span></span><br><span class="line"><span class="keyword">int</span> lineBytesRotated = (bitCount * newWidth / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> lineBytesOriginal = (bitCount * *width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">uint8_t</span>* rotaData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesRotated * newHeight]&#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; *height; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; *width * <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytesOriginal + j);</span><br><span class="line">        <span class="keyword">int</span> x = j / <span class="number">3</span> * <span class="built_in">cos</span>(radian) - i * <span class="built_in">sin</span>(radian) + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cx + <span class="built_in">sin</span>(radian) * cy - xMin;</span><br><span class="line">        <span class="keyword">int</span> y = j / <span class="number">3</span> * <span class="built_in">sin</span>(radian) + i * <span class="built_in">cos</span>(radian) - <span class="built_in">sin</span>(radian) * cx + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cy - yMin;</span><br><span class="line">        *(rotaData + y * lineBytesRotated + x * <span class="number">3</span>) = r;</span><br><span class="line">        *(rotaData + y * lineBytesRotated + x * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">        *(rotaData + y * lineBytesRotated + x * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*height = newHeight;</span><br><span class="line">*width = newWidth;</span><br><span class="line"><span class="keyword">return</span> rotaData;</span><br></pre></td></tr></table></figure>
<p>逆时针旋转45度后效果如图</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/rotation.bmp" class="" title="This is the rotated image">
<p>可以看到图片上有很多黑点，这是因为像素旋转过程中我们舍弃了部分精度导致的，因此我们需要进一步进行插值算法，而插值的方法有很多，我们在这里选择双线性插值</p>
<h3 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h3><p>双线性插值利用旋转后图像中的点在原图所对应点周围四个点的数值，在两个方向分别进行线性插值来得到</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/bilinear.png" class="">
<p>记这四个点分别为$Q_{ij}(i,j=1,2)$，先对x轴方向做两次线性插值得到函数在$R_1$和$R_2$上的值，再对$R_1$和$R_2$做$y$轴方向的线性插值得到函数在所求点的值</p>
<script type="math/tex; mode=display">
f(P)=\frac{(y_2-y)(x_2-x)}{(y_2-y_1)(x_2-x_1)}f(Q_{11})+\frac{(y_2-y)(x-x_1)}{(y_2-y_1)(x_2-x_1)}f(Q_{21})+\frac{(y-y_1)(x_2-x)}{(y_2-y_1)(x_2-x_1)}f(Q_{12})+\frac{(y-y_1)(x-x_1)}{(y_2-y_1)(x_2-x_1)}f(Q_{22})</script><p>而对于旋转的图像，我们先对其变换矩阵$M$求逆运算，其实旋转矩阵的逆即是旋转矩阵的转置，因此</p>
<script type="math/tex; mode=display">
M^{-1}=\begin{bmatrix}\cos(\theta) & \sin(\theta) & (1-\cos(\theta))*c_x-\sin(\theta)*c_y \\ -\sin(\theta) & \cos(\theta) & \sin(\theta)*c_x+(1-\cos(\theta))*c_y \\ 0 & 0 & 1\end{bmatrix}</script><p>由此我们可以开始插值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newHeight; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newWidth; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(rotaData + i * lineBytesRotated + j * <span class="number">3</span>) == <span class="number">0</span> &amp;&amp; *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = j + xMin, y = i + yMin;</span><br><span class="line">            <span class="keyword">double</span> ox = x * <span class="built_in">cos</span>(radian) + y * <span class="built_in">sin</span>(radian) + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cx - <span class="built_in">sin</span>(radian) * cy;</span><br><span class="line">            <span class="keyword">double</span> oy = x * -<span class="built_in">sin</span>(radian) + y * <span class="built_in">cos</span>(radian) + <span class="built_in">sin</span>(radian) * cx + (<span class="number">1</span> - <span class="built_in">cos</span>(radian)) * cy;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">floor</span>(ox) &gt;=<span class="number">0.0</span> &amp;&amp; <span class="built_in">floor</span>(oy) &gt;=<span class="number">0.0</span> &amp;&amp; <span class="built_in">ceil</span>(ox) &lt; *width &amp;&amp; <span class="built_in">ceil</span>(oy) &lt; *height) &#123;</span><br><span class="line">                <span class="keyword">int</span> x[<span class="number">2</span>], y[<span class="number">2</span>];</span><br><span class="line">                x[<span class="number">0</span>] = <span class="built_in">floor</span>(ox); x[<span class="number">1</span>] = <span class="built_in">ceil</span>(ox);</span><br><span class="line">                y[<span class="number">0</span>] = <span class="built_in">floor</span>(oy); y[<span class="number">1</span>] = <span class="built_in">ceil</span>(oy);</span><br><span class="line">                <span class="keyword">uint8_t</span> r = (y[<span class="number">1</span>] - oy) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal) + </span><br><span class="line">                            (y[<span class="number">1</span>] - oy) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal);</span><br><span class="line">                <span class="keyword">uint8_t</span> g = (y[<span class="number">1</span>] - oy) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">1</span>) + </span><br><span class="line">                            (y[<span class="number">1</span>] - oy) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">uint8_t</span> b = (y[<span class="number">1</span>] - oy) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">2</span>) + </span><br><span class="line">                            (y[<span class="number">1</span>] - oy) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">0</span>] * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (x[<span class="number">1</span>] - ox) * *(imgData + x[<span class="number">0</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                            (oy - y[<span class="number">0</span>]) * (ox - x[<span class="number">0</span>]) * *(imgData + x[<span class="number">1</span>] * <span class="number">3</span> + y[<span class="number">1</span>] * lineBytesOriginal + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                *(rotaData + i * lineBytesRotated + j * <span class="number">3</span>) = r;</span><br><span class="line">                *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">                *(rotaData + i * lineBytesRotated + j * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终效果如图</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/rotation1.bmp" class="" title="This is the rotated image">
<h3 id="图像放缩"><a href="#图像放缩" class="headerlink" title="图像放缩"></a>图像放缩</h3><p>很明显，这里需要用到上文提到的双线性插值算法，我们在这里换一种写法，相信聪明的你一眼就看出来这两种写法是一样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgScale</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">double</span> ratioA, <span class="keyword">double</span> ratioB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newHeight = <span class="built_in">floor</span>(height * ratioA);</span><br><span class="line">    <span class="keyword">int</span> newWidth = <span class="built_in">floor</span>(width * ratioB);</span><br><span class="line">    <span class="keyword">int</span> lineBytesScaled = (bitCount * newWidth / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> lineBytesOriginal = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* scaleData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesScaled * newHeight];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newHeight; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; newWidth; j++) &#123;</span><br><span class="line">            <span class="keyword">double</span> y = i / ratioA;</span><br><span class="line">            <span class="keyword">double</span> x = j / ratioB;</span><br><span class="line">            <span class="keyword">if</span> (y &gt; height - <span class="number">1</span>) y = height - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; width - <span class="number">1</span>) x = width - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> x1 = <span class="built_in">ceil</span>(x), y1 = <span class="built_in">ceil</span>(y), x2 = <span class="built_in">ceil</span>(x) + <span class="number">1</span>, y2 = <span class="built_in">ceil</span>(y) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt; width - <span class="number">1</span>)</span><br><span class="line">                x2 -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (y2 &gt; height - <span class="number">1</span>)</span><br><span class="line">                y2 -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">double</span> u = x + <span class="number">1</span> - x1;</span><br><span class="line">            <span class="keyword">double</span> v = y + <span class="number">1</span> - y1;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = (<span class="number">1</span> - u) * (<span class="number">1</span> - v) * *(imgData + x1 * <span class="number">3</span> + y1 * lineBytesOriginal) +</span><br><span class="line">                        (<span class="number">1</span> - u) * v * *(imgData + x1 * <span class="number">3</span> + y2 * lineBytesOriginal) +</span><br><span class="line">                        u * (<span class="number">1</span> - v) * *(imgData + x2 * <span class="number">3</span> + y1 * lineBytesOriginal) + </span><br><span class="line">                        u * v * *(imgData + x2 * <span class="number">3</span> + y2 * lineBytesOriginal);</span><br><span class="line">            <span class="keyword">uint8_t</span> g = (<span class="number">1</span> - u) * (<span class="number">1</span> - v) * *(imgData + x1 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                        (<span class="number">1</span> - u) * v * *(imgData + x1 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">1</span>) +</span><br><span class="line">                        u * (<span class="number">1</span> - v) * *(imgData + x2 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">1</span>) + </span><br><span class="line">                        u * v * *(imgData + x2 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> b = (<span class="number">1</span> - u) * (<span class="number">1</span> - v) * *(imgData + x1 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                        (<span class="number">1</span> - u) * v * *(imgData + x1 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">2</span>) +</span><br><span class="line">                        u * (<span class="number">1</span> - v) * *(imgData + x2 * <span class="number">3</span> + y1 * lineBytesOriginal + <span class="number">2</span>) + </span><br><span class="line">                        u * v * *(imgData + x2 * <span class="number">3</span> + y2 * lineBytesOriginal + <span class="number">2</span>);</span><br><span class="line">            *(scaleData + i * lineBytesScaled + j * <span class="number">3</span>) = r;</span><br><span class="line">            *(scaleData + i * lineBytesScaled + j * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">            *(scaleData + i * lineBytesScaled + j * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scaleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终横向拉伸一倍效果如下</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/scale.bmp" class="" title="This is the scaled image">
<h3 id="图像错切"><a href="#图像错切" class="headerlink" title="图像错切"></a>图像错切</h3><p>错切的本质是一种线性变换，可以算是学线性代数的时候的矩阵乘法启蒙变换了吧</p>
<p>对于水平错切，我们有矩阵$M$</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} 1 & m \\ 0 & 1 \end{bmatrix}</script><p>其中$m=\tan(\phi)$，也就是说我们将平面上的直线$y=b$错切成了$y=\frac{1}{m}x+b$</p>
<p>很明显，既然有水平错切那就自然有垂直错切，两者在代码上有众多相似之处，因此我们就在这里只实现水平错切</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgShear</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">double</span> ratio)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newWidth = <span class="built_in">floor</span>(height * <span class="built_in">fabs</span>(ratio)) + width;</span><br><span class="line">    <span class="keyword">int</span> lineBytesSheared = (bitCount * newWidth / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> lineBytesOriginal = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* shearData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytesSheared * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ratio &lt; <span class="number">0</span>) offset = ratio * height;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = i;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="built_in">floor</span>(y * ratio) + j - offset;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytesOriginal + j * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytesOriginal + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytesOriginal + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            *(shearData + y * lineBytesSheared + x * <span class="number">3</span>) = r;</span><br><span class="line">            *(shearData + y * lineBytesSheared + x * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">            *(shearData + y * lineBytesSheared + x * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shearData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果比率小于零，那么我们就需要定义一个偏移量<code>offset</code>进行原点偏移，最终结果如下</p>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/shear.bmp" class="" title="This is the sheared image">
<h3 id="图像镜像"><a href="#图像镜像" class="headerlink" title="图像镜像"></a>图像镜像</h3><p>蛮简单的，没啥好说的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgMirror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* mirrorData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytes * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> y,x;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">                y = i;</span><br><span class="line">                x = width - j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                y = height - i - <span class="number">1</span>;</span><br><span class="line">                x = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">uint8_t</span> r = *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> g = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">uint8_t</span> b = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            *(mirrorData + y * lineBytes + x * <span class="number">3</span>) = r;</span><br><span class="line">            *(mirrorData + y * lineBytes + x * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">            *(mirrorData + y * lineBytes + x * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mirrorData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2021/11/20/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A3/mirror.bmp" class="" title="This is the mirrored image">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然看上去这次作业也不算特别难，但是在编写代码的过程中我还是遇到了许多奇妙的问题，比如一些公式的笔误导致最终输出的图像根本不能看</p>
<p>而且有的时候图像的分辨率如果恰好是一个奇妙的数值，那么最后输出的图像就有可能会损坏，因此请随意使用本博客里的图像，它的鲁棒性十分的好</p>
<p>总之就是需要胆大心细地按部就班地编写程序，最终就一定会出现自己预想中的图像</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>图像信息处理Assignment5</title>
    <url>/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/</url>
    <content><![CDATA[<p>第五次图像信息处理作业，大致上就是图像的模糊和锐化吧。</p>
<span id="more"></span>
<h2 id="Assignment-5作业要求"><a href="#Assignment-5作业要求" class="headerlink" title="Assignment-5作业要求"></a>Assignment-5作业要求</h2><ul>
<li>Image mean filtering</li>
<li>Laplacian image enhancement</li>
</ul>
<h2 id="作业分析"><a href="#作业分析" class="headerlink" title="作业分析"></a>作业分析</h2><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><p>其实由上次作业可以知道，图像的处理就是由一系列矩阵变换得到的结果，不过在这次作业中，我们选择的是对像素进行矩阵变换而不是像素坐标，而均值滤波，顾名思义，就是对图像像素取均值得到新的像素值，以$3\times3$矩阵为例，其变换矩阵如下</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix}\frac19 & \frac19 & \frac19 \\ \frac19 & \frac19 & \frac19 \\ \frac19 & \frac19 & \frac19 \\\end{bmatrix}</script><p>值得注意的是，对于边缘的像素值，我们在这里对其进行保留处理。由此我们可以很快的写出代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgMean</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* meanData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytes * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == height - <span class="number">1</span> || j == <span class="number">0</span> || j == width - <span class="number">1</span>) &#123;</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> r = *(imgData + i * lineBytes + j * <span class="number">3</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) +</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) +</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> g = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) +</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) +</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> b = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) +</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) +</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) + *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span>) = (<span class="keyword">uint8_t</span>)(r / <span class="number">9</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = (<span class="keyword">uint8_t</span>)(g / <span class="number">9</span>);</span><br><span class="line">                *(meanData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = (<span class="keyword">uint8_t</span>)(b / <span class="number">9</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> meanData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果对比</p>
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/kagami.bmp" class="" title="This is the origin image">
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/mean_filter.bmp" class="" title="This is the filtered image">
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/a.jpg" class="">
<p>当然我们也可以修改均值滤波的矩阵，例如改成如下</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix}\frac1{16} & \frac18 & \frac1{16} \\ \frac18 & \frac14 & \frac18 \\ \frac1{16} & \frac18 & \frac1{16}\end{bmatrix}</script><p>那么这样图像的亮度也会有些许变化</p>
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/mean_filter1.bmp" class="" title="This is the filtered image">
<h3 id="拉普拉斯图像增强"><a href="#拉普拉斯图像增强" class="headerlink" title="拉普拉斯图像增强"></a>拉普拉斯图像增强</h3><p>这里我们使用拉普拉斯算子进行图像的增强，其中我们需要先计算出拉普拉斯遮罩</p>
<script type="math/tex; mode=display">
\nabla^2 f=\begin{bmatrix}1 & 1 & 1 \\ 1 & -8 & 1 \\ 1 & 1 & 1\end{bmatrix}</script><p>然后我们将原像素减去拉普拉斯遮罩即可得出锐化之后的图像，当然这里需要注意增强后的图像溢色的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint8_t</span>* <span class="title">imgLaplacian</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* imgData, <span class="keyword">int</span> bitCount, <span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lineBytes = (bitCount * width / <span class="number">8</span> + <span class="number">3</span>) / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">uint8_t</span>* lapData = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[lineBytes * height]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == height - <span class="number">1</span> || j == <span class="number">0</span> || j == width - <span class="number">1</span>) &#123;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> r = <span class="number">8</span> * *(imgData + i * lineBytes + j * <span class="number">3</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span>) -</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) -</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span>);</span><br><span class="line">                <span class="keyword">int</span> g = <span class="number">8</span> * *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) -</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) -</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> b = <span class="number">8</span> * *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) -</span><br><span class="line">                            *(imgData + i * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + i * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i - <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) -</span><br><span class="line">                            *(imgData + (i - <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>) - *(imgData + (i + <span class="number">1</span>) * lineBytes + (j + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">                r += *(imgData + i * lineBytes + j * <span class="number">3</span>);</span><br><span class="line">                g += *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">                b += *(imgData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>);</span><br><span class="line">                r = r &gt; <span class="number">255</span> ? <span class="number">255</span> : r;</span><br><span class="line">                g = g &gt; <span class="number">255</span> ? <span class="number">255</span> : g;</span><br><span class="line">                b = b &gt; <span class="number">255</span> ? <span class="number">255</span> : b;</span><br><span class="line">                r = r &lt; <span class="number">0</span> ? <span class="number">0</span> : r;</span><br><span class="line">                g = g &lt; <span class="number">0</span> ? <span class="number">0</span> : g;</span><br><span class="line">                b = b &lt; <span class="number">0</span> ? <span class="number">0</span> : b;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span>) = r;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">1</span>) = g;</span><br><span class="line">                *(lapData + i * lineBytes + j * <span class="number">3</span> + <span class="number">2</span>) = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lapData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果如下</p>
<img src="/2021/11/27/%E5%9B%BE%E5%83%8F%E4%BF%A1%E6%81%AF%E5%A4%84%E7%90%86%E4%BD%9C%E4%B8%9A4/laplacian_filter.bmp" class="" title="This is the laplaced image">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次作业确实还蛮简单的，最后总计的编程时间可能一个小时都不到，不过这些矩阵运算还是十分重要的</p>
<p>同时长远地想，配合别的不同的滤波器可以实现其他不同的效果，可以算是图像滤波的入门体验作业吧</p>
]]></content>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>Ref-Nerf Implement And Speeding Up w/ instant-ngp</title>
    <url>/2022/11/22/Ref-Nerf-Implement/</url>
    <content><![CDATA[<p>好耶，复活了。时隔一年，我学会了不少新东西呢。比如，如何使用 instant-ngp 给 RefNerf 加速。</p>
<span id="more"></span>
<h2 id="Ref-Nerf-Implement-And-Speeding-Up-w-instant-ngp"><a href="#Ref-Nerf-Implement-And-Speeding-Up-w-instant-ngp" class="headerlink" title="Ref-Nerf Implement And Speeding Up w/ instant-ngp"></a>Ref-Nerf Implement And Speeding Up w/ instant-ngp</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CV ，炼丹界的内卷之王。 NeRF ，可谓是 CV 界的内卷之王。在今年的 CVPR 上，<a href="https://dorverbin.github.io/refnerf/">Ref NeRF</a> 作为 Best Student Paper Honorable Mention 横空出世，它基于 mip-NeRF 框架对反射现象进行了建模，在 NeRF 的基础上增加了 opacity, roughness, tint, normal 的估计。本文将会首先介绍一下 Ref NeRF 论文本身，然后简单聊聊复现思路以及使用 instant-ngp 加速的过程。不过目前，Ref NeRF 的复现结果还没有达到令我满意的程度，只是具备雏形，毕竟融合两篇文章的 idea 可能导致冲突，深度学习这种玄学就更是这样了，模型炸了都不知道从哪一个先开始。</p>
<h3 id="Ref-NeRF-论文简析"><a href="#Ref-NeRF-论文简析" class="headerlink" title="Ref-NeRF 论文简析"></a>Ref-NeRF 论文简析</h3><h4 id="反射建模"><a href="#反射建模" class="headerlink" title="反射建模"></a>反射建模</h4><p>Ref-NeRF 的一大亮点就在于它对于反射的建模，根据 Phong 模型，被观察到的光线为：</p>
<script type="math/tex; mode=display">
I_o=k_aI_a+\sum_ik_d(l_i\cdot n)I_i+\sum_ik_s(r_i\cdot v)^pI_i</script><p>其中，下标为 a 的部分与环境光（ambient light）有关；下标含有 d 则与漫反射有关，而下标含有 s 则与镜面高光有关。为了更好地解释 Ref NeRF 的反射模型处理以及回顾一下 Phong 模型这个基础模型，这里对模型简单解释：</p>
<ul>
<li>第一项代表环境光对观察结果的影响：环境光只对结果产生常数 offset</li>
<li>第二项代表了所有光源在物体上产生的漫反射。漫反射与观察方向无关，只要能观察到，就是 “恒定” 的。光源 i ($l_i$ 为其发射的某一光线的方向）发射光越是能垂直表面（与法向平行），漫反射越强。</li>
<li>第三项代表了镜面高光：不一定是完全的镜面反射（所以称之为镜面高光），可以稍显模糊，但是其强度是与视角有关的。$r_i$ 代表了反射光线的方向，$v$ 则代表了观察方向。两者重合（点乘结果接近 1）时，反射较强。指数 p 用于加强衰减，可知 p 越大，$(r_i\cdot v)^p$ 变化越快。也即视线与反射方向重合发生变化时，镜面高光的变化越明显。</li>
</ul>
<p>而我们的 Ref-NeRF 对后面两部分进行了建模：</p>
<script type="math/tex; mode=display">
L_{out}(\hat{\omega_o})\propto\int L_{in}(\hat{\omega_i})f(\hat{\omega_i},\hat{\omega_r})\mathrm d\hat{\omega_i}</script><p>其中，$L_{in}$ 为入射光，$L_{out}$ 为出射光，$f$ 为 BRDF（Bidirectional Reflectance Distribution Function）。很明显，这就是一个关于 $\omega_r$ 的函数，而这个 BRDF 我们试图通过神经网络直接学习出来。不过这也让我有些思考，如果把 Phong 模型换成 Blinn-Phong 模型会不会有所加速？毕竟 Blinn-Phong 模型不需要计算反射方向，而只需要通过平行四边形定理得到观察方向和入射方向的 “法线” 即可。</p>
<h4 id="directional-MLP-的修改"><a href="#directional-MLP-的修改" class="headerlink" title="directional MLP 的修改"></a>directional MLP 的修改</h4><p>在这里作者进行了一个类似于 mip NeRF 光锥采样的操作。在 mip NeRF 中，我们为了达到 mipmap 那样的感觉，进行了个一个光锥上的采样。而在 Ref NeRF 中，作者也认为 “反射” 也不能仅仅考虑单个反射方向。由于物体实际是凹凸不平的，并非完美的镜面，表面法向量并非完全一致。可以认为，物体表面的凹凸起伏（噪声），使得反射发生了一些改变（distortion），物体表面噪声的概率分布，经过反射的数学操作后被映射成了新的分布。</p>
<p>作者在这里使用了一个被称为 vMF 的概率分布，看上去就和高斯分布差不多，甚至有个别称叫做 normalized spherical gaussian 。个人推测作者选这个函数是为了方便进行后续的数学推导以及近似，就 像 mip NeRF 中，将光锥用混合高斯模型进行近似一样。有了此分布，自然需要使用积分将所有可能的反射方向考虑进去。在这里，作者使用了球谐函数进行方向编码，然后对其进行积分。</p>
<script type="math/tex; mode=display">
E_{\hat\omega\sim vMF(\hat\omega_r,\kappa)}\left[Y^m_l(\hat\omega)\right]=\exp(\frac{-l(l+1)}{2\kappa})Y^m_l(\hat\omega)</script><p>其中，$Y^m_l$ 为球谐函数，$\kappa$ 为 vMF 分布的参数，等于粗糙度的倒数。这里的 $l$ 代表了球谐函数的阶数，$l$ 越大，球谐函数的分布越均匀，而 $l$ 越小，球谐函数的分布越集中。$\kappa$ 越小，对于高阶（频）球谐影响越大。这也就反映了这样一个事实：光滑程度减小，高低频信息均有所衰减，但高频信息衰减更严重。</p>
<p>这里作者还给 directional MLP 喂了 $l_i\cdot n$ ，当然不是要建模漫反射，而是考虑到一些稍微复杂一些的效应，如菲涅尔效应（并非全反射，部分反射部分折射，反射所占的比例需要另外计算）等等。</p>
<h4 id="Normal-估计"><a href="#Normal-估计" class="headerlink" title="Normal 估计"></a>Normal 估计</h4><p>作者有言：</p>
<blockquote>
<p>normal vectors estimated from its volume density gradient as in Equation (上面那个) are often extremely noisy</p>
<p>NeRF tends to “fake” specular highlights by embedding emitters inside the object and partially occluding them with a “foggy” diffuse surface</p>
</blockquote>
<p>为此，作者设计了两个正则项，</p>
<ul>
<li>针对第一个问题，作者通过 spatial MLP 预测法向量 $\hat n$ ，将其和梯度法向量 $n^\prime$ 求一个 MSE。</li>
</ul>
<script type="math/tex; mode=display">
L_n=\sum_i\omega_i||{\hat n_i-n_i^\prime}||^2</script><p>由于 $\hat n$ 比较光滑，而 $n^\prime$ 是通过梯度求一阶导数求出来的，不是很光滑，所以我们可以通过光滑的数据给不光滑的梯度学一学，让它更加光滑。至于为何，小编也不知道（bushi），我认为大概是网络比较菜，所以只能学习低频部分，所以比较光滑。</p>
<ul>
<li>针对第二个问题，作者设计了一个正则项，用于惩罚反向的法向量。</li>
</ul>
<script type="math/tex; mode=display">
R_o=\sum_i\omega_i\max\left(0, \hat n_i\cdot\hat{\mathrm d}\right)^2</script><p>其实就是惩罚法向量和光线方向相同的部分，而且和 weight 有关。这就说明：被遮挡的有效背面不会被影响（weight 低），而 fake surface（在半透明 surface 后的 embedded emitter 表面）将会被惩罚（其 density 衰减方向与光线方向一致）。</p>
<p>然后作者说，把这两个正则项放在一起就可以得到一个比较好的效果。</p>
<ul>
<li>对于 $\hat n$ 和 $n^\prime$ 相差较大时，前者可以让网络使得两者相等，从而平滑梯度。</li>
<li>对于两者相差不大时，第二个正则项可以达到惩罚的目的得到更加合理的法向量。</li>
</ul>
<h3 id="复现中的细节"><a href="#复现中的细节" class="headerlink" title="复现中的细节"></a>复现中的细节</h3><h4 id="proposal-network"><a href="#proposal-network" class="headerlink" title="proposal network"></a>proposal network</h4><p>这里我们使用了 proposal network distillation ，而没有选择 stratified sampling 。stratified sampling非常慢（由于coarse network需要forward所有点，fine network也要forward），proposal network则是用浅MLP（5层），forward点后直接输出预测的density，再利用fine network输出的density（weight）进行监督。这样就能完成从fine network到proposal network的蒸馏。</p>
<p>但是雀氏也有一些问题，</p>
<img src="/2022/11/22/Ref-Nerf-Implement/noisy_balls.png" class="" title="why it is so noisy?">
<p>如图，这个球上有很多的噪点，怎么辉石呢？我们推断这是 density 有一些问题，于是进行了一些改动。</p>
<p>​原始prop net输入coarse points之后，输出density，此后coarse points将会被弃用。根据density计算的weight，将指导inverse sampling，fine network的输入只为inverse sampling的结果（也就是说，集中在weight高的地方）。假设，prop net计算的density有缺陷，也即weight有缺陷，在实际的表面附近weight很小，在空域中weight大，那么inverse sampling可能无法在此条光线上采到有效的点。</p>
<p>很简单，就是复用coarse points，将coarse depths（采样的长度）与inverse sampling的采样长度（fine depths）进行拼接，排序。但其实在实现中，要考虑proposal network的weight bound计算。啊，这一步很复杂。可以这么说：</p>
<ul>
<li>proposal network需要预测每一个采样点（fine采样点）的weight上界（weight bound）。上界如何计算？两个fine采样点之间会存在一个采样区间，此区间将会与coarse采样的区间重合，则此fine采样区间的weight上界应该是所有与之有交集的coarse区间weight之和。</li>
<li>coarse points合并到fine points相当于修改了fine采样区间。那么就需要计算更多区间交集。</li>
</ul>
<p>​这样修改，也就使得每条光线上，既有均匀采样的部分（保证了coverage），又使得density大的部分可以有更多采样点。可能有人觉得，不就是增加了一些采样点吗？这样为什么能保证proposal network的学习是正确的呢？很简单，网络不仅有更加充足的输入，fine network提供给proposal network的监督也更加充足了。</p>
<h4 id="instant-ngp"><a href="#instant-ngp" class="headerlink" title="instant ngp"></a>instant ngp</h4><p><a href="https://nvlabs.github.io/instant-ngp/">instant ngp</a> ，一种使用哈希编码用于加速神经网络训练的方法。简单来说，就是通过一个多分辨率的哈希映射到一个向量中，然后再进行插值得到一个训练出来的编码值。</p>

<p>虽然这个东西看上去很好很fancy，但是会有哈希碰撞的问题，作者说这玩意儿可以通过神经网络来学习减少问题，不过我们觉得不行，这会让我们训练出来的玩意儿非常的“粉”。</p>
<img src="/2022/11/22/Ref-Nerf-Implement/collision.png" class="" title="instant ngp collision">
<p>这个就很难受了，两个相距很远的点获得了类似的性质，导致一些没有意义的点也被赋予了奇怪的颜色，有意义的点也变得有很多空洞。为此我们尝试了增大哈希表的大小，但是这样就炸显存了，非常神秘。所以目前正在着手于实现一种更好的采样方法，这样或许可以减少冲突的问题。</p>
]]></content>
      <tags>
        <tag>灵感</tag>
      </tags>
  </entry>
  <entry>
    <title>Burn This Book</title>
    <url>/2022/12/12/Burn-This-Book/</url>
    <content><![CDATA[<h1 id="烧掉这本书"><a href="#烧掉这本书" class="headerlink" title="烧掉这本书"></a>烧掉这本书</h1><h2 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h2><p>点燃这本书，最好从右下开始，让火焰首先将写着“一”的页码吞噬。<br>随后，火焰席卷这张纸，留下枯叶般的黑与雪花般的灰白。</p>
<span id="more"></span>
<h2 id="第二页"><a href="#第二页" class="headerlink" title="第二页"></a>第二页</h2><p>然而你翻开了第二页，<br>说明你没有按照说明书行事，<br>或许你是爱书的，或许你只是闲着无聊。<br>那么就看看这些句读罢！<br>这些句读，本是书写给火焰的情书。</p>
<h2 id="第三页"><a href="#第三页" class="headerlink" title="第三页"></a>第三页</h2><p>白色的纸上印着“版本馆”三个字。<br>没有插图，只有文字。空茫的土地上，立着三个钢铁铸成的大字。<br><strong>版本馆</strong><br>你在这三个大字之中，看到了曾见过的一切书籍，与你读到的一切版本。或许还有一束落在书架上的阳光，它照亮了空中的尘埃与书脊上的文字，或许那是你寻找已久的珍本，或许只是一串无聊的字符。<br>记忆的冷雾笼罩着那栋建筑的轮廓。</p>
<h2 id="第四页"><a href="#第四页" class="headerlink" title="第四页"></a>第四页</h2><p>随后，火焰将吞噬他。<br>当“版本馆”三个字呗被火的光明淹没之时，你仿佛能看到，记忆之雾中的版本馆，在它自己充作燃料的火炬中挣扎，只留下黑色的枯骨。<br>但你并不会伤心，因为你没有失去你的记忆，你失去的只是你手上的这本书。倘若你早早将它点燃，你将失去后文中所有的秘密。倘若，你读完之后再把它点燃，你失去的只是再次回顾的权利。<br>你的记忆是雾，你的遗忘是火。这本书终将燃烧，你记忆中的版本馆也是如此。火炬和时间总是狼狈为奸。</p>
<h2 id="第五页"><a href="#第五页" class="headerlink" title="第五页"></a>第五页</h2><p>请想象，现在是二百三十七年之后。<br>你拿着这本书的孤本（总有些人不会及时将它点燃），残破的枯黄的纸如晚秋的叶子，纸上的文字模糊而难以辨识。<br>但你并没有读到这一页，而是在翻开第一页时就听话地把它点燃了。<br>于是，人类永远失去了这本书。前行的利维坦失去了一片鳞片。</p>
<h2 id="第六页"><a href="#第六页" class="headerlink" title="第六页"></a>第六页</h2><p>然而，这又怎样呢？<br>想想那些在亚历山大图书馆毁灭之时，痛哭流涕的哲人吧！多少人的生命之火被熄灭了。<br>“火刑架上的火焰驱不散黑暗”</p>
<h2 id="第七页"><a href="#第七页" class="headerlink" title="第七页"></a>第七页</h2><p>当亚历山大的女哲人被狂热的教徒用蚌壳千刀万剐时，她是否会想起当年燃烧的图书馆呢？<br>那贪婪的火焰，吞噬着莎草纸上英雄的事迹、哲人的言行。许多史诗与歌谣消失化作尘土，坠入忘川；而生存于字里行间的人们 —— 那些孤本是他们存在过的唯一证据 —— 同样坠入了遗忘的夜，仿佛从未诞生过。<br>那是刀兵的凯旋。短剑与血红的蚌壳划过孕妇柔软的躯体。在那辉煌的火中，世界一片昏黑。</p>
<h2 id="第八页"><a href="#第八页" class="headerlink" title="第八页"></a>第八页</h2><p>希帕提亚死去了。她在愚昧与狂热中死去了，仿佛一本未被翻开、在火中燃烧的书。</p>
<h2 id="第九页"><a href="#第九页" class="headerlink" title="第九页"></a>第九页</h2><p>那个人死在卡廷的土丘上，浓黑的血流出了躯体，也一同带走了他的回忆：古老的华沙城街头的马蹄声、中学时课上讲过的拉丁文、香肠、酸黄瓜与伏特加的味道、音乐会上钢琴家弹奏肖邦一号夜曲时弹错的三个音符、婚姻、女儿出生时自己的欣喜、父亲葬礼上棺椁上的裂痕、俄国人留在自己家窗户上的三个弹孔……<br>无穷无尽的细节足以填满一本厚厚的回忆录。然而在一颗子弹之中，它们灰飞烟灭了。<br>当然，那本行走的回忆录本来也终有毁灭之时。在他弥留之际，他最终说出的话，仿佛是子孙留下的书摘。只是火焰来得太早，有如大雪就将初夏葱绿的田野覆盖。那些初生的苗早早夭亡。</p>
<h2 id="第十页"><a href="#第十页" class="headerlink" title="第十页"></a>第十页</h2><p>刀剑是历史上速生速朽的幽灵，他们在大地之上耀武扬威地流浪，点燃一座座繁荣的城：藏书、建筑、绘画与居民，都在那刀剑之火中呻吟着、寂灭着。<br>随后他们走上王座，吞食着成了活祭品的书。酒足饭饱之后，就把他们眼中的残羹冷炙在广场上付之一炬。品达的诗行与希罗多德的吟唱照亮了他们肥硕的脸。<br>他们贪恋着火炉的温暖，想着用炖得软烂的哲学选段与史书滋养身体、驱散体寒；他们又畏惧那书中的火苗，似乎唯有大地上无尽的黑夜才让他们安心。</p>
<h2 id="第十一页"><a href="#第十一页" class="headerlink" title="第十一页"></a>第十一页</h2><p>然而在那黑夜之中，有一个身影在巷子中潜行着，在死胡同的最深处那面被月光照亮了的白墙上，刻下了这样的字句：</p>
<h2 id="第十二页"><a href="#第十二页" class="headerlink" title="第十二页"></a>第十二页</h2><p>其他人的心脏都稳稳地待在胸腔内，<br>而我的身体呢？<br>浑身上下只有心脏，<br>所至之处都拉响了汽笛。</p>
<h2 id="第十三页"><a href="#第十三页" class="headerlink" title="第十三页"></a>第十三页</h2><p>那午夜的反叛者，叫做书。</p>
<h2 id="第十四页"><a href="#第十四页" class="headerlink" title="第十四页"></a>第十四页</h2><p>“火刑架的火焰驱不散黑暗”</p>
<h2 id="第十五页"><a href="#第十五页" class="headerlink" title="第十五页"></a>第十五页</h2><p>至此，你觉得刀剑之火已然无法舔舐书页的一角。<br>你大笑，你的笑声像是一团火焰，<br>融进了虚幻与碎片。<br>“虚幻呵，早已簇拥着书脊，拼凑出一曲全新的诗篇”<br>可一团绿色的虚拟之火裹挟着这本书，诉说起一个故事。</p>
<h2 id="第十六页"><a href="#第十六页" class="headerlink" title="第十六页"></a>第十六页</h2><p>（注：第十六页至第十九页内容由学习了前文所有内容后的 ChatGPT 生成）</p>
<p>烈焰燃烧着书页，<br>熊熊燃烧着心中的情怀。<br>黑烟升腾，<br>在空中留下一道影子。</p>
<p>但我并不害怕，<br>因为我曾经见过这一幕。<br>我熟悉火焰的脚步，<br>了解它的脾气。</p>
<p>它是我的指南针，<br>指引我走向殿堂。</p>
<p>我的记忆永远不会消失，<br>它们将留在我的心中。<br>一座不朽的纪念碑，<br>见证我的成长。</p>
<h2 id="第十七页"><a href="#第十七页" class="headerlink" title="第十七页"></a>第十七页</h2><p>书籍林立，我不知道该从哪里开始。<br>读书是我的旅程，寻找真正的书。<br>这本书具有魔力，捕捉我的记忆。<br>我不想被暴露，我离开这个地方。<br>我开始新的旅程，寻找属于我的书。</p>
<h2 id="第十八页"><a href="#第十八页" class="headerlink" title="第十八页"></a>第十八页</h2><p>书籍、旅程、寻找、不同的地方。</p>
<h2 id="第十九页"><a href="#第十九页" class="headerlink" title="第十九页"></a>第十九页</h2><p>A: 我来到了一个不同的地方，发现书籍在这里林立。<br>B: 你打算从哪本书开始？<br>A: 我不知道，我只知道我必须读下去。<br>B: 读书会让你变得更好。<br>A: 是的，我相信阅读会对让他们不能轻易地捕捉我的记忆。<br>B: 不要忘了，在你的旅程中，不断寻找新的书籍。<br>A: 是的，我会不断寻找，直到找到真正摆脱了他们。</p>
<h2 id="第二十页"><a href="#第二十页" class="headerlink" title="第二十页"></a>第二十页</h2><p>你甩开虚拟之火，大声疾呼：<br>是谁给予了“虚拟之火”自称火的勇气？<br>焚书的火只是北极的万年冰。<br>将书浸泡、包裹、熄灭。<br>书才是真正的火，跃动着生之激情的火，<br>在书架中、引文里、声带上、<br>或是阅读者的心间，长久地燃烧着。<br>是的，典雅的诗行终将变得古拗难识，<br>而不朽的铭文总似风海间的泡沫。<br>但是书还是燃烧着、燃烧着、<br>那每一个小小的铅字都是一簇烛火。<br>直到遗忘最终把丧钟敲响，<br>那时间烧成的灰烬，仍可以骄傲的说：<br>我曾经照亮过世界！</p>
<h2 id="第二十一页"><a href="#第二十一页" class="headerlink" title="第二十一页"></a>第二十一页</h2><p>因此，烧掉这本书吧。<br>让这本书，以及你将读到的每一本书，在你的心中燃烧。</p>
<p>再见了，在火焰中腾越而起的铅字的灵。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
